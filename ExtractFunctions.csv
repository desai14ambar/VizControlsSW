,Uniq ID,Code
0,Arducopter\afs_copter.cpp_terminate_vehicle,"void AP_AdvancedFailsafe_Copter::terminate_vehicle(void)
{
if (_terminate_action == TERMINATE_ACTION_LAND) {
copter.set_mode(Mode::Number::LAND, ModeReason::TERMINATE)
} else {
copter.motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::SHUT_DOWN)
copter.motors->output()

copter.arming.disarm(AP_Arming::Method::AFS)

SRV_Channels::set_output_limit(SRV_Channel::k_heli_rsc, SRV_Channel::Limit::TRIM)
SRV_Channels::set_output_limit(SRV_Channel::k_heli_tail_rsc, SRV_Channel::Limit::TRIM)
SRV_Channels::set_output_limit(SRV_Channel::k_engine_run_enable, SRV_Channel::Limit::TRIM)
SRV_Channels::set_output_limit(SRV_Channel::k_ignition, SRV_Channel::Limit::TRIM)
SRV_Channels::set_output_limit(SRV_Channel::k_none, SRV_Channel::Limit::TRIM)
SRV_Channels::set_output_limit(SRV_Channel::k_manual, SRV_Channel::Limit::TRIM)
}

SRV_Channels::output_ch_all()
}
"
1,Arducopter\afs_copter.cpp_setup_IO_failsafe,"void AP_AdvancedFailsafe_Copter::setup_IO_failsafe(void)
{
SRV_Channels::set_failsafe_limit(SRV_Channel::k_heli_rsc, SRV_Channel::Limit::TRIM)
SRV_Channels::set_failsafe_limit(SRV_Channel::k_heli_tail_rsc, SRV_Channel::Limit::TRIM)
SRV_Channels::set_failsafe_limit(SRV_Channel::k_engine_run_enable, SRV_Channel::Limit::TRIM)
SRV_Channels::set_failsafe_limit(SRV_Channel::k_ignition, SRV_Channel::Limit::TRIM)
SRV_Channels::set_failsafe_limit(SRV_Channel::k_none, SRV_Channel::Limit::TRIM)
SRV_Channels::set_failsafe_limit(SRV_Channel::k_manual, SRV_Channel::Limit::TRIM)

uint32_t mask = copter.motors->get_motor_mask()
hal.rcout->set_failsafe_pwm(mask, copter.motors->get_pwm_output_min())
}
"
2,Arducopter\afs_copter.cpp_afs_mode,"AP_AdvancedFailsafe::control_mode AP_AdvancedFailsafe_Copter::afs_mode(void)
{
switch (copter.flightmode->mode_number()) {
case Mode::Number::AUTO:
case Mode::Number::AUTO_RTL:
case Mode::Number::GUIDED:
case Mode::Number::RTL:
case Mode::Number::LAND:
return AP_AdvancedFailsafe::AFS_AUTO
default:
break
}
return AP_AdvancedFailsafe::AFS_STABILIZED
}
"
3,Arducopter\AP_Arming.cpp_pre_arm_checks,"bool AP_Arming_Copter::pre_arm_checks(bool display_failure)
{
const bool passed = run_pre_arm_checks(display_failure)
set_pre_arm_check(passed)
return passed
}
"
4,Arducopter\AP_Arming.cpp_run_pre_arm_checks,"bool AP_Arming_Copter::run_pre_arm_checks(bool display_failure)
{
if (copter.motors->armed()) {
return true
}

if (rc().find_channel_for_option(RC_Channel::AUX_FUNC::MOTOR_INTERLOCK) &&
(rc().find_channel_for_option(RC_Channel::AUX_FUNC::MOTOR_ESTOP) ||
rc().find_channel_for_option(RC_Channel::AUX_FUNC::ARM_EMERGENCY_STOP))){
check_failed(display_failure, ""Interlock/E-Stop Conflict"")
return false
}

if (copter.ap.using_interlock && copter.ap.motor_interlock_switch) {
check_failed(display_failure, ""Motor Interlock Enabled"")
return false
}

if (SRV_Channels::get_emergency_stop()){
check_failed(display_failure, ""Motor Emergency Stopped"")
return false
}

if (!disarm_switch_checks(display_failure)) {
return false
}

char failure_msg[50] {}
if (!copter.motors->arming_checks(ARRAY_SIZE(failure_msg), failure_msg)) {
check_failed(display_failure, ""Motors: %s"", failure_msg)
return false
}

if (checks_to_perform == 0) {
return mandatory_checks(display_failure)
}

return parameter_checks(display_failure)
& oa_checks(display_failure)
& gcs_failsafe_check(display_failure)
& winch_checks(display_failure)
& rc_throttle_failsafe_checks(display_failure)
& alt_checks(display_failure)
& AP_Arming::airspeed_checks(display_failure)
& AP_Arming::pre_arm_checks(display_failure)
}
"
5,Arducopter\AP_Arming.cpp_rc_throttle_failsafe_checks,"bool AP_Arming_Copter::rc_throttle_failsafe_checks(bool display_failure) const
{
if ((checks_to_perform != ARMING_CHECK_ALL) &&
(checks_to_perform & ARMING_CHECK_RC) == 0) {
return true
}

if (copter.g.failsafe_throttle == FS_THR_DISABLED) {
return true
}

const char *rc_item = ""Collective""
const char *rc_item = ""Throttle""

if (!rc().has_had_rc_receiver()) {
check_failed(ARMING_CHECK_RC, display_failure, ""RC not found"")
return false
}

if (copter.channel_throttle->get_radio_in() < copter.g.failsafe_throttle_value) {
check_failed(ARMING_CHECK_RC, display_failure, ""%s below failsafe"", rc_item)
return false
}

return true
}
"
6,Arducopter\AP_Arming.cpp_barometer_checks,"bool AP_Arming_Copter::barometer_checks(bool display_failure)
{
if (!AP_Arming::barometer_checks(display_failure)) {
return false
}

bool ret = true
if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_BARO)) {
nav_filter_status filt_status = copter.inertial_nav.get_filter_status()
bool using_baro_ref = (!filt_status.flags.pred_horiz_pos_rel && filt_status.flags.pred_horiz_pos_abs)
if (using_baro_ref) {
if (fabsf(copter.inertial_nav.get_position_z_up_cm() - copter.baro_alt) > PREARM_MAX_ALT_DISPARITY_CM) {
check_failed(ARMING_CHECK_BARO, display_failure, ""Altitude disparity"")
ret = false
}
}
}
return ret
}
"
7,Arducopter\AP_Arming.cpp_ins_checks,"bool AP_Arming_Copter::ins_checks(bool display_failure)
{
bool ret = AP_Arming::ins_checks(display_failure)

if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {

if (!pre_arm_ekf_attitude_check()) {
check_failed(ARMING_CHECK_INS, display_failure, ""EKF attitude is bad"")
ret = false
}
}

return ret
}
"
8,Arducopter\AP_Arming.cpp_board_voltage_checks,"bool AP_Arming_Copter::board_voltage_checks(bool display_failure)
{
if (!AP_Arming::board_voltage_checks(display_failure)) {
return false
}

if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_VOLTAGE)) {
if (copter.battery.has_failsafed()) {
check_failed(ARMING_CHECK_VOLTAGE, display_failure, ""Battery failsafe"")
return false
}
}

return true
}
"
9,Arducopter\AP_Arming.cpp_terrain_database_required,"bool AP_Arming_Copter::terrain_database_required() const
{
if (copter.wp_nav->get_terrain_source() == AC_WPNav::TerrainSource::TERRAIN_FROM_TERRAINDATABASE &&
copter.mode_rtl.get_alt_type() == ModeRTL::RTLAltType::RTL_ALTTYPE_TERRAIN) {
return true
}
return AP_Arming::terrain_database_required()
}
"
10,Arducopter\AP_Arming.cpp_parameter_checks,"bool AP_Arming_Copter::parameter_checks(bool display_failure)
{
if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_PARAMETERS)) {

if (copter.g.failsafe_throttle) {
if (copter.channel_throttle->get_radio_min() <= copter.g.failsafe_throttle_value+10 || copter.g.failsafe_throttle_value < 910) {
check_failed(ARMING_CHECK_PARAMETERS, display_failure, ""Check FS_THR_VALUE"")
return false
}
}
if (copter.g.failsafe_gcs == FS_GCS_ENABLED_CONTINUE_MISSION) {
check_failed(ARMING_CHECK_PARAMETERS, display_failure, ""FS_GCS_ENABLE=2 removed, see FS_OPTIONS"")
}

if (copter.aparm.angle_max < 1000 || copter.aparm.angle_max > 8000) {
check_failed(ARMING_CHECK_PARAMETERS, display_failure, ""Check ANGLE_MAX"")
return false
}

if ((copter.g.acro_balance_roll > copter.attitude_control->get_angle_roll_p().kP()) || (copter.g.acro_balance_pitch > copter.attitude_control->get_angle_pitch_p().kP())) {
check_failed(ARMING_CHECK_PARAMETERS, display_failure, ""Check ACRO_BAL_ROLL/PITCH"")
return false
}

if (copter.g.pilot_speed_up <= 0) {
check_failed(ARMING_CHECK_PARAMETERS, display_failure, ""Check PILOT_SPEED_UP"")
return false
}

if (copter.g2.frame_class.get() != AP_Motors::MOTOR_FRAME_HELI_QUAD &&
copter.g2.frame_class.get() != AP_Motors::MOTOR_FRAME_HELI_DUAL &&
copter.g2.frame_class.get() != AP_Motors::MOTOR_FRAME_HELI) {
check_failed(ARMING_CHECK_PARAMETERS, display_failure, ""Invalid Heli FRAME_CLASS"")
return false
}

if (!copter.motors->parameter_check(display_failure)) {
check_failed(ARMING_CHECK_PARAMETERS, display_failure, ""Heli motors checks failed"")
return false
}

char fail_msg[50]
if (!copter.input_manager.parameter_check(fail_msg, ARRAY_SIZE(fail_msg))) {
check_failed(ARMING_CHECK_PARAMETERS, display_failure, ""%s"", fail_msg)
return false
}

if (copter.g2.frame_class.get() != AP_Motors::MOTOR_FRAME_HELI_QUAD &&
rc().find_channel_for_option(RC_Channel::aux_func_t::INVERTED) != nullptr) {
check_failed(ARMING_CHECK_PARAMETERS, display_failure, ""Inverted flight option not supported"")
return false
}
if (rc().find_channel_for_option(RC_Channel::aux_func_t::MOTOR_INTERLOCK) == nullptr) {
check_failed(ARMING_CHECK_PARAMETERS, display_failure, ""Motor Interlock not configured"")
return false
}

if (copter.g2.frame_class.get() == AP_Motors::MOTOR_FRAME_HELI_QUAD ||
copter.g2.frame_class.get() == AP_Motors::MOTOR_FRAME_HELI_DUAL ||
copter.g2.frame_class.get() == AP_Motors::MOTOR_FRAME_HELI) {
check_failed(ARMING_CHECK_PARAMETERS, display_failure, ""Invalid MultiCopter FRAME_CLASS"")
return false
}

if (copter.mode_rtl.get_alt_type() == ModeRTL::RTLAltType::RTL_ALTTYPE_TERRAIN) {
const char *failure_template = ""RTL_ALT_TYPE is above-terrain but %s""
switch (copter.wp_nav->get_terrain_source()) {
case AC_WPNav::TerrainSource::TERRAIN_UNAVAILABLE:
check_failed(ARMING_CHECK_PARAMETERS, display_failure, failure_template, ""no terrain data"")
return false
break
case AC_WPNav::TerrainSource::TERRAIN_FROM_RANGEFINDER:
if (!copter.rangefinder_state.enabled || !copter.rangefinder.has_orientation(ROTATION_PITCH_270)) {
check_failed(ARMING_CHECK_PARAMETERS, display_failure, failure_template, ""no rangefinder"")
return false
}
if (copter.g.rtl_altitude > copter.rangefinder.max_distance_cm_orient(ROTATION_PITCH_270)) {
check_failed(ARMING_CHECK_PARAMETERS, display_failure, failure_template, ""RTL_ALT>RNGFND_MAX_CM"")
return false
}
break
case AC_WPNav::TerrainSource::TERRAIN_FROM_TERRAINDATABASE:
break
}
}

if (copter.failsafe.adsb) {
check_failed(ARMING_CHECK_PARAMETERS, display_failure, ""ADSB threat detected"")
return false
}

char failure_msg[50] = {}
if (!copter.pos_control->pre_arm_checks(""PSC"", failure_msg, ARRAY_SIZE(failure_msg))) {
check_failed(ARMING_CHECK_PARAMETERS, display_failure, ""Bad parameter: %s"", failure_msg)
return false
}
if (!copter.attitude_control->pre_arm_checks(""ATC"", failure_msg, ARRAY_SIZE(failure_msg))) {
check_failed(ARMING_CHECK_PARAMETERS, display_failure, ""Bad parameter: %s"", failure_msg)
return false
}
}

return true
}
"
11,Arducopter\AP_Arming.cpp_oa_checks,"bool AP_Arming_Copter::oa_checks(bool display_failure)
{
char failure_msg[50] = {}
if (copter.g2.oa.pre_arm_check(failure_msg, ARRAY_SIZE(failure_msg))) {
return true
}
if (strlen(failure_msg) == 0) {
check_failed(display_failure, ""%s"", ""Check Object Avoidance"")
} else {
check_failed(display_failure, ""%s"", failure_msg)
}
return false
return true
}
"
12,Arducopter\AP_Arming.cpp_rc_calibration_checks,"bool AP_Arming_Copter::rc_calibration_checks(bool display_failure)
{
const RC_Channel *channels[] = {
copter.channel_roll,
copter.channel_pitch,
copter.channel_throttle,
copter.channel_yaw
}

copter.ap.pre_arm_rc_check = rc_checks_copter_sub(display_failure, channels)
& AP_Arming::rc_calibration_checks(display_failure)

return copter.ap.pre_arm_rc_check
}
"
13,Arducopter\AP_Arming.cpp_gps_checks,"bool AP_Arming_Copter::gps_checks(bool display_failure)
{
bool fence_requires_gps = false
fence_requires_gps = (copter.fence.get_enabled_fences() & (AC_FENCE_TYPE_CIRCLE | AC_FENCE_TYPE_POLYGON)) > 0

bool mode_requires_gps = copter.flightmode->requires_GPS() || fence_requires_gps || (copter.simple_mode == Copter::SimpleMode::SUPERSIMPLE)

if (mode_requires_gps) {
if (!AP_Arming::gps_checks(display_failure)) {
AP_Notify::flags.pre_arm_gps_check = false
return false
}
}

if (!mandatory_gps_checks(display_failure)) {
AP_Notify::flags.pre_arm_gps_check = false
return false
}

if (!mode_requires_gps) {
AP_Notify::flags.pre_arm_gps_check = true
return true
}

if (!(checks_to_perform == ARMING_CHECK_ALL || checks_to_perform & ARMING_CHECK_GPS)) {
AP_Notify::flags.pre_arm_gps_check = true
return true
}

if (copter.gps.get_hdop() > copter.g.gps_hdop_good) {
check_failed(ARMING_CHECK_GPS, display_failure, ""High GPS HDOP"")
AP_Notify::flags.pre_arm_gps_check = false
return false
}

AP_Notify::flags.pre_arm_gps_check = true
return true
}
"
14,Arducopter\AP_Arming.cpp_pre_arm_ekf_attitude_check,"bool AP_Arming_Copter::pre_arm_ekf_attitude_check()
{
nav_filter_status filt_status = copter.inertial_nav.get_filter_status()

return filt_status.flags.attitude
}
"
15,Arducopter\AP_Arming.cpp_proximity_checks,"bool AP_Arming_Copter::proximity_checks(bool display_failure) const
{

if (!AP_Arming::proximity_checks(display_failure)) {
return false
}

if (!((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_PARAMETERS))) {
return true
}

float angle_deg, distance
if (copter.avoid.proximity_avoidance_enabled() && copter.g2.proximity.get_closest_object(angle_deg, distance)) {
const float tolerance = 0.6f
if (distance <= tolerance) {
check_failed(ARMING_CHECK_PARAMETERS, display_failure, ""Proximity %d deg, %4.2fm (want > %0.1fm)"", (int)angle_deg, (double)distance, (double)tolerance)
return false
}
}

return true
}
"
16,Arducopter\AP_Arming.cpp_mandatory_gps_checks,"bool AP_Arming_Copter::mandatory_gps_checks(bool display_failure)
{
bool mode_requires_gps = copter.flightmode->requires_GPS()

const auto &ahrs = AP::ahrs()
char failure_msg[50] = {}
if (!ahrs.pre_arm_check(mode_requires_gps, failure_msg, sizeof(failure_msg))) {
check_failed(display_failure, ""AHRS: %s"", failure_msg)
return false
}

bool fence_requires_gps = false
fence_requires_gps = (copter.fence.get_enabled_fences() & (AC_FENCE_TYPE_CIRCLE | AC_FENCE_TYPE_POLYGON)) > 0

if (mode_requires_gps) {
if (!copter.position_ok()) {
check_failed(display_failure, ""Need Position Estimate"")
return false
}
} else {
if (fence_requires_gps) {
if (!copter.position_ok()) {
check_failed(display_failure, ""Fence enabled, need position estimate"")
return false
}
} else {
return true
}
}

nav_filter_status filt_status
if (ahrs.get_filter_status(filt_status)) {
if (filt_status.flags.gps_glitching) {
check_failed(display_failure, ""GPS glitching"")
return false
}
}

if (copter.g.fs_ekf_thresh > 0.0f) {
float vel_variance, pos_variance, hgt_variance, tas_variance
Vector3f mag_variance
ahrs.get_variances(vel_variance, pos_variance, hgt_variance, mag_variance, tas_variance)
if (mag_variance.length() >= copter.g.fs_ekf_thresh) {
check_failed(display_failure, ""EKF compass variance"")
return false
}
if (pos_variance >= copter.g.fs_ekf_thresh) {
check_failed(display_failure, ""EKF position variance"")
return false
}
if (vel_variance >= copter.g.fs_ekf_thresh) {
check_failed(display_failure, ""EKF velocity variance"")
return false
}
if (hgt_variance >= copter.g.fs_ekf_thresh) {
check_failed(display_failure, ""EKF height variance"")
return false
}
}

if (copter.far_from_EKF_origin(ahrs.get_home())) {
check_failed(display_failure, ""Home too far from EKF origin"")
return false
}

if (copter.far_from_EKF_origin(copter.current_loc)) {
check_failed(display_failure, ""Vehicle too far from EKF origin"")
return false
}

return true
}
"
17,Arducopter\AP_Arming.cpp_gcs_failsafe_check,"bool AP_Arming_Copter::gcs_failsafe_check(bool display_failure)
{
if (copter.failsafe.gcs) {
check_failed(display_failure, ""GCS failsafe on"")
return false
}
return true
}
"
18,Arducopter\AP_Arming.cpp_winch_checks,"bool AP_Arming_Copter::winch_checks(bool display_failure) const
{
if (((checks_to_perform & ARMING_CHECK_ALL) == 0) && ((checks_to_perform & ARMING_CHECK_PARAMETERS) == 0)) {
return true
}

const AP_Winch *winch = AP::winch()
if (winch == nullptr) {
return true
}
char failure_msg[50] = {}
if (!winch->pre_arm_check(failure_msg, sizeof(failure_msg))) {
check_failed(display_failure, ""%s"", failure_msg)
return false
}
return true
}
"
19,Arducopter\AP_Arming.cpp_alt_checks,"bool AP_Arming_Copter::alt_checks(bool display_failure)
{
if (!copter.flightmode->has_manual_throttle() && !copter.ekf_alt_ok()) {
check_failed(display_failure, ""Need Alt Estimate"")
return false
}

return true
}
"
20,Arducopter\AP_Arming.cpp_arm_checks,"bool AP_Arming_Copter::arm_checks(AP_Arming::Method method)
{
const auto &ahrs = AP::ahrs()

if (!ahrs.healthy()) {
check_failed(true, ""AHRS not healthy"")
return false
}

if (!ahrs.using_noncompass_for_yaw()) {
const Compass &_compass = AP::compass()
if (!_compass.healthy()) {
check_failed(true, ""Compass not healthy"")
return false
}
}

if (!copter.flightmode->allows_arming(method)) {
check_failed(true, ""%s mode not armable"", copter.flightmode->name())
return false
}

if (checks_to_perform == 0) {
return true
}

if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {
if (degrees(acosf(ahrs.cos_roll()*ahrs.cos_pitch()))*100.0f > copter.aparm.angle_max) {
check_failed(ARMING_CHECK_INS, true, ""Leaning"")
return false
}
}

if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_PARAMETERS)) {
if (copter.failsafe.adsb) {
check_failed(ARMING_CHECK_PARAMETERS, true, ""ADSB threat detected"")
return false
}
}

if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_RC)) {
const char *rc_item = ""Collective""
const char *rc_item = ""Throttle""
if (!(method == AP_Arming::Method::MAVLINK && (copter.flightmode->mode_number() == Mode::Number::GUIDED || copter.flightmode->mode_number() == Mode::Number::GUIDED_NOGPS))) {
if (copter.get_pilot_desired_climb_rate(copter.channel_throttle->get_control_in()) > 0.0f) {
check_failed(ARMING_CHECK_RC, true, ""%s too high"", rc_item)
return false
}
if ((copter.flightmode->has_manual_throttle() || copter.flightmode->mode_number() == Mode::Number::DRIFT) && copter.channel_throttle->get_control_in() > 0) {
check_failed(ARMING_CHECK_RC, true, ""%s too high"", rc_item)
return false
}
}
}

if (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {
check_failed(true, ""Safety Switch"")
return false
}

return AP_Arming::arm_checks(method)
}
"
21,Arducopter\AP_Arming.cpp_mandatory_checks,"bool AP_Arming_Copter::mandatory_checks(bool display_failure)
{
bool result = mandatory_gps_checks(display_failure)
AP_Notify::flags.pre_arm_gps_check = result

if (!alt_checks(display_failure)) {
result = false
}

return result & AP_Arming::mandatory_checks(display_failure)
}
"
22,Arducopter\AP_Arming.cpp_set_pre_arm_check,"void AP_Arming_Copter::set_pre_arm_check(bool b)
{
copter.ap.pre_arm_check = b
AP_Notify::flags.pre_arm_check = b
}
"
23,Arducopter\AP_Arming.cpp_arm,"bool AP_Arming_Copter::arm(const AP_Arming::Method method, const bool do_arming_checks)
{
static bool in_arm_motors = false

if (in_arm_motors) {
return false
}
in_arm_motors = true

if (copter.motors->armed()) {
in_arm_motors = false
return true
}

if (!AP_Arming::arm(method, do_arming_checks)) {
AP_Notify::events.arming_failed = true
in_arm_motors = false
return false
}

AP::logger().set_vehicle_armed(true)

copter.failsafe_disable()

AP_Notify::flags.armed = true
for (uint8_t i=0
AP::notify().update()
}

gcs().send_text(MAV_SEVERITY_INFO, ""Arming motors"")

copter.init_simple_bearing()

auto &ahrs = AP::ahrs()

copter.initial_armed_bearing = ahrs.yaw_sensor

if (!ahrs.home_is_set()) {
ahrs.resetHeightDatum()
AP::logger().Write_Event(LogEvent::EKF_ALT_RESET)

copter.arming_altitude_m = 0
} else if (!ahrs.home_is_locked()) {
if (!copter.set_home_to_current_location(false)) {
}

copter.arming_altitude_m = copter.inertial_nav.get_position_z_up_cm() * 0.01
}
copter.update_super_simple_bearing(false)

copter.g2.smart_rtl.set_home(copter.position_ok())

hal.util->set_soft_armed(true)

copter.sprayer.test_pump(false)

copter.enable_motor_output()

copter.motors->armed(true)

AP::logger().Write_Mode((uint8_t)copter.flightmode->mode_number(), copter.control_mode_reason)

copter.failsafe_enable()

AP::scheduler().perf_info.ignore_this_loop()

in_arm_motors = false

copter.arm_time_ms = millis()

copter.ap.in_arming_delay = true

copter.ap.armed_with_airmode_switch = false

return true
}
"
24,Arducopter\AP_Arming.cpp_disarm,"bool AP_Arming_Copter::disarm(const AP_Arming::Method method, bool do_disarm_checks)
{
if (!copter.motors->armed()) {
return true
}

if (do_disarm_checks &&
method == AP_Arming::Method::MAVLINK &&
!copter.ap.land_complete) {
return false
}

if (!AP_Arming::disarm(method, do_disarm_checks)) {
return false
}

gcs().send_text(MAV_SEVERITY_INFO, ""Disarming motors"")

auto &ahrs = AP::ahrs()

Compass &compass = AP::compass()
if (ahrs.use_compass() && compass.get_learn_type() == Compass::LEARN_EKF) {
for(uint8_t i=0
Vector3f magOffsets
if (ahrs.getMagOffsets(i, magOffsets)) {
compass.set_and_save_offsets(i, magOffsets)
}
}
}

if (copter.flightmode == &copter.mode_autotune) {
copter.mode_autotune.save_tuning_gains()
} else {
copter.mode_autotune.reset()
}

copter.set_land_complete(true)
copter.set_land_complete_maybe(true)

copter.motors->armed(false)

copter.mode_auto.mission.reset()

AP::logger().set_vehicle_armed(false)

hal.util->set_soft_armed(false)

copter.ap.in_arming_delay = false

return true
}
"
25,Arducopter\AP_Rally.cpp_is_valid,"bool AP_Rally_Copter::is_valid(const Location &rally_point) const
{
if (!copter.fence.check_destination_within_fence(rally_point)) {
return false
}
return true
}
"
26,Arducopter\AP_State.cpp_set_auto_armed,"void Copter::set_auto_armed(bool b)
{
if( ap.auto_armed == b )
return

ap.auto_armed = b
if(b){
AP::logger().Write_Event(LogEvent::AUTO_ARMED)
}
}
"
27,Arducopter\AP_State.cpp_set_simple_mode,"void Copter::set_simple_mode(SimpleMode b)
{
if (simple_mode != b) {
switch (b) {
case SimpleMode::NONE:
AP::logger().Write_Event(LogEvent::SET_SIMPLE_OFF)
gcs().send_text(MAV_SEVERITY_INFO, ""SIMPLE mode off"")
break
case SimpleMode::SIMPLE:
AP::logger().Write_Event(LogEvent::SET_SIMPLE_ON)
gcs().send_text(MAV_SEVERITY_INFO, ""SIMPLE mode on"")
break
case SimpleMode::SUPERSIMPLE:
update_super_simple_bearing(true)
AP::logger().Write_Event(LogEvent::SET_SUPERSIMPLE_ON)
gcs().send_text(MAV_SEVERITY_INFO, ""SUPERSIMPLE mode on"")
break
}
simple_mode = b
}
}
"
28,Arducopter\AP_State.cpp_set_failsafe_radio,"void Copter::set_failsafe_radio(bool b)
{
if(failsafe.radio != b) {

failsafe.radio = b

if (failsafe.radio == false) {
failsafe_radio_off_event()
}else{
failsafe_radio_on_event()
}

AP_Notify::flags.failsafe_radio = b
}
}
"
29,Arducopter\AP_State.cpp_set_failsafe_gcs,"void Copter::set_failsafe_gcs(bool b)
{
failsafe.gcs = b

AP_Notify::flags.failsafe_gcs = b
}
"
30,Arducopter\AP_State.cpp_update_using_interlock,"void Copter::update_using_interlock()
{
ap.using_interlock = true
ap.using_interlock = rc().find_channel_for_option(RC_Channel::AUX_FUNC::MOTOR_INTERLOCK) != nullptr
}
"
31,Arducopter\Attitude.cpp_update_throttle_hover,"void Copter::update_throttle_hover()
{
if (!motors->armed() || ap.land_complete || standby_active) {
return
}

if (flightmode->has_manual_throttle() || (copter.flightmode->mode_number() == Mode::Number::DRIFT)) {
return
}

if (!is_zero(pos_control->get_vel_desired_cms().z)) {
return
}

float throttle = motors->get_throttle()

if (throttle > 0.0f && fabsf(inertial_nav.get_velocity_z_up_cms()) < 60 &&
fabsf(ahrs.roll_sensor-attitude_control->get_roll_trim_cd()) < 500 && labs(ahrs.pitch_sensor) < 500) {
motors->update_throttle_hover(0.01f)
gyro_fft.update_freq_hover(0.01f, motors->get_throttle_out())
}
}
"
32,Arducopter\Attitude.cpp_get_pilot_desired_climb_rate,"float Copter::get_pilot_desired_climb_rate(float throttle_control)
{
if (failsafe.radio || !ap.rc_receiver_present) {
return 0.0f
}

if (g2.toy_mode.enabled()) {
g2.toy_mode.throttle_adjust(throttle_control)
}

throttle_control = constrain_float(throttle_control,0.0f,1000.0f)

g.throttle_deadzone.set(constrain_int16(g.throttle_deadzone, 0, 400))

float desired_rate = 0.0f
const float mid_stick = get_throttle_mid()
const float deadband_top = mid_stick + g.throttle_deadzone
const float deadband_bottom = mid_stick - g.throttle_deadzone

if (throttle_control < deadband_bottom) {
desired_rate = get_pilot_speed_dn() * (throttle_control-deadband_bottom) / deadband_bottom
} else if (throttle_control > deadband_top) {
desired_rate = g.pilot_speed_up * (throttle_control-deadband_top) / (1000.0f-deadband_top)
} else {
desired_rate = 0.0f
}

return desired_rate
}
"
33,Arducopter\Attitude.cpp_get_non_takeoff_throttle,"float Copter::get_non_takeoff_throttle()
{
return MAX(0,motors->get_throttle_hover()/2.0f)
}
"
34,Arducopter\Attitude.cpp_set_accel_throttle_I_from_pilot_throttle,"void Copter::set_accel_throttle_I_from_pilot_throttle()
{
float pilot_throttle = constrain_float(attitude_control->get_throttle_in(), 0.0f, 1.0f)
pos_control->get_accel_z_pid().set_integrator((pilot_throttle-motors->get_throttle_hover()) * 1000.0f)
}
"
35,Arducopter\Attitude.cpp_rotate_body_frame_to_NE,"void Copter::rotate_body_frame_to_NE(float &x, float &y)
{
float ne_x = x*ahrs.cos_yaw() - y*ahrs.sin_yaw()
float ne_y = x*ahrs.sin_yaw() + y*ahrs.cos_yaw()
x = ne_x
y = ne_y
}
"
36,Arducopter\Attitude.cpp_get_pilot_speed_dn,"uint16_t Copter::get_pilot_speed_dn() const
{
if (g2.pilot_speed_dn == 0) {
return abs(g.pilot_speed_up)
} else {
return abs(g2.pilot_speed_dn)
}
}
"
37,Arducopter\autoyaw.cpp_roi_yaw,"float Mode::AutoYaw::roi_yaw() const
{
return get_bearing_cd(copter.inertial_nav.get_position_xy_cm(), roi.xy())
}
"
38,Arducopter\autoyaw.cpp_look_ahead_yaw,"float Mode::AutoYaw::look_ahead_yaw()
{
const Vector3f& vel = copter.inertial_nav.get_velocity_neu_cms()
const float speed_sq = vel.xy().length_squared()
if (copter.position_ok() && (speed_sq > (YAW_LOOK_AHEAD_MIN_SPEED * YAW_LOOK_AHEAD_MIN_SPEED))) {
_look_ahead_yaw = degrees(atan2f(vel.y,vel.x))*100.0f
}
return _look_ahead_yaw
}
"
39,Arducopter\autoyaw.cpp_set_mode_to_default,"void Mode::AutoYaw::set_mode_to_default(bool rtl)
{
set_mode(default_mode(rtl))
}
"
40,Arducopter\autoyaw.cpp_default_mode,"autopilot_yaw_mode Mode::AutoYaw::default_mode(bool rtl) const
{
switch (copter.g.wp_yaw_behavior) {

case WP_YAW_BEHAVIOR_NONE:
return AUTO_YAW_HOLD

case WP_YAW_BEHAVIOR_LOOK_AT_NEXT_WP_EXCEPT_RTL:
if (rtl) {
return AUTO_YAW_HOLD
} else {
return AUTO_YAW_LOOK_AT_NEXT_WP
}

case WP_YAW_BEHAVIOR_LOOK_AHEAD:
return AUTO_YAW_LOOK_AHEAD

case WP_YAW_BEHAVIOR_LOOK_AT_NEXT_WP:
default:
return AUTO_YAW_LOOK_AT_NEXT_WP
}
}
"
41,Arducopter\autoyaw.cpp_set_mode,"void Mode::AutoYaw::set_mode(autopilot_yaw_mode yaw_mode)
{
if (_mode == yaw_mode) {
return
}
_mode = yaw_mode

switch (_mode) {

case AUTO_YAW_HOLD:
break

case AUTO_YAW_LOOK_AT_NEXT_WP:
break

case AUTO_YAW_ROI:
break

case AUTO_YAW_FIXED:
break

case AUTO_YAW_LOOK_AHEAD:
_look_ahead_yaw = copter.ahrs.yaw_sensor
break

case AUTO_YAW_RESETTOARMEDYAW:
break

case AUTO_YAW_ANGLE_RATE:
break

case AUTO_YAW_RATE:
_yaw_rate_cds = 0.0f
break

case AUTO_YAW_CIRCLE:
break
}
}
"
42,Arducopter\autoyaw.cpp_set_fixed_yaw,"void Mode::AutoYaw::set_fixed_yaw(float angle_deg, float turn_rate_ds, int8_t direction, bool relative_angle)
{
_last_update_ms = millis()

_yaw_angle_cd = copter.attitude_control->get_att_target_euler_cd().z
_yaw_rate_cds = 0.0

if (relative_angle) {
_fixed_yaw_offset_cd = angle_deg * 100.0 * (direction >= 0 ? 1.0 : -1.0)
} else {
_fixed_yaw_offset_cd = wrap_180_cd(angle_deg * 100.0 - _yaw_angle_cd)
if ( direction < 0 && is_positive(_fixed_yaw_offset_cd) ) {
_fixed_yaw_offset_cd -= 36000.0
} else if ( direction > 0 && is_negative(_fixed_yaw_offset_cd) ) {
_fixed_yaw_offset_cd += 36000.0
}
}

if (!is_positive(turn_rate_ds)) {
_fixed_yaw_slewrate_cds = copter.attitude_control->get_slew_yaw_max_degs() * 100.0
} else {
_fixed_yaw_slewrate_cds = MIN(copter.attitude_control->get_slew_yaw_max_degs(), turn_rate_ds) * 100.0
}

set_mode(AUTO_YAW_FIXED)
}
"
43,Arducopter\autoyaw.cpp_set_yaw_angle_rate,"void Mode::AutoYaw::set_yaw_angle_rate(float yaw_angle_d, float yaw_rate_ds)
{
_last_update_ms = millis()

_yaw_angle_cd = yaw_angle_d * 100.0
_yaw_rate_cds = yaw_rate_ds * 100.0

set_mode(AUTO_YAW_ANGLE_RATE)
}
"
44,Arducopter\autoyaw.cpp_set_roi,"void Mode::AutoYaw::set_roi(const Location &roi_location)
{
if (roi_location.alt == 0 && roi_location.lat == 0 && roi_location.lng == 0) {
auto_yaw.set_mode_to_default(false)
if (copter.camera_mount.get_mode() == MAV_MOUNT_MODE_GPS_POINT) {
copter.camera_mount.set_mode_to_default()
}
} else {
if (!copter.camera_mount.has_pan_control()) {
if (roi_location.get_vector_from_origin_NEU(roi)) {
auto_yaw.set_mode(AUTO_YAW_ROI)
}
}
copter.camera_mount.set_roi_target(roi_location)

if (roi_location.get_vector_from_origin_NEU(roi)) {
auto_yaw.set_mode(AUTO_YAW_ROI)
}
}
}
"
45,Arducopter\autoyaw.cpp_set_rate,"void Mode::AutoYaw::set_rate(float turn_rate_cds)
{
set_mode(AUTO_YAW_RATE)
_yaw_rate_cds = turn_rate_cds
}
"
46,Arducopter\autoyaw.cpp_yaw,"float Mode::AutoYaw::yaw()
{
switch (_mode) {

case AUTO_YAW_ROI:
return roi_yaw()

case AUTO_YAW_FIXED: {
const uint32_t now_ms = millis()
float dt = (now_ms - _last_update_ms) * 0.001
_last_update_ms = now_ms
float yaw_angle_step = constrain_float(_fixed_yaw_offset_cd, - dt * _fixed_yaw_slewrate_cds, dt * _fixed_yaw_slewrate_cds)
_fixed_yaw_offset_cd -= yaw_angle_step
_yaw_angle_cd += yaw_angle_step
return _yaw_angle_cd
}

case AUTO_YAW_LOOK_AHEAD:
return look_ahead_yaw()

case AUTO_YAW_RESETTOARMEDYAW:
return copter.initial_armed_bearing

case AUTO_YAW_CIRCLE:
if (copter.circle_nav->is_active()) {
return copter.circle_nav->get_yaw()
}
return wrap_360_cd(copter.attitude_control->get_att_target_euler_cd().z)

case AUTO_YAW_ANGLE_RATE:{
const uint32_t now_ms = millis()
float dt = (now_ms - _last_update_ms) * 0.001
_last_update_ms = now_ms
_yaw_angle_cd += _yaw_rate_cds * dt
return _yaw_angle_cd
}

case AUTO_YAW_LOOK_AT_NEXT_WP:
default:
return copter.pos_control->get_yaw_cd()
}
}
"
47,Arducopter\autoyaw.cpp_rate_cds,"float Mode::AutoYaw::rate_cds() const
{
switch (_mode) {

case AUTO_YAW_HOLD:
case AUTO_YAW_ROI:
case AUTO_YAW_FIXED:
case AUTO_YAW_LOOK_AHEAD:
case AUTO_YAW_RESETTOARMEDYAW:
case AUTO_YAW_CIRCLE:
return 0.0f

case AUTO_YAW_ANGLE_RATE:
case AUTO_YAW_RATE:
return _yaw_rate_cds

case AUTO_YAW_LOOK_AT_NEXT_WP:
return copter.pos_control->get_yaw_rate_cds()
}

return 0.0f
}
"
48,Arducopter\avoidance.cpp_low_alt_avoidance,"void Copter::low_alt_avoidance()
{
int32_t alt_cm
if (!get_rangefinder_height_interpolated_cm(alt_cm)) {
avoid.proximity_alt_avoidance_enable(true)
return
}

bool enable_avoidance = true
if (alt_cm < avoid.get_min_alt() * 100.0f) {
enable_avoidance = false
}
avoid.proximity_alt_avoidance_enable(enable_avoidance)
}
"
49,Arducopter\avoidance_adsb.cpp_avoidance_adsb_update,"void Copter::avoidance_adsb_update(void)
{
adsb.update()
avoidance_adsb.update()
}
"
50,Arducopter\avoidance_adsb.cpp_handle_avoidance,"MAV_COLLISION_ACTION AP_Avoidance_Copter::handle_avoidance(const AP_Avoidance::Obstacle *obstacle, MAV_COLLISION_ACTION requested_action)
{
MAV_COLLISION_ACTION actual_action = requested_action
bool failsafe_state_change = false

if (!copter.failsafe.adsb) {
copter.failsafe.adsb = true
failsafe_state_change = true
prev_control_mode = copter.flightmode->mode_number()
}

if (copter.flightmode->mode_number() == Mode::Number::LAND ||
copter.flightmode->mode_number() == Mode::Number::THROW ||
copter.flightmode->mode_number() == Mode::Number::FLIP) {
actual_action = MAV_COLLISION_ACTION_NONE
}

if ((actual_action > MAV_COLLISION_ACTION_REPORT) && copter.should_disarm_on_failsafe()) {
copter.arming.disarm(AP_Arming::Method::ADSBCOLLISIONACTION)
actual_action = MAV_COLLISION_ACTION_NONE
} else {

switch (actual_action) {

case MAV_COLLISION_ACTION_RTL:
if (failsafe_state_change) {
if (!copter.set_mode(Mode::Number::RTL, ModeReason::AVOIDANCE)) {
actual_action = MAV_COLLISION_ACTION_NONE
}
}
break

case MAV_COLLISION_ACTION_HOVER:
if (failsafe_state_change) {
if (!copter.set_mode(Mode::Number::LOITER, ModeReason::AVOIDANCE)) {
actual_action = MAV_COLLISION_ACTION_NONE
}
}
break

case MAV_COLLISION_ACTION_ASCEND_OR_DESCEND:
if (!handle_avoidance_vertical(obstacle, failsafe_state_change)) {
actual_action = MAV_COLLISION_ACTION_NONE
}
break

case MAV_COLLISION_ACTION_MOVE_HORIZONTALLY:
if (!handle_avoidance_horizontal(obstacle, failsafe_state_change)) {
actual_action = MAV_COLLISION_ACTION_NONE
}
break

case MAV_COLLISION_ACTION_MOVE_PERPENDICULAR:
if (!handle_avoidance_perpendicular(obstacle, failsafe_state_change)) {
actual_action = MAV_COLLISION_ACTION_NONE
}
break

case MAV_COLLISION_ACTION_NONE:
return actual_action
case MAV_COLLISION_ACTION_REPORT:
default:
break
}
}

if (failsafe_state_change) {
AP::logger().Write_Error(LogErrorSubsystem::FAILSAFE_ADSB,
LogErrorCode(actual_action))
}

return actual_action
}
"
51,Arducopter\avoidance_adsb.cpp_handle_recovery,"void AP_Avoidance_Copter::handle_recovery(RecoveryAction recovery_action)
{
if (copter.failsafe.adsb) {
copter.failsafe.adsb = false
AP::logger().Write_Error(LogErrorSubsystem::FAILSAFE_ADSB,
LogErrorCode::ERROR_RESOLVED)

if (copter.control_mode_reason == ModeReason::AVOIDANCE) {
switch (recovery_action) {

case RecoveryAction::REMAIN_IN_AVOID_ADSB:
break

case RecoveryAction::RESUME_PREVIOUS_FLIGHTMODE:
set_mode_else_try_RTL_else_LAND(prev_control_mode)
break

case RecoveryAction::RTL:
set_mode_else_try_RTL_else_LAND(Mode::Number::RTL)
break

case RecoveryAction::RESUME_IF_AUTO_ELSE_LOITER:
if (prev_control_mode == Mode::Number::AUTO) {
set_mode_else_try_RTL_else_LAND(Mode::Number::AUTO)
}
break

default:
break
} // switch
}
}
}
"
52,Arducopter\avoidance_adsb.cpp_set_mode_else_try_RTL_else_LAND,"void AP_Avoidance_Copter::set_mode_else_try_RTL_else_LAND(Mode::Number mode)
{
if (!copter.set_mode(mode, ModeReason::AVOIDANCE_RECOVERY)) {
if (!copter.set_mode(Mode::Number::RTL, ModeReason::AVOIDANCE_RECOVERY)) {
copter.set_mode(Mode::Number::LAND, ModeReason::AVOIDANCE_RECOVERY)
}
}
}
"
53,Arducopter\avoidance_adsb.cpp_get_altitude_minimum,"int32_t AP_Avoidance_Copter::get_altitude_minimum() const
{
return copter.g.rtl_altitude
return 0
}
"
54,Arducopter\avoidance_adsb.cpp_check_flightmode,"bool AP_Avoidance_Copter::check_flightmode(bool allow_mode_change)
{
if (allow_mode_change && copter.flightmode->mode_number() != Mode::Number::AVOID_ADSB) {
if (!copter.set_mode(Mode::Number::AVOID_ADSB, ModeReason::AVOIDANCE)) {
return false
}
}

return (copter.flightmode->mode_number() == Mode::Number::AVOID_ADSB)
}
"
55,Arducopter\avoidance_adsb.cpp_handle_avoidance_vertical,"bool AP_Avoidance_Copter::handle_avoidance_vertical(const AP_Avoidance::Obstacle *obstacle, bool allow_mode_change)
{
if (!check_flightmode(allow_mode_change)) {
return false
}

bool should_climb = false
Location my_loc
if (AP::ahrs().get_location(my_loc)) {
should_climb = my_loc.alt > obstacle->_location.alt
}

Vector3f velocity_neu
if (should_climb) {
velocity_neu.z = copter.wp_nav->get_default_speed_up()
} else {
velocity_neu.z = -copter.wp_nav->get_default_speed_down()
if (copter.current_loc.alt < get_altitude_minimum()) {
velocity_neu.z = 0.0f
}
}

copter.mode_avoid_adsb.set_velocity(velocity_neu)
return true
}
"
56,Arducopter\avoidance_adsb.cpp_handle_avoidance_horizontal,"bool AP_Avoidance_Copter::handle_avoidance_horizontal(const AP_Avoidance::Obstacle *obstacle, bool allow_mode_change)
{
if (!check_flightmode(allow_mode_change)) {
return false
}

Vector3f velocity_neu
if (get_vector_perpendicular(obstacle, velocity_neu)) {
velocity_neu.z = 0.0f
if (is_zero(velocity_neu.x) && is_zero(velocity_neu.y)) {
return false
}
velocity_neu.normalize()
velocity_neu.x *= copter.wp_nav->get_default_speed_xy()
velocity_neu.y *= copter.wp_nav->get_default_speed_xy()
copter.mode_avoid_adsb.set_velocity(velocity_neu)
return true
}

return false
}
"
57,Arducopter\avoidance_adsb.cpp_handle_avoidance_perpendicular,"bool AP_Avoidance_Copter::handle_avoidance_perpendicular(const AP_Avoidance::Obstacle *obstacle, bool allow_mode_change)
{
if (!check_flightmode(allow_mode_change)) {
return false
}

Vector3f velocity_neu
if (get_vector_perpendicular(obstacle, velocity_neu)) {
velocity_neu.x *= copter.wp_nav->get_default_speed_xy()
velocity_neu.y *= copter.wp_nav->get_default_speed_xy()
if (velocity_neu.z > 0.0f) {
velocity_neu.z *= copter.wp_nav->get_default_speed_up()
} else {
velocity_neu.z *= copter.wp_nav->get_default_speed_down()
if (copter.current_loc.alt < get_altitude_minimum()) {
velocity_neu.z = 0.0f
}
}
copter.mode_avoid_adsb.set_velocity(velocity_neu)
return true
}

return false
}
"
58,Arducopter\baro_ground_effect.cpp_update_ground_effect_detector,"void Copter::update_ground_effect_detector(void)
{
if(!g2.gndeffect_comp_enabled || !motors->armed()) {
gndeffect_state.takeoff_expected = false
gndeffect_state.touchdown_expected = false
ahrs.set_takeoff_expected(gndeffect_state.takeoff_expected)
ahrs.set_touchdown_expected(gndeffect_state.touchdown_expected)
return
}

uint32_t tnow_ms = millis()
float xy_des_speed_cms = 0.0f
float xy_speed_cms = 0.0f
float des_climb_rate_cms = pos_control->get_vel_desired_cms().z

if (pos_control->is_active_xy()) {
Vector3f vel_target = pos_control->get_vel_target_cms()
vel_target.z = 0.0f
xy_des_speed_cms = vel_target.length()
}

if (position_ok() || ekf_has_relative_position()) {
Vector3f vel = inertial_nav.get_velocity_neu_cms()
vel.z = 0.0f
xy_speed_cms = vel.length()
}


if (flightmode->mode_number() == Mode::Number::THROW) {
gndeffect_state.takeoff_expected = false
} else if (motors->armed() && ap.land_complete) {
gndeffect_state.takeoff_expected = true
}

const bool throttle_up = flightmode->has_manual_throttle() && channel_throttle->get_control_in() > 0
if (!throttle_up && ap.land_complete) {
gndeffect_state.takeoff_time_ms = tnow_ms
gndeffect_state.takeoff_alt_cm = inertial_nav.get_position_z_up_cm()
}

if (gndeffect_state.takeoff_expected && (tnow_ms-gndeffect_state.takeoff_time_ms > 5000 || inertial_nav.get_position_z_up_cm()-gndeffect_state.takeoff_alt_cm > 50.0f)) {
gndeffect_state.takeoff_expected = false
}

Vector3f angle_target_rad = attitude_control->get_att_target_euler_cd() * radians(0.01f)
bool small_angle_request = cosf(angle_target_rad.x)*cosf(angle_target_rad.y) > cosf(radians(7.5f))
bool xy_speed_low = (position_ok() || ekf_has_relative_position()) && xy_speed_cms <= 125.0f
bool xy_speed_demand_low = pos_control->is_active_xy() && xy_des_speed_cms <= 125.0f
bool slow_horizontal = xy_speed_demand_low || (xy_speed_low && !pos_control->is_active_xy()) || (flightmode->mode_number() == Mode::Number::ALT_HOLD && small_angle_request)

bool descent_demanded = pos_control->is_active_z() && des_climb_rate_cms < 0.0f
bool slow_descent_demanded = descent_demanded && des_climb_rate_cms >= -100.0f
bool z_speed_low = fabsf(inertial_nav.get_velocity_z_up_cms()) <= 60.0f
bool slow_descent = (slow_descent_demanded || (z_speed_low && descent_demanded))

gndeffect_state.touchdown_expected = slow_horizontal && slow_descent

ahrs.set_takeoff_expected(gndeffect_state.takeoff_expected)
ahrs.set_touchdown_expected(gndeffect_state.touchdown_expected)
}
"
59,Arducopter\baro_ground_effect.cpp_update_ekf_terrain_height_stable,"void Copter::update_ekf_terrain_height_stable()
{
if (!position_ok() && !ekf_has_relative_position()) {
ahrs.set_terrain_hgt_stable(false)
return
}

ahrs.set_terrain_hgt_stable(flightmode->is_taking_off() || flightmode->is_landing())
}
"
60,Arducopter\commands.cpp_update_home_from_EKF,"void Copter::update_home_from_EKF()
{
if (ahrs.home_is_set()) {
return
}

if (motors->armed()) {
set_home_to_current_location_inflight()
} else {
if (!set_home_to_current_location(false)) {
}
}
}
"
61,Arducopter\commands.cpp_set_home_to_current_location_inflight,"void Copter::set_home_to_current_location_inflight() {
Location temp_loc
Location ekf_origin
if (ahrs.get_location(temp_loc) && ahrs.get_origin(ekf_origin)) {
temp_loc.alt = ekf_origin.alt
if (!set_home(temp_loc, false)) {
return
}
g2.smart_rtl.set_home(true)
}
}
"
62,Arducopter\commands.cpp_set_home_to_current_location,"bool Copter::set_home_to_current_location(bool lock) {
Location temp_loc
if (ahrs.get_location(temp_loc)) {
if (!set_home(temp_loc, lock)) {
return false
}
g2.smart_rtl.set_home(true)
return true
}
return false
}
"
63,Arducopter\commands.cpp_set_home,"bool Copter::set_home(const Location& loc, bool lock)
{
Location ekf_origin
if (!ahrs.get_origin(ekf_origin)) {
return false
}

if (far_from_EKF_origin(loc)) {
return false
}

const bool home_was_set = ahrs.home_is_set()

if (!ahrs.set_home(loc)) {
return false
}

if (!home_was_set) {
if (should_log(MASK_LOG_CMD)) {
AP_Mission::Mission_Command temp_cmd
if (mode_auto.mission.read_cmd_from_storage(0, temp_cmd)) {
logger.Write_Mission_Cmd(mode_auto.mission, temp_cmd)
}
}
}

if (lock) {
ahrs.lock_home()
}

return true
}
"
64,Arducopter\commands.cpp_far_from_EKF_origin,"bool Copter::far_from_EKF_origin(const Location& loc)
{
Location ekf_origin
if (ahrs.get_origin(ekf_origin)) {
if (labs(ekf_origin.alt - loc.alt)*0.01 > EKF_ORIGIN_MAX_ALT_KM*1000.0) {
return true
}
}

return false
}
"
65,Arducopter\compassmot.cpp_mavlink_compassmot,"MAV_RESULT Copter::mavlink_compassmot(const GCS_MAVLINK &gcs_chan)
{
return MAV_RESULT_UNSUPPORTED
int8_t   comp_type
Vector3f compass_base[COMPASS_MAX_INSTANCES]
Vector3f motor_impact[COMPASS_MAX_INSTANCES]
Vector3f motor_impact_scaled[COMPASS_MAX_INSTANCES]
Vector3f motor_compensation[COMPASS_MAX_INSTANCES]
float    throttle_pct
float    throttle_pct_max = 0.0f
float    current_amps_max = 0.0f
float    interference_pct[COMPASS_MAX_INSTANCES]{}
uint32_t last_run_time
uint32_t last_send_time
bool     updated = false
uint8_t  command_ack_start = command_ack_counter

if (ap.compass_mot) {
return MAV_RESULT_TEMPORARILY_REJECTED
} else {
ap.compass_mot = true
}

if (!AP::compass().available()) {
gcs_chan.send_text(MAV_SEVERITY_CRITICAL, ""Compass disabled"")
ap.compass_mot = false
return MAV_RESULT_TEMPORARILY_REJECTED
}

compass.read()
for (uint8_t i=0
if (!compass.healthy(i)) {
gcs_chan.send_text(MAV_SEVERITY_CRITICAL, ""Check compass"")
ap.compass_mot = false
return MAV_RESULT_TEMPORARILY_REJECTED
}
}

if (!arming.rc_calibration_checks(true)) {
gcs_chan.send_text(MAV_SEVERITY_CRITICAL, ""RC not calibrated"")
ap.compass_mot = false
return MAV_RESULT_TEMPORARILY_REJECTED
}

read_radio()
if (channel_throttle->get_control_in() != 0) {
gcs_chan.send_text(MAV_SEVERITY_CRITICAL, ""Throttle not zero"")
ap.compass_mot = false
return MAV_RESULT_TEMPORARILY_REJECTED
}

if (!ap.land_complete) {
gcs_chan.send_text(MAV_SEVERITY_CRITICAL, ""Not landed"")
ap.compass_mot = false
return MAV_RESULT_TEMPORARILY_REJECTED
}

failsafe_disable()

float current

if (battery.current_amps(current)) {
comp_type = AP_COMPASS_MOT_COMP_CURRENT
} else {
comp_type = AP_COMPASS_MOT_COMP_THROTTLE
}

mavlink_msg_command_ack_send(gcs_chan.get_chan(), MAV_CMD_PREFLIGHT_CALIBRATION,0,
0, 0, 0, 0)

AP_Notify::flags.esc_calibration = true

gcs_chan.send_text(MAV_SEVERITY_INFO, ""Starting calibration"")

if (comp_type == AP_COMPASS_MOT_COMP_CURRENT) {
gcs_chan.send_text(MAV_SEVERITY_INFO, ""Current"")
} else {
gcs_chan.send_text(MAV_SEVERITY_INFO, ""Throttle"")
}

g.failsafe_throttle.set(FS_THR_DISABLED)

compass.motor_compensation_type(AP_COMPASS_MOT_COMP_DISABLED)
for (uint8_t i=0
compass.set_motor_compensation(i, Vector3f(0,0,0))
}

compass.read()

for (uint8_t i=0
compass_base[i] = compass.get_field(i)
interference_pct[i] = 0.0f
}

EXPECT_DELAY_MS(5000)

enable_motor_output()
motors->armed(true)
hal.util->set_soft_armed(true)

last_run_time = millis()
last_send_time = millis()

while (command_ack_start == command_ack_counter && compass.healthy() && motors->armed()) {
EXPECT_DELAY_MS(5000)

if (millis() - last_run_time < 20) {
hal.scheduler->delay(5)
continue
}
last_run_time = millis()

read_radio()

SRV_Channels::cork()
motors->set_throttle_passthrough_for_esc_calibration(channel_throttle->get_control_in() * 0.001f)
SRV_Channels::push()

compass.read()

battery.read()

throttle_pct = (float)channel_throttle->get_control_in() * 0.001f
throttle_pct = constrain_float(throttle_pct,0.0f,1.0f)

throttle_pct_max = MAX(throttle_pct_max, throttle_pct)

if (!battery.current_amps(current)) {
current = 0
}
current_amps_max = MAX(current_amps_max, current)

if (!is_positive(throttle_pct)) {
for (uint8_t i=0
compass_base[i] = compass_base[i] * 0.99f + compass.get_field(i) * 0.01f
}
} else {

for (uint8_t i=0
motor_impact[i] = compass.get_field(i) - compass_base[i]
}

if (comp_type == AP_COMPASS_MOT_COMP_THROTTLE) {
for (uint8_t i=0
motor_impact_scaled[i] = motor_impact[i] / throttle_pct
motor_compensation[i] = motor_compensation[i] * 0.99f - motor_impact_scaled[i] * 0.01f
}
updated = true
} else {
for (uint8_t i=0
if (current >= 3.0f) {
motor_impact_scaled[i] = motor_impact[i] / current
motor_compensation[i] = motor_compensation[i] * 0.99f - motor_impact_scaled[i] * 0.01f
updated = true
}
}
}

if (comp_type == AP_COMPASS_MOT_COMP_THROTTLE) {
for (uint8_t i=0
interference_pct[i] = motor_compensation[i].length() / (float)arming.compass_magfield_expected() * 100.0f
}
} else {
for (uint8_t i=0
interference_pct[i] = motor_compensation[i].length() * (current_amps_max/throttle_pct_max) / (float)arming.compass_magfield_expected() * 100.0f
}
}
}

if (AP_HAL::millis() - last_send_time > 500) {
last_send_time = AP_HAL::millis()
mavlink_msg_compassmot_status_send(gcs_chan.get_chan(),
channel_throttle->get_control_in(),
current,
interference_pct[0],
motor_compensation[0].x,
motor_compensation[0].y,
motor_compensation[0].z)
AP::esc_telem().send_esc_telemetry_mavlink(gcs_chan.get_chan())
}
}

motors->output_min()
motors->armed(false)
hal.util->set_soft_armed(false)

if (updated) {
compass.motor_compensation_type(comp_type)
for (uint8_t i=0
compass.set_motor_compensation(i, motor_compensation[i])
}
compass.save_motor_compensation()
gcs_chan.send_text(MAV_SEVERITY_INFO, ""Calibration successful"")
} else {
gcs_chan.send_text(MAV_SEVERITY_NOTICE, ""Failed"")
compass.motor_compensation_type(AP_COMPASS_MOT_COMP_DISABLED)
}

AP_Notify::flags.esc_calibration = false

failsafe_enable()

g.failsafe_throttle.load()

ap.compass_mot = false

return MAV_RESULT_ACCEPTED
}
"
66,Arducopter\Copter.cpp_get_scheduler_tasks,"void Copter::get_scheduler_tasks(const AP_Scheduler::Task *&tasks,
uint8_t &task_count,
uint32_t &log_bit)
{
tasks = &scheduler_tasks[0]
task_count = ARRAY_SIZE(scheduler_tasks)
log_bit = MASK_LOG_PM
}
"
67,Arducopter\Copter.cpp_start_takeoff,"bool Copter::start_takeoff(float alt)
{
if (!flightmode->in_guided_mode()) {
return false
}

if (mode_guided.do_user_takeoff_start(alt * 100.0f)) {
copter.set_auto_armed(true)
return true
}
return false
}
"
68,Arducopter\Copter.cpp_set_target_location,"bool Copter::set_target_location(const Location& target_loc)
{
if (!flightmode->in_guided_mode()) {
return false
}

return mode_guided.set_destination(target_loc)
}
"
69,Arducopter\Copter.cpp_set_target_pos_NED,"bool Copter::set_target_pos_NED(const Vector3f& target_pos, bool use_yaw, float yaw_deg, bool use_yaw_rate, float yaw_rate_degs, bool yaw_relative, bool terrain_alt)
{
if (!flightmode->in_guided_mode()) {
return false
}

const Vector3f pos_neu_cm(target_pos.x * 100.0f, target_pos.y * 100.0f, -target_pos.z * 100.0f)

return mode_guided.set_destination(pos_neu_cm, use_yaw, yaw_deg * 100.0, use_yaw_rate, yaw_rate_degs * 100.0, yaw_relative, terrain_alt)
}
"
70,Arducopter\Copter.cpp_set_target_posvel_NED,"bool Copter::set_target_posvel_NED(const Vector3f& target_pos, const Vector3f& target_vel)
{
if (!flightmode->in_guided_mode()) {
return false
}

const Vector3f pos_neu_cm(target_pos.x * 100.0f, target_pos.y * 100.0f, -target_pos.z * 100.0f)
const Vector3f vel_neu_cms(target_vel.x * 100.0f, target_vel.y * 100.0f, -target_vel.z * 100.0f)

return mode_guided.set_destination_posvelaccel(pos_neu_cm, vel_neu_cms, Vector3f())
}
"
71,Arducopter\Copter.cpp_set_target_posvelaccel_NED,"bool Copter::set_target_posvelaccel_NED(const Vector3f& target_pos, const Vector3f& target_vel, const Vector3f& target_accel, bool use_yaw, float yaw_deg, bool use_yaw_rate, float yaw_rate_degs, bool yaw_relative)
{
if (!flightmode->in_guided_mode()) {
return false
}

const Vector3f pos_neu_cm(target_pos.x * 100.0f, target_pos.y * 100.0f, -target_pos.z * 100.0f)
const Vector3f vel_neu_cms(target_vel.x * 100.0f, target_vel.y * 100.0f, -target_vel.z * 100.0f)
const Vector3f accel_neu_cms(target_accel.x * 100.0f, target_accel.y * 100.0f, -target_accel.z * 100.0f)

return mode_guided.set_destination_posvelaccel(pos_neu_cm, vel_neu_cms, accel_neu_cms, use_yaw, yaw_deg * 100.0, use_yaw_rate, yaw_rate_degs * 100.0, yaw_relative)
}
"
72,Arducopter\Copter.cpp_set_target_velocity_NED,"bool Copter::set_target_velocity_NED(const Vector3f& vel_ned)
{
if (!flightmode->in_guided_mode()) {
return false
}

const Vector3f vel_neu_cms(vel_ned.x * 100.0f, vel_ned.y * 100.0f, -vel_ned.z * 100.0f)
mode_guided.set_velocity(vel_neu_cms)
return true
}
"
73,Arducopter\Copter.cpp_set_target_velaccel_NED,"bool Copter::set_target_velaccel_NED(const Vector3f& target_vel, const Vector3f& target_accel, bool use_yaw, float yaw_deg, bool use_yaw_rate, float yaw_rate_degs, bool relative_yaw)
{
if (!flightmode->in_guided_mode()) {
return false
}

const Vector3f vel_neu_cms(target_vel.x * 100.0f, target_vel.y * 100.0f, -target_vel.z * 100.0f)
const Vector3f accel_neu_cms(target_accel.x * 100.0f, target_accel.y * 100.0f, -target_accel.z * 100.0f)

mode_guided.set_velaccel(vel_neu_cms, accel_neu_cms, use_yaw, yaw_deg * 100.0, use_yaw_rate, yaw_rate_degs * 100.0, relative_yaw)
return true
}
"
74,Arducopter\Copter.cpp_set_target_angle_and_climbrate,"bool Copter::set_target_angle_and_climbrate(float roll_deg, float pitch_deg, float yaw_deg, float climb_rate_ms, bool use_yaw_rate, float yaw_rate_degs)
{
if (!flightmode->in_guided_mode()) {
return false
}

Quaternion q
q.from_euler(radians(roll_deg),radians(pitch_deg),radians(yaw_deg))

mode_guided.set_angle(q, Vector3f{}, climb_rate_ms*100, false)
return true
}
"
75,Arducopter\Copter.cpp_get_circle_radius,"bool Copter::get_circle_radius(float &radius_m)
{
radius_m = circle_nav->get_radius() * 0.01f
return true
}
"
76,Arducopter\Copter.cpp_set_circle_rate,"bool Copter::set_circle_rate(float rate_dps)
{
circle_nav->set_rate(rate_dps)
return true
}
"
77,Arducopter\Copter.cpp_set_desired_speed,"bool Copter::set_desired_speed(float speed)
{
if (!flightmode->is_autopilot()) {
return false
}

wp_nav->set_speed_xy(speed * 100.0f)
return true
}
"
78,Arducopter\Copter.cpp_nav_scripting_enable,"bool Copter::nav_scripting_enable(uint8_t mode)
{
return mode == (uint8_t)mode_auto.mode_number()
}
"
79,Arducopter\Copter.cpp_nav_script_time,"bool Copter::nav_script_time(uint16_t &id, uint8_t &cmd, float &arg1, float &arg2)
{
if (flightmode != &mode_auto) {
return false
}

return mode_auto.nav_script_time(id, cmd, arg1, arg2)
}
"
80,Arducopter\Copter.cpp_nav_script_time_done,"void Copter::nav_script_time_done(uint16_t id)
{
if (flightmode != &mode_auto) {
return
}

return mode_auto.nav_script_time_done(id)
}
"
81,Arducopter\Copter.cpp_has_ekf_failsafed,"bool Copter::has_ekf_failsafed() const
{
return failsafe.ekf
}
"
82,Arducopter\Copter.cpp_rc_loop,"void Copter::rc_loop()
{
read_radio()
rc().read_mode_switch()
}
"
83,Arducopter\Copter.cpp_throttle_loop,"void Copter::throttle_loop()
{
update_throttle_mix()

update_auto_armed()

heli_update_rotor_speed_targets()

heli_update_landing_swash()

update_ground_effect_detector()
update_ekf_terrain_height_stable()
}
"
84,Arducopter\Copter.cpp_update_batt_compass,"void Copter::update_batt_compass(void)
{
battery.read()

if(AP::compass().available()) {
compass.set_throttle(motors->get_throttle())
compass.set_voltage(battery.voltage())
compass.read()
}
}
"
85,Arducopter\Copter.cpp_loop_rate_logging,"void Copter::loop_rate_logging()
{
if (should_log(MASK_LOG_ATTITUDE_FAST) && !copter.flightmode->logs_attitude()) {
Log_Write_Attitude()
Log_Write_PIDS()
}
if (should_log(MASK_LOG_FTN_FAST)) {
AP::ins().write_notch_log_messages()
}
if (should_log(MASK_LOG_IMU_FAST)) {
AP::ins().Write_IMU()
}
}
"
86,Arducopter\Copter.cpp_ten_hz_logging_loop,"void Copter::ten_hz_logging_loop()
{
if (should_log(MASK_LOG_ATTITUDE_MED) && !should_log(MASK_LOG_ATTITUDE_FAST) && !copter.flightmode->logs_attitude()) {
Log_Write_Attitude()
}
if (!should_log(MASK_LOG_ATTITUDE_FAST)) {
Log_Write_PIDS()
}
if (!should_log(MASK_LOG_ATTITUDE_FAST)) {
Log_Write_EKF_POS()
}
if (should_log(MASK_LOG_MOTBATT)) {
motors->Log_Write()
}
if (should_log(MASK_LOG_RCIN)) {
logger.Write_RCIN()
if (rssi.enabled()) {
logger.Write_RSSI()
}
}
if (should_log(MASK_LOG_RCOUT)) {
logger.Write_RCOUT()
}
if (should_log(MASK_LOG_NTUN) && (flightmode->requires_GPS() || landing_with_GPS() || !flightmode->has_manual_throttle())) {
pos_control->write_log()
}
if (should_log(MASK_LOG_IMU) || should_log(MASK_LOG_IMU_FAST) || should_log(MASK_LOG_IMU_RAW)) {
AP::ins().Write_Vibration()
}
if (should_log(MASK_LOG_CTUN)) {
attitude_control->control_monitor_log()
g2.proximity.log()
g2.beacon.log()
}
Log_Write_Heli()
if (should_log(MASK_LOG_ANY)) {
g2.winch.write_log()
}
}
"
87,Arducopter\Copter.cpp_twentyfive_hz_logging,"void Copter::twentyfive_hz_logging()
{
if (should_log(MASK_LOG_ATTITUDE_FAST)) {
Log_Write_EKF_POS()
}

if (should_log(MASK_LOG_IMU) && !(should_log(MASK_LOG_IMU_FAST))) {
AP::ins().Write_IMU()
}

if (should_log(MASK_LOG_ATTITUDE_MED) || should_log(MASK_LOG_ATTITUDE_FAST)) {
g2.arot.Log_Write_Autorotation()
}
}
"
88,Arducopter\Copter.cpp_three_hz_loop,"void Copter::three_hz_loop()
{
failsafe_gcs_check()

failsafe_terrain_check()

failsafe_deadreckon_check()

fence_check()


tuning()

low_alt_avoidance()
}
"
89,Arducopter\Copter.cpp_one_hz_loop,"void Copter::one_hz_loop()
{
if (should_log(MASK_LOG_ANY)) {
Log_Write_Data(LogDataID::AP_STATE, ap.value)
}

if (!motors->armed()) {
update_using_interlock()

motors->set_frame_class_and_type((AP_Motors::motor_frame_class)g2.frame_class.get(), (AP_Motors::motor_frame_type)g.frame_type.get())

motors->update_throttle_range()
}

SRV_Channels::enable_aux_servos()

terrain_logging()

adsb.set_is_flying(!ap.land_complete)

AP_Notify::flags.flying = !ap.land_complete
}
"
90,Arducopter\Copter.cpp_init_simple_bearing,"void Copter::init_simple_bearing()
{
simple_cos_yaw = ahrs.cos_yaw()
simple_sin_yaw = ahrs.sin_yaw()

super_simple_last_bearing = wrap_360_cd(ahrs.yaw_sensor+18000)
super_simple_cos_yaw = simple_cos_yaw
super_simple_sin_yaw = simple_sin_yaw

if (should_log(MASK_LOG_ANY)) {
Log_Write_Data(LogDataID::INIT_SIMPLE_BEARING, ahrs.yaw_sensor)
}
}
"
91,Arducopter\Copter.cpp_update_simple_mode,"void Copter::update_simple_mode(void)
{
float rollx, pitchx

if (simple_mode == SimpleMode::NONE || !ap.new_radio_frame) {
return
}

ap.new_radio_frame = false

if (simple_mode == SimpleMode::SIMPLE) {
rollx = channel_roll->get_control_in()*simple_cos_yaw - channel_pitch->get_control_in()*simple_sin_yaw
pitchx = channel_roll->get_control_in()*simple_sin_yaw + channel_pitch->get_control_in()*simple_cos_yaw
}else{
rollx = channel_roll->get_control_in()*super_simple_cos_yaw - channel_pitch->get_control_in()*super_simple_sin_yaw
pitchx = channel_roll->get_control_in()*super_simple_sin_yaw + channel_pitch->get_control_in()*super_simple_cos_yaw
}

channel_roll->set_control_in(rollx*ahrs.cos_yaw() + pitchx*ahrs.sin_yaw())
channel_pitch->set_control_in(-rollx*ahrs.sin_yaw() + pitchx*ahrs.cos_yaw())
}
"
92,Arducopter\Copter.cpp_update_super_simple_bearing,"void Copter::update_super_simple_bearing(bool force_update)
{
if (!force_update) {
if (simple_mode != SimpleMode::SUPERSIMPLE) {
return
}
if (home_distance() < SUPER_SIMPLE_RADIUS) {
return
}
}

const int32_t bearing = home_bearing()

if (labs(super_simple_last_bearing - bearing) < 500) {
return
}

super_simple_last_bearing = bearing
const float angle_rad = radians((super_simple_last_bearing+18000)/100)
super_simple_cos_yaw = cosf(angle_rad)
super_simple_sin_yaw = sinf(angle_rad)
}
"
93,Arducopter\Copter.cpp_read_AHRS,"void Copter::read_AHRS(void)
{
ahrs.update(true)
}
"
94,Arducopter\Copter.cpp_update_altitude,"void Copter::update_altitude()
{
read_barometer()

if (should_log(MASK_LOG_CTUN)) {
Log_Write_Control_Tuning()
if (!should_log(MASK_LOG_FTN_FAST)) {
AP::ins().write_notch_log_messages()
}
gyro_fft.write_log_messages()
}
}
"
95,Arducopter\Copter.cpp_get_wp_distance_m,"bool Copter::get_wp_distance_m(float &distance) const
{
distance = flightmode->wp_distance() * 0.01
return true
}
"
96,Arducopter\Copter.cpp_get_wp_bearing_deg,"bool Copter::get_wp_bearing_deg(float &bearing) const
{
bearing = flightmode->wp_bearing() * 0.01
return true
}
"
97,Arducopter\Copter.cpp_get_wp_crosstrack_error_m,"bool Copter::get_wp_crosstrack_error_m(float &xtrack_error) const
{
xtrack_error = flightmode->crosstrack_error() * 0.01
return true
}
"
98,Arducopter\Copter.cpp_get_rate_bf_targets,"bool Copter::get_rate_bf_targets(Vector3f& rate_bf_targets) const
{
rate_bf_targets = attitude_control->rate_bf_targets()
return true
}
"
99,Arducopter\Copter.cpp_Copter,"Copter::Copter(void)
: logger(g.log_bitmask),
flight_modes(&g.flight_mode1),
simple_cos_yaw(1.0f),
super_simple_cos_yaw(1.0),
land_accel_ef_filter(LAND_DETECTOR_ACCEL_LPF_CUTOFF),
rc_throttle_control_in_filter(1.0f),
inertial_nav(ahrs),
param_loader(var_info),
flightmode(&mode_stabilize)
{
}
"
100,Arducopter\crash_check.cpp_crash_check,"void Copter::crash_check()
{
static uint16_t crash_counter

if (!motors->armed() || ap.land_complete || g.fs_crash_check == 0) {
crash_counter = 0
return
}

if (standby_active) {
crash_counter = 0
return
}

if (force_flying && !flightmode->is_landing()) {
crash_counter = 0
return
}

if (flightmode->mode_number() == Mode::Number::ACRO || flightmode->mode_number() == Mode::Number::FLIP) {
crash_counter = 0
return
}

if (flightmode->mode_number() == Mode::Number::AUTOROTATE) {
crash_counter = 0
return
}

const float filtered_acc = land_accel_ef_filter.get().length()
if (filtered_acc >= CRASH_CHECK_ACCEL_MAX) {
crash_counter = 0
return
}

const float lean_angle_deg = degrees(acosf(ahrs.cos_roll()*ahrs.cos_pitch()))
if (lean_angle_deg <= CRASH_CHECK_ANGLE_MIN_DEG) {
crash_counter = 0
return
}

const float angle_error = attitude_control->get_att_error_angle_deg()
if (angle_error <= CRASH_CHECK_ANGLE_DEVIATION_DEG) {
crash_counter = 0
return
}

Vector3f vel_ned
if (ahrs.get_velocity_NED(vel_ned) && (vel_ned.length() >= CRASH_CHECK_SPEED_MAX)) {
crash_counter = 0
return
}

crash_counter++

if (crash_counter >= (CRASH_CHECK_TRIGGER_SEC * scheduler.get_loop_rate_hz())) {
AP::logger().Write_Error(LogErrorSubsystem::CRASH_CHECK, LogErrorCode::CRASH_CHECK_CRASH)
gcs().send_text(MAV_SEVERITY_EMERGENCY,""Crash: Disarming: AngErr=%.0f>%.0f, Accel=%.1f<%.1f"", angle_error, CRASH_CHECK_ANGLE_DEVIATION_DEG, filtered_acc, CRASH_CHECK_ACCEL_MAX)
copter.arming.disarm(AP_Arming::Method::CRASH)
}
}
"
101,Arducopter\crash_check.cpp_thrust_loss_check,"void Copter::thrust_loss_check()
{
static uint16_t thrust_loss_counter

if ((copter.g2.flight_options & uint32_t(FlightOptions::DISABLE_THRUST_LOSS_CHECK)) != 0) {
return
}

if (motors->get_thrust_boost()) {
return
}

if (!motors->armed() || ap.land_complete) {
thrust_loss_counter = 0
return
}

if (standby_active) {
return
}

const Vector3f angle_target = attitude_control->get_att_target_euler_cd()
if (sq(angle_target.x) + sq(angle_target.y) > sq(THRUST_LOSS_CHECK_ANGLE_DEVIATION_CD)) {
thrust_loss_counter = 0
return
}

if ((attitude_control->get_throttle_in() < THRUST_LOSS_CHECK_MINIMUM_THROTTLE) && (!motors->limit.throttle_upper)) {
thrust_loss_counter = 0
return
}

if ((attitude_control->get_throttle_in() < 0.25f)) {
thrust_loss_counter = 0
return
}

if (!is_negative(inertial_nav.get_velocity_z_up_cms())) {
thrust_loss_counter = 0
return
}

const float angle_error = attitude_control->get_att_error_angle_deg()
if (angle_error >= CRASH_CHECK_ANGLE_DEVIATION_DEG) {
thrust_loss_counter = 0
return
}

thrust_loss_counter++

if (thrust_loss_counter >= (THRUST_LOSS_CHECK_TRIGGER_SEC * scheduler.get_loop_rate_hz())) {
thrust_loss_counter = 0
AP::logger().Write_Error(LogErrorSubsystem::THRUST_LOSS_CHECK, LogErrorCode::FAILSAFE_OCCURRED)
gcs().send_text(MAV_SEVERITY_EMERGENCY, ""Potential Thrust Loss (%d)"", (int)motors->get_lost_motor() + 1)
motors->set_thrust_boost(true)

if ((copter.g2.flight_options & uint32_t(FlightOptions::RELEASE_GRIPPER_ON_THRUST_LOSS)) != 0) {
copter.g2.gripper.release()
}
}
}
"
102,Arducopter\crash_check.cpp_yaw_imbalance_check,"void Copter::yaw_imbalance_check()
{
if ((copter.g2.flight_options & uint32_t(FlightOptions::DISABLE_YAW_IMBALANCE_WARNING)) != 0) {
return
}

if (!is_positive(attitude_control->get_rate_yaw_pid().kI())) {
return
}

if (motors->get_thrust_boost()) {
yaw_I_filt.reset(0.0f)
return
}

if (!motors->armed() || ap.land_complete) {
yaw_I_filt.reset(0.0f)
return
}

if (standby_active) {
yaw_I_filt.reset(0.0f)
return
}

const float I_term = attitude_control->get_rate_yaw_pid().get_pid_info().I
const float I = fabsf(yaw_I_filt.apply(attitude_control->get_rate_yaw_pid().get_pid_info().I,G_Dt))
if (I > fabsf(I_term)) {
yaw_I_filt.reset(I_term)
}

const float I_max = attitude_control->get_rate_yaw_pid().imax()
if ((is_positive(I_max) && ((I > YAW_IMBALANCE_IMAX_THRESHOLD * I_max) || (is_equal(I_term,I_max))))) {
const uint32_t now = millis()
if (now - last_yaw_warn_ms > YAW_IMBALANCE_WARN_MS) {
last_yaw_warn_ms = now
gcs().send_text(MAV_SEVERITY_EMERGENCY, ""Yaw Imbalance %0.0f%%"", I *100)
}
}
}
"
103,Arducopter\crash_check.cpp_parachute_check,"void Copter::parachute_check()
{
static uint16_t control_loss_count
static int32_t baro_alt_start

if (!parachute.enabled()) {
return
}

parachute.set_is_flying(!ap.land_complete)

parachute.set_sink_rate(-inertial_nav.get_velocity_z_up_cms() * 0.01f)

if (standby_active) {
return
}

parachute.update()

if (!motors->armed()) {
control_loss_count = 0
return
}

if (parachute.release_initiated()) {
copter.arming.disarm(AP_Arming::Method::PARACHUTE_RELEASE)
return
}

if (flightmode->mode_number() == Mode::Number::ACRO || flightmode->mode_number() == Mode::Number::FLIP) {
control_loss_count = 0
return
}

if (ap.land_complete) {
control_loss_count = 0
return
}

if (control_loss_count == 0 && parachute.alt_min() != 0 && (current_loc.alt < (int32_t)parachute.alt_min() * 100)) {
return
}

parachute.check_sink_rate()

const float angle_error = attitude_control->get_att_error_angle_deg()
if (angle_error <= PARACHUTE_CHECK_ANGLE_DEVIATION_DEG) {
if (control_loss_count > 0) {
control_loss_count--
}
return
}

if (control_loss_count < (PARACHUTE_CHECK_TRIGGER_SEC*scheduler.get_loop_rate_hz())) {
control_loss_count++
}

if (control_loss_count == 1) {
baro_alt_start = baro_alt

} else if (baro_alt >= baro_alt_start) {
control_loss_count = 0
return


} else if (control_loss_count >= (PARACHUTE_CHECK_TRIGGER_SEC*scheduler.get_loop_rate_hz())) {
control_loss_count = 0
AP::logger().Write_Error(LogErrorSubsystem::CRASH_CHECK, LogErrorCode::CRASH_CHECK_LOSS_OF_CONTROL)
parachute_release()
}
}
"
104,Arducopter\crash_check.cpp_parachute_release,"void Copter::parachute_release()
{
arming.disarm(AP_Arming::Method::PARACHUTE_RELEASE)

parachute.release()

landinggear.set_position(AP_LandingGear::LandingGear_Deploy)
}
"
105,Arducopter\crash_check.cpp_parachute_manual_release,"void Copter::parachute_manual_release()
{
if (!parachute.enabled()) {
return
}

if (ap.land_complete) {
gcs().send_text(MAV_SEVERITY_INFO,""Parachute: Landed"")
AP::logger().Write_Error(LogErrorSubsystem::PARACHUTES, LogErrorCode::PARACHUTE_LANDED)
return
}

if ((parachute.alt_min() != 0 && (current_loc.alt < (int32_t)parachute.alt_min() * 100))) {
gcs().send_text(MAV_SEVERITY_ALERT,""Parachute: Too low"")
AP::logger().Write_Error(LogErrorSubsystem::PARACHUTES, LogErrorCode::PARACHUTE_TOO_LOW)
return
}

parachute_release()
}
"
106,Arducopter\ekf_check.cpp_ekf_check,"void Copter::ekf_check()
{
static_assert(EKF_CHECK_ITERATIONS_MAX >= 7, ""EKF_CHECK_ITERATIONS_MAX must be at least 7"")

Location temp_loc
if (!ahrs.get_origin(temp_loc)) {
return
}

if (g.fs_ekf_thresh <= 0.0f) {
ekf_check_state.fail_count = 0
ekf_check_state.bad_variance = false
AP_Notify::flags.ekf_bad = ekf_check_state.bad_variance
failsafe_ekf_off_event()
return
}

const bool over_threshold = ekf_over_threshold()
const bool has_position = ekf_has_relative_position() || ekf_has_absolute_position()
const bool checks_passed = !over_threshold && has_position

ekf_check_state.has_ever_passed |= checks_passed
if (!ekf_check_state.has_ever_passed) {
return
}

if (!checks_passed) {
if (!ekf_check_state.bad_variance) {
ekf_check_state.fail_count++
if (ekf_check_state.fail_count == (EKF_CHECK_ITERATIONS_MAX-2) && over_threshold) {
ahrs.request_yaw_reset()
}
if (ekf_check_state.fail_count == (EKF_CHECK_ITERATIONS_MAX-1)) {
ahrs.check_lane_switch()
}
if (ekf_check_state.fail_count >= EKF_CHECK_ITERATIONS_MAX) {
ekf_check_state.fail_count = EKF_CHECK_ITERATIONS_MAX
ekf_check_state.bad_variance = true
AP::logger().Write_Error(LogErrorSubsystem::EKFCHECK, LogErrorCode::EKFCHECK_BAD_VARIANCE)
if ((AP_HAL::millis() - ekf_check_state.last_warn_time) > EKF_CHECK_WARNING_TIME) {
gcs().send_text(MAV_SEVERITY_CRITICAL,""EKF variance"")
ekf_check_state.last_warn_time = AP_HAL::millis()
}
failsafe_ekf_event()
}
}
} else {
if (ekf_check_state.fail_count > 0) {
ekf_check_state.fail_count--

if (ekf_check_state.bad_variance && ekf_check_state.fail_count == 0) {
ekf_check_state.bad_variance = false
AP::logger().Write_Error(LogErrorSubsystem::EKFCHECK, LogErrorCode::EKFCHECK_VARIANCE_CLEARED)
failsafe_ekf_off_event()
}
}
}

AP_Notify::flags.ekf_bad = ekf_check_state.bad_variance

}
"
107,Arducopter\ekf_check.cpp_ekf_over_threshold,"bool Copter::ekf_over_threshold()
{
if (g.fs_ekf_thresh <= 0.0f) {
return false
}

float position_variance, vel_variance, height_variance, tas_variance
Vector3f mag_variance
ahrs.get_variances(vel_variance, position_variance, height_variance, mag_variance, tas_variance)

const float mag_max = fmaxf(fmaxf(mag_variance.x,mag_variance.y),mag_variance.z)

uint8_t over_thresh_count = 0
if (mag_max >= g.fs_ekf_thresh) {
over_thresh_count++
}

bool optflow_healthy = false
optflow_healthy = optflow.healthy()
if (!optflow_healthy && (vel_variance >= (2.0f * g.fs_ekf_thresh))) {
over_thresh_count += 2
} else if (vel_variance >= g.fs_ekf_thresh) {
over_thresh_count++
}

if ((position_variance >= g.fs_ekf_thresh && over_thresh_count >= 1) || over_thresh_count >= 2) {
return true
}

return false
}
"
108,Arducopter\ekf_check.cpp_failsafe_ekf_event,"void Copter::failsafe_ekf_event()
{
failsafe.ekf = true
AP::logger().Write_Error(LogErrorSubsystem::FAILSAFE_EKFINAV, LogErrorCode::FAILSAFE_OCCURRED)

if (!motors->armed()) {
return
}

if (flightmode->mode_number() == Mode::Number::LAND && landing_with_GPS()) {
mode_land.do_not_use_GPS()
return
}

if (!copter.flightmode->requires_GPS() && (g.fs_ekf_action != FS_EKF_ACTION_LAND_EVEN_STABILIZE)) {
return
}

switch (g.fs_ekf_action) {
case FS_EKF_ACTION_ALTHOLD:
if (failsafe.radio || !set_mode(Mode::Number::ALT_HOLD, ModeReason::EKF_FAILSAFE)) {
set_mode_land_with_pause(ModeReason::EKF_FAILSAFE)
}
break
case FS_EKF_ACTION_LAND:
case FS_EKF_ACTION_LAND_EVEN_STABILIZE:
default:
set_mode_land_with_pause(ModeReason::EKF_FAILSAFE)
break
}

AP_Notify::flags.failsafe_ekf = true
gcs().send_text(MAV_SEVERITY_CRITICAL, ""EKF Failsafe: changed to %s Mode"", flightmode->name())
}
"
109,Arducopter\ekf_check.cpp_failsafe_ekf_off_event,"void Copter::failsafe_ekf_off_event(void)
{
if (!failsafe.ekf) {
return
}

failsafe.ekf = false
if (AP_Notify::flags.failsafe_ekf) {
AP_Notify::flags.failsafe_ekf = false
gcs().send_text(MAV_SEVERITY_CRITICAL, ""EKF Failsafe Cleared"")
}
AP::logger().Write_Error(LogErrorSubsystem::FAILSAFE_EKFINAV, LogErrorCode::FAILSAFE_RESOLVED)
}
"
110,Arducopter\ekf_check.cpp_failsafe_ekf_recheck,"void Copter::failsafe_ekf_recheck()
{
if (!failsafe.ekf) {
return
}

failsafe_ekf_event()
}
"
111,Arducopter\ekf_check.cpp_check_ekf_reset,"void Copter::check_ekf_reset()
{
float yaw_angle_change_rad
uint32_t new_ekfYawReset_ms = ahrs.getLastYawResetAngle(yaw_angle_change_rad)
if (new_ekfYawReset_ms != ekfYawReset_ms) {
attitude_control->inertial_frame_reset()
ekfYawReset_ms = new_ekfYawReset_ms
AP::logger().Write_Event(LogEvent::EKF_YAW_RESET)
}

if ((ahrs.get_primary_core_index() != ekf_primary_core) && (ahrs.get_primary_core_index() != -1)) {
attitude_control->inertial_frame_reset()
ekf_primary_core = ahrs.get_primary_core_index()
AP::logger().Write_Error(LogErrorSubsystem::EKF_PRIMARY, LogErrorCode(ekf_primary_core))
gcs().send_text(MAV_SEVERITY_WARNING, ""EKF primary changed:%d"", (unsigned)ekf_primary_core)
}
}
"
112,Arducopter\ekf_check.cpp_check_vibration,"void Copter::check_vibration()
{
uint32_t now = AP_HAL::millis()

bool innovation_checks_valid = true

Vector3f vel_innovation
Vector3f pos_innovation
Vector3f mag_innovation
float tas_innovation
float yaw_innovation
if (!ahrs.get_innovations(vel_innovation, pos_innovation, mag_innovation, tas_innovation, yaw_innovation)) {
innovation_checks_valid = false
}
const bool innov_velD_posD_positive = is_positive(vel_innovation.z) && is_positive(pos_innovation.z)

float position_variance, vel_variance, height_variance, tas_variance
Vector3f mag_variance
if (!ahrs.get_variances(vel_variance, position_variance, height_variance, mag_variance, tas_variance)) {
innovation_checks_valid = false
}

const bool is_vibration_affected = ahrs.is_vibration_affected()
const bool bad_vibe_detected = (innovation_checks_valid && innov_velD_posD_positive && (vel_variance > 1.0f)) || is_vibration_affected
const bool do_bad_vibe_actions = (g2.fs_vibe_enabled == 1) && bad_vibe_detected && motors->armed() && !flightmode->has_manual_throttle()

if (!vibration_check.high_vibes) {
if (!do_bad_vibe_actions) {
vibration_check.start_ms = now
}
if (now - vibration_check.start_ms > 1000) {
vibration_check.clear_ms = 0
vibration_check.high_vibes = true
pos_control->set_vibe_comp(true)
AP::logger().Write_Error(LogErrorSubsystem::FAILSAFE_VIBE, LogErrorCode::FAILSAFE_OCCURRED)
gcs().send_text(MAV_SEVERITY_CRITICAL, ""Vibration compensation ON"")
}
} else {
if (do_bad_vibe_actions) {
vibration_check.clear_ms = now
}
if (now - vibration_check.clear_ms > 15000) {
vibration_check.start_ms = 0
vibration_check.high_vibes = false
pos_control->set_vibe_comp(false)
vibration_check.clear_ms = 0
AP::logger().Write_Error(LogErrorSubsystem::FAILSAFE_VIBE, LogErrorCode::FAILSAFE_RESOLVED)
gcs().send_text(MAV_SEVERITY_CRITICAL, ""Vibration compensation OFF"")
}
}

return
}
"
113,Arducopter\esc_calibration.cpp_esc_calibration_startup_check,"void Copter::esc_calibration_startup_check()
{
if (motors->is_brushed_pwm_type()) {
return
}

uint8_t i = 0
while ((i++ < 100) && (last_radio_update_ms == 0)) {
hal.scheduler->delay(20)
read_radio()
}

if (!arming.rc_calibration_checks(true)) {
if ((g.esc_calibrate != ESCCalibrationModes::ESCCAL_NONE) && (g.esc_calibrate != ESCCalibrationModes::ESCCAL_DISABLED)) {
g.esc_calibrate.set_and_save(ESCCalibrationModes::ESCCAL_NONE)
}
return
}

switch (g.esc_calibrate) {
case ESCCalibrationModes::ESCCAL_NONE:
if (channel_throttle->get_control_in() >= ESC_CALIBRATION_HIGH_THROTTLE) {
g.esc_calibrate.set_and_save(ESCCalibrationModes::ESCCAL_PASSTHROUGH_IF_THROTTLE_HIGH)
gcs().send_text(MAV_SEVERITY_CRITICAL,""ESC calibration: Restart board"")
AP_Notify::flags.esc_calibration = true
while(1) { hal.scheduler->delay(5)
}
break
case ESCCalibrationModes::ESCCAL_PASSTHROUGH_IF_THROTTLE_HIGH:
if (channel_throttle->get_control_in() >= ESC_CALIBRATION_HIGH_THROTTLE) {
esc_calibration_passthrough()
}
break
case ESCCalibrationModes::ESCCAL_PASSTHROUGH_ALWAYS:
esc_calibration_passthrough()
break
case ESCCalibrationModes::ESCCAL_AUTO:
esc_calibration_auto()
break
case ESCCalibrationModes::ESCCAL_DISABLED:
default:
break
}

if (g.esc_calibrate != ESCCalibrationModes::ESCCAL_DISABLED) {
g.esc_calibrate.set_and_save(ESCCalibrationModes::ESCCAL_NONE)
}
}
"
114,Arducopter\esc_calibration.cpp_esc_calibration_passthrough,"void Copter::esc_calibration_passthrough()
{
gcs().send_text(MAV_SEVERITY_INFO,""ESC calibration: Passing pilot throttle to ESCs"")

esc_calibration_setup()

while(1) {
esc_calibration_notify()

read_radio()

hal.scheduler->delay(3)

SRV_Channels::cork()
motors->set_throttle_passthrough_for_esc_calibration(channel_throttle->get_control_in() * 0.001f)
SRV_Channels::push()
}
}
"
115,Arducopter\esc_calibration.cpp_esc_calibration_auto,"void Copter::esc_calibration_auto()
{
gcs().send_text(MAV_SEVERITY_INFO,""ESC calibration: Auto calibration"")

esc_calibration_setup()

SRV_Channels::cork()
motors->set_throttle_passthrough_for_esc_calibration(1.0f)
SRV_Channels::push()

uint32_t tstart = millis()
while (millis() - tstart < 5000) {
SRV_Channels::cork()
motors->set_throttle_passthrough_for_esc_calibration(1.0f)
SRV_Channels::push()
esc_calibration_notify()
hal.scheduler->delay(3)
}

while(1) {
SRV_Channels::cork()
motors->set_throttle_passthrough_for_esc_calibration(0.0f)
SRV_Channels::push()
esc_calibration_notify()
hal.scheduler->delay(3)
}
}
"
116,Arducopter\esc_calibration.cpp_esc_calibration_notify,"void Copter::esc_calibration_notify()
{
AP_Notify::flags.esc_calibration = true
uint32_t now = AP_HAL::millis()
if (now - esc_calibration_notify_update_ms > 20) {
esc_calibration_notify_update_ms = now
notify.update()
}
}
"
117,Arducopter\esc_calibration.cpp_esc_calibration_setup,"void Copter::esc_calibration_setup()
{
g.esc_calibrate.set_and_save(ESCCAL_NONE)

if (motors->is_normal_pwm_type()) {
motors->set_update_rate(g.rc_speed)
} else {
motors->set_update_rate(50)
}

BoardConfig.init_safety()

uint32_t tstart = 0
while (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {
const uint32_t tnow = AP_HAL::millis()
if (tnow - tstart >= 5000) {
gcs().send_text(MAV_SEVERITY_INFO,""ESC calibration: Push safety switch"")
tstart = tnow
}
esc_calibration_notify()
hal.scheduler->delay(3)
}

motors->armed(true)
SRV_Channels::enable_by_mask(motors->get_motor_mask())
hal.util->set_soft_armed(true)
}
"
118,Arducopter\events.cpp_failsafe_option,"bool Copter::failsafe_option(FailsafeOption opt) const
{
return (g2.fs_options & (uint32_t)opt)
}
"
119,Arducopter\events.cpp_failsafe_radio_on_event,"void Copter::failsafe_radio_on_event()
{
AP::logger().Write_Error(LogErrorSubsystem::FAILSAFE_RADIO, LogErrorCode::FAILSAFE_OCCURRED)

FailsafeAction desired_action
switch (g.failsafe_throttle) {
case FS_THR_DISABLED:
desired_action = FailsafeAction::NONE
break
case FS_THR_ENABLED_ALWAYS_RTL:
case FS_THR_ENABLED_CONTINUE_MISSION:
desired_action = FailsafeAction::RTL
break
case FS_THR_ENABLED_ALWAYS_SMARTRTL_OR_RTL:
desired_action = FailsafeAction::SMARTRTL
break
case FS_THR_ENABLED_ALWAYS_SMARTRTL_OR_LAND:
desired_action = FailsafeAction::SMARTRTL_LAND
break
case FS_THR_ENABLED_ALWAYS_LAND:
desired_action = FailsafeAction::LAND
break
case FS_THR_ENABLED_AUTO_RTL_OR_RTL:
desired_action = FailsafeAction::AUTO_DO_LAND_START
break
default:
desired_action = FailsafeAction::LAND
}

if (should_disarm_on_failsafe()) {
announce_failsafe(""Radio"", ""Disarming"")
arming.disarm(AP_Arming::Method::RADIOFAILSAFE)
desired_action = FailsafeAction::NONE

} else if (flightmode->is_landing() && ((battery.has_failsafed() && battery.get_highest_failsafe_priority() <= FAILSAFE_LAND_PRIORITY))) {
announce_failsafe(""Radio + Battery"", ""Continuing Landing"")
desired_action = FailsafeAction::LAND

} else if (flightmode->is_landing() && failsafe_option(FailsafeOption::CONTINUE_IF_LANDING)) {
announce_failsafe(""Radio"", ""Continuing Landing"")
desired_action = FailsafeAction::LAND

} else if (flightmode->mode_number() == Mode::Number::AUTO && failsafe_option(FailsafeOption::RC_CONTINUE_IF_AUTO)) {
announce_failsafe(""Radio"", ""Continuing Auto"")
desired_action = FailsafeAction::NONE

} else if ((flightmode->in_guided_mode()) && failsafe_option(FailsafeOption::RC_CONTINUE_IF_GUIDED)) {
announce_failsafe(""Radio"", ""Continuing Guided Mode"")
desired_action = FailsafeAction::NONE

} else {
announce_failsafe(""Radio"")
}

do_failsafe_action(desired_action, ModeReason::RADIO_FAILSAFE)
}
"
120,Arducopter\events.cpp_failsafe_radio_off_event,"void Copter::failsafe_radio_off_event()
{
AP::logger().Write_Error(LogErrorSubsystem::FAILSAFE_RADIO, LogErrorCode::FAILSAFE_RESOLVED)
gcs().send_text(MAV_SEVERITY_WARNING, ""Radio Failsafe Cleared"")
}
"
121,Arducopter\events.cpp_announce_failsafe,"void Copter::announce_failsafe(const char *type, const char *action_undertaken)
{
if (action_undertaken != nullptr) {
gcs().send_text(MAV_SEVERITY_WARNING, ""%s Failsafe - %s"", type, action_undertaken)
} else {
gcs().send_text(MAV_SEVERITY_WARNING, ""%s Failsafe"", type)
}
}
"
122,Arducopter\events.cpp_handle_battery_failsafe,"void Copter::handle_battery_failsafe(const char *type_str, const int8_t action)
{
AP::logger().Write_Error(LogErrorSubsystem::FAILSAFE_BATT, LogErrorCode::FAILSAFE_OCCURRED)

FailsafeAction desired_action = (FailsafeAction)action

if (should_disarm_on_failsafe()) {
arming.disarm(AP_Arming::Method::BATTERYFAILSAFE)
desired_action = FailsafeAction::NONE
announce_failsafe(""Battery"", ""Disarming"")

} else if (flightmode->is_landing() && failsafe_option(FailsafeOption::CONTINUE_IF_LANDING) && desired_action != FailsafeAction::NONE) {
desired_action = FailsafeAction::LAND
announce_failsafe(""Battery"", ""Continuing Landing"")
} else {
announce_failsafe(""Battery"")
}

do_failsafe_action(desired_action, ModeReason::BATTERY_FAILSAFE)

}
"
123,Arducopter\events.cpp_failsafe_gcs_check,"void Copter::failsafe_gcs_check()
{
if (g.failsafe_gcs == FS_GCS_DISABLED) {
return
}

const uint32_t gcs_last_seen_ms = gcs().sysid_myggcs_last_seen_time_ms()
if (gcs_last_seen_ms == 0) {
return
}

const uint32_t last_gcs_update_ms = millis() - gcs_last_seen_ms
const uint32_t gcs_timeout_ms = uint32_t(constrain_float(g2.fs_gcs_timeout * 1000.0f, 0.0f, UINT32_MAX))

if (last_gcs_update_ms < gcs_timeout_ms && failsafe.gcs) {
set_failsafe_gcs(false)
failsafe_gcs_off_event()

} else if (last_gcs_update_ms < gcs_timeout_ms && !failsafe.gcs) {

} else if (last_gcs_update_ms > gcs_timeout_ms && failsafe.gcs) {

} else if (last_gcs_update_ms > gcs_timeout_ms && !failsafe.gcs) {
set_failsafe_gcs(true)
failsafe_gcs_on_event()
}
}
"
124,Arducopter\events.cpp_failsafe_gcs_on_event,"void Copter::failsafe_gcs_on_event(void)
{
AP::logger().Write_Error(LogErrorSubsystem::FAILSAFE_GCS, LogErrorCode::FAILSAFE_OCCURRED)
RC_Channels::clear_overrides()

FailsafeAction desired_action
switch (g.failsafe_gcs) {
case FS_GCS_DISABLED:
desired_action = FailsafeAction::NONE
break
case FS_GCS_ENABLED_ALWAYS_RTL:
case FS_GCS_ENABLED_CONTINUE_MISSION:
desired_action = FailsafeAction::RTL
break
case FS_GCS_ENABLED_ALWAYS_SMARTRTL_OR_RTL:
desired_action = FailsafeAction::SMARTRTL
break
case FS_GCS_ENABLED_ALWAYS_SMARTRTL_OR_LAND:
desired_action = FailsafeAction::SMARTRTL_LAND
break
case FS_GCS_ENABLED_ALWAYS_LAND:
desired_action = FailsafeAction::LAND
break
case FS_GCS_ENABLED_AUTO_RTL_OR_RTL:
desired_action = FailsafeAction::AUTO_DO_LAND_START
break
default: // if an invalid parameter value is set, the fallback is RTL
desired_action = FailsafeAction::RTL
}

if (!motors->armed()) {
desired_action = FailsafeAction::NONE
announce_failsafe(""GCS"")

} else if (should_disarm_on_failsafe()) {
arming.disarm(AP_Arming::Method::GCSFAILSAFE)
desired_action = FailsafeAction::NONE
announce_failsafe(""GCS"", ""Disarming"")

} else if (flightmode->is_landing() && ((battery.has_failsafed() && battery.get_highest_failsafe_priority() <= FAILSAFE_LAND_PRIORITY))) {
announce_failsafe(""GCS + Battery"", ""Continuing Landing"")
desired_action = FailsafeAction::LAND

} else if (flightmode->is_landing() && failsafe_option(FailsafeOption::CONTINUE_IF_LANDING)) {
announce_failsafe(""GCS"", ""Continuing Landing"")
desired_action = FailsafeAction::LAND

} else if (flightmode->mode_number() == Mode::Number::AUTO && failsafe_option(FailsafeOption::GCS_CONTINUE_IF_AUTO)) {
announce_failsafe(""GCS"", ""Continuing Auto Mode"")
desired_action = FailsafeAction::NONE

} else if (failsafe_option(FailsafeOption::GCS_CONTINUE_IF_PILOT_CONTROL) && !flightmode->is_autopilot()) {
announce_failsafe(""GCS"", ""Continuing Pilot Control"")
desired_action = FailsafeAction::NONE
} else {
announce_failsafe(""GCS"")
}

do_failsafe_action(desired_action, ModeReason::GCS_FAILSAFE)
}
"
125,Arducopter\events.cpp_failsafe_gcs_off_event,"void Copter::failsafe_gcs_off_event(void)
{
gcs().send_text(MAV_SEVERITY_WARNING, ""GCS Failsafe Cleared"")
AP::logger().Write_Error(LogErrorSubsystem::FAILSAFE_GCS, LogErrorCode::FAILSAFE_RESOLVED)
}
"
126,Arducopter\events.cpp_failsafe_terrain_check,"void Copter::failsafe_terrain_check()
{
bool timeout = (failsafe.terrain_last_failure_ms - failsafe.terrain_first_failure_ms) > FS_TERRAIN_TIMEOUT_MS
bool trigger_event = timeout && flightmode->requires_terrain_failsafe()

if (trigger_event != failsafe.terrain) {
if (trigger_event) {
failsafe_terrain_on_event()
} else {
AP::logger().Write_Error(LogErrorSubsystem::FAILSAFE_TERRAIN, LogErrorCode::ERROR_RESOLVED)
failsafe.terrain = false
}
}
}
"
127,Arducopter\events.cpp_failsafe_terrain_set_status,"void Copter::failsafe_terrain_set_status(bool data_ok)
{
uint32_t now = millis()

if (!data_ok) {
failsafe.terrain_last_failure_ms = now
if (failsafe.terrain_first_failure_ms == 0) {
failsafe.terrain_first_failure_ms = now
}
} else {
if (now - failsafe.terrain_last_failure_ms > 100) {
failsafe.terrain_last_failure_ms = 0
failsafe.terrain_first_failure_ms = 0
}
}
}
"
128,Arducopter\events.cpp_failsafe_terrain_on_event,"void Copter::failsafe_terrain_on_event()
{
failsafe.terrain = true
gcs().send_text(MAV_SEVERITY_CRITICAL,""Failsafe: Terrain data missing"")
AP::logger().Write_Error(LogErrorSubsystem::FAILSAFE_TERRAIN, LogErrorCode::FAILSAFE_OCCURRED)

if (should_disarm_on_failsafe()) {
arming.disarm(AP_Arming::Method::TERRAINFAILSAFE)
} else if (flightmode->mode_number() == Mode::Number::RTL) {
mode_rtl.restart_without_terrain()
} else {
set_mode_RTL_or_land_with_pause(ModeReason::TERRAIN_FAILSAFE)
}
}
"
129,Arducopter\events.cpp_gpsglitch_check,"void Copter::gpsglitch_check()
{
nav_filter_status filt_status = inertial_nav.get_filter_status()
bool gps_glitching = filt_status.flags.gps_glitching

if (ap.gps_glitching != gps_glitching) {
ap.gps_glitching = gps_glitching
if (gps_glitching) {
AP::logger().Write_Error(LogErrorSubsystem::GPS, LogErrorCode::GPS_GLITCH)
gcs().send_text(MAV_SEVERITY_CRITICAL,""GPS Glitch or Compass error"")
} else {
AP::logger().Write_Error(LogErrorSubsystem::GPS, LogErrorCode::ERROR_RESOLVED)
gcs().send_text(MAV_SEVERITY_CRITICAL,""Glitch cleared"")
}
}
}
"
130,Arducopter\events.cpp_failsafe_deadreckon_check,"void Copter::failsafe_deadreckon_check()
{
const char* dr_prefix_str = ""Dead Reckoning""

bool ekf_dead_reckoning = inertial_nav.get_filter_status().flags.dead_reckoning

const uint32_t now_ms = AP_HAL::millis()
if (dead_reckoning.active != ekf_dead_reckoning) {
dead_reckoning.active = ekf_dead_reckoning
if (dead_reckoning.active) {
dead_reckoning.start_ms = now_ms
gcs().send_text(MAV_SEVERITY_CRITICAL,""%s started"", dr_prefix_str)
} else {
dead_reckoning.start_ms = 0
dead_reckoning.timeout = false
gcs().send_text(MAV_SEVERITY_CRITICAL,""%s stopped"", dr_prefix_str)
}
}

if (dead_reckoning.active && !dead_reckoning.timeout) {
const uint32_t dr_timeout_ms = uint32_t(constrain_float(g2.failsafe_dr_timeout * 1000.0f, 0.0f, UINT32_MAX))
if (now_ms - dead_reckoning.start_ms > dr_timeout_ms) {
dead_reckoning.timeout = true
gcs().send_text(MAV_SEVERITY_CRITICAL,""%s timeout"", dr_prefix_str)
}
}

if (g2.failsafe_dr_enable <= 0) {
failsafe.deadreckon = false
return
}

if (failsafe.deadreckon != ekf_dead_reckoning) {
failsafe.deadreckon = ekf_dead_reckoning

if (failsafe.deadreckon && copter.flightmode->requires_GPS()) {

AP::logger().Write_Error(LogErrorSubsystem::FAILSAFE_DEADRECKON, LogErrorCode::FAILSAFE_OCCURRED)

if (should_disarm_on_failsafe()) {
arming.disarm(AP_Arming::Method::DEADRECKON_FAILSAFE)
return
}

do_failsafe_action((FailsafeAction)g2.failsafe_dr_enable.get(), ModeReason::DEADRECKON_FAILSAFE)
}
}
}
"
131,Arducopter\events.cpp_set_mode_RTL_or_land_with_pause,"void Copter::set_mode_RTL_or_land_with_pause(ModeReason reason)
{
if (!set_mode(Mode::Number::RTL, reason)) {
set_mode_land_with_pause(reason)
} else {
AP_Notify::events.failsafe_mode_change = 1
}
}
"
132,Arducopter\events.cpp_set_mode_SmartRTL_or_land_with_pause,"void Copter::set_mode_SmartRTL_or_land_with_pause(ModeReason reason)
{
if (!set_mode(Mode::Number::SMART_RTL, reason)) {
gcs().send_text(MAV_SEVERITY_WARNING, ""SmartRTL Unavailable, Using Land Mode"")
set_mode_land_with_pause(reason)
} else {
AP_Notify::events.failsafe_mode_change = 1
}
}
"
133,Arducopter\events.cpp_set_mode_SmartRTL_or_RTL,"void Copter::set_mode_SmartRTL_or_RTL(ModeReason reason)
{
if (!set_mode(Mode::Number::SMART_RTL, reason)) {
gcs().send_text(MAV_SEVERITY_WARNING, ""SmartRTL Unavailable, Trying RTL Mode"")
set_mode_RTL_or_land_with_pause(reason)
} else {
AP_Notify::events.failsafe_mode_change = 1
}
}
"
134,Arducopter\events.cpp_set_mode_auto_do_land_start_or_RTL,"void Copter::set_mode_auto_do_land_start_or_RTL(ModeReason reason)
{
if (set_mode(Mode::Number::AUTO_RTL, reason)) {
AP_Notify::events.failsafe_mode_change = 1
return
}

gcs().send_text(MAV_SEVERITY_WARNING, ""Trying RTL Mode"")
set_mode_RTL_or_land_with_pause(reason)
}
"
135,Arducopter\events.cpp_should_disarm_on_failsafe,"bool Copter::should_disarm_on_failsafe() {
if (ap.in_arming_delay) {
return true
}

switch (flightmode->mode_number()) {
case Mode::Number::STABILIZE:
case Mode::Number::ACRO:
return ap.throttle_zero || ap.land_complete
case Mode::Number::AUTO:
case Mode::Number::AUTO_RTL:
return !ap.auto_armed && ap.land_complete
default:
return ap.land_complete
}
}
"
136,Arducopter\events.cpp_do_failsafe_action,"void Copter::do_failsafe_action(FailsafeAction action, ModeReason reason){

switch (action) {
case FailsafeAction::NONE:
return
case FailsafeAction::LAND:
set_mode_land_with_pause(reason)
break
case FailsafeAction::RTL:
set_mode_RTL_or_land_with_pause(reason)
break
case FailsafeAction::SMARTRTL:
set_mode_SmartRTL_or_RTL(reason)
break
case FailsafeAction::SMARTRTL_LAND:
set_mode_SmartRTL_or_land_with_pause(reason)
break
case FailsafeAction::TERMINATE: {
g2.afs.gcs_terminate(true, ""Failsafe"")
arming.disarm(AP_Arming::Method::FAILSAFE_ACTION_TERMINATE)
break
}
case FailsafeAction::AUTO_DO_LAND_START:
set_mode_auto_do_land_start_or_RTL(reason)
break
}

if (failsafe_option(FailsafeOption::RELEASE_GRIPPER)) {
copter.g2.gripper.release()
}
}
"
137,Arducopter\failsafe.cpp_failsafe_enable,"void Copter::failsafe_enable()
{
failsafe_enabled = true
failsafe_last_timestamp = micros()
}
"
138,Arducopter\failsafe.cpp_failsafe_disable,"void Copter::failsafe_disable()
{
failsafe_enabled = false
}
"
139,Arducopter\failsafe.cpp_failsafe_check,"void Copter::failsafe_check()
{
uint32_t tnow = AP_HAL::micros()

const uint16_t ticks = scheduler.ticks()
if (ticks != failsafe_last_ticks) {
failsafe_last_ticks = ticks
failsafe_last_timestamp = tnow
if (in_failsafe) {
in_failsafe = false
AP::logger().Write_Error(LogErrorSubsystem::CPU, LogErrorCode::FAILSAFE_RESOLVED)
}
return
}

if (!in_failsafe && failsafe_enabled && tnow - failsafe_last_timestamp > 2000000) {
in_failsafe = true
if (motors->armed()) {
motors->output_min()
}

AP::logger().Write_Error(LogErrorSubsystem::CPU, LogErrorCode::FAILSAFE_OCCURRED)
}

if (failsafe_enabled && in_failsafe && tnow - failsafe_last_timestamp > 1000000) {
failsafe_last_timestamp = tnow
if(motors->armed()) {
motors->armed(false)
motors->output()
}
}
}
"
140,Arducopter\failsafe.cpp_afs_fs_check,"void Copter::afs_fs_check(void)
{
const bool fence_breached = fence.get_breaches() != 0
const bool fence_breached = false
g2.afs.check(fence_breached, last_radio_update_ms)
}
"
141,Arducopter\fence.cpp_fence_check,"void Copter::fence_check()
{
const uint8_t orig_breaches = fence.get_breaches()

const uint8_t new_breaches = fence.check()

if (!motors->armed()) {
return
}

if (new_breaches) {

if (!copter.ap.land_complete) {
GCS_SEND_TEXT(MAV_SEVERITY_NOTICE, ""Fence Breached"")
}

uint8_t fence_act = fence.get_action()
if (fence_act != AC_FENCE_ACTION_REPORT_ONLY ) {

if (ap.land_complete || (flightmode->has_manual_throttle() && ap.throttle_zero && !failsafe.radio && ((fence.get_breaches() & AC_FENCE_TYPE_ALT_MAX)== 0))){
arming.disarm(AP_Arming::Method::FENCEBREACH)

} else {

if (fence.get_breach_distance(new_breaches) > AC_FENCE_GIVE_UP_DISTANCE) {
set_mode(Mode::Number::LAND, ModeReason::FENCE_BREACHED)
} else {
switch (fence_act) {
case AC_FENCE_ACTION_RTL_AND_LAND:
default:
if (!set_mode(Mode::Number::RTL, ModeReason::FENCE_BREACHED)) {
set_mode(Mode::Number::LAND, ModeReason::FENCE_BREACHED)
}
break
case AC_FENCE_ACTION_ALWAYS_LAND:
set_mode(Mode::Number::LAND, ModeReason::FENCE_BREACHED)
break
case AC_FENCE_ACTION_SMART_RTL:
if (!set_mode(Mode::Number::SMART_RTL, ModeReason::FENCE_BREACHED)) {
if (!set_mode(Mode::Number::RTL, ModeReason::FENCE_BREACHED)) {
set_mode(Mode::Number::LAND, ModeReason::FENCE_BREACHED)
}
}
break
case AC_FENCE_ACTION_BRAKE:
if (!set_mode(Mode::Number::BRAKE, ModeReason::FENCE_BREACHED)) {
set_mode(Mode::Number::LAND, ModeReason::FENCE_BREACHED)
}
break
case AC_FENCE_ACTION_SMART_RTL_OR_LAND:
if (!set_mode(Mode::Number::SMART_RTL, ModeReason::FENCE_BREACHED)) {
set_mode(Mode::Number::LAND, ModeReason::FENCE_BREACHED)
}
break
}
}
}
}

AP::logger().Write_Error(LogErrorSubsystem::FAILSAFE_FENCE, LogErrorCode(new_breaches))

} else if (orig_breaches) {
AP::logger().Write_Error(LogErrorSubsystem::FAILSAFE_FENCE, LogErrorCode::ERROR_RESOLVED)
}
}
"
142,Arducopter\GCS_Copter.cpp_sysid_this_mav,"uint8_t GCS_Copter::sysid_this_mav() const
{
return copter.g.sysid_this_mav
}
"
143,Arducopter\GCS_Copter.cpp_frame_string,"const char* GCS_Copter::frame_string() const
{
if (copter.motors == nullptr) {
return ""motors not allocated""
}
return copter.motors->get_frame_string()
}
"
144,Arducopter\GCS_Copter.cpp_simple_input_active,"bool GCS_Copter::simple_input_active() const
{
return copter.simple_mode == Copter::SimpleMode::SIMPLE
}
"
145,Arducopter\GCS_Copter.cpp_supersimple_input_active,"bool GCS_Copter::supersimple_input_active() const
{
return copter.simple_mode == Copter::SimpleMode::SUPERSIMPLE
}
"
146,Arducopter\GCS_Copter.cpp_update_vehicle_sensor_status_flags,"void GCS_Copter::update_vehicle_sensor_status_flags(void)
{
control_sensors_present |=
MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL |
MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION |
MAV_SYS_STATUS_SENSOR_YAW_POSITION

control_sensors_enabled |=
MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL |
MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION |
MAV_SYS_STATUS_SENSOR_YAW_POSITION

control_sensors_health |=
MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL |
MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION |
MAV_SYS_STATUS_SENSOR_YAW_POSITION

const Copter::ap_t &ap = copter.ap

if (ap.rc_receiver_present) {
control_sensors_present |= MAV_SYS_STATUS_SENSOR_RC_RECEIVER
control_sensors_enabled |= MAV_SYS_STATUS_SENSOR_RC_RECEIVER
}
if (ap.rc_receiver_present && !copter.failsafe.radio) {
control_sensors_health |= MAV_SYS_STATUS_SENSOR_RC_RECEIVER
}

control_sensors_present |= MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL
control_sensors_present |= MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL

switch (copter.flightmode->mode_number()) {
case Mode::Number::AUTO:
case Mode::Number::AUTO_RTL:
case Mode::Number::AVOID_ADSB:
case Mode::Number::GUIDED:
case Mode::Number::LOITER:
case Mode::Number::RTL:
case Mode::Number::CIRCLE:
case Mode::Number::LAND:
case Mode::Number::POSHOLD:
case Mode::Number::BRAKE:
case Mode::Number::THROW:
case Mode::Number::SMART_RTL:
control_sensors_enabled |= MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL
control_sensors_health |= MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL
control_sensors_enabled |= MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL
control_sensors_health |= MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL
break
case Mode::Number::ALT_HOLD:
case Mode::Number::GUIDED_NOGPS:
case Mode::Number::SPORT:
case Mode::Number::AUTOTUNE:
case Mode::Number::FLOWHOLD:
control_sensors_enabled |= MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL
control_sensors_health |= MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL
break
default:
break
}

if (copter.g2.proximity.sensor_present()) {
control_sensors_present |= MAV_SYS_STATUS_SENSOR_PROXIMITY
}
if (copter.g2.proximity.sensor_enabled()) {
control_sensors_enabled |= MAV_SYS_STATUS_SENSOR_PROXIMITY
}
if (!copter.g2.proximity.sensor_failed()) {
control_sensors_health |= MAV_SYS_STATUS_SENSOR_PROXIMITY
}

const RangeFinder *rangefinder = RangeFinder::get_singleton()
if (rangefinder && rangefinder->has_orientation(ROTATION_PITCH_270)) {
control_sensors_present |= MAV_SYS_STATUS_SENSOR_LASER_POSITION
}
if (copter.rangefinder_state.enabled) {
control_sensors_enabled |= MAV_SYS_STATUS_SENSOR_LASER_POSITION
if (rangefinder && rangefinder->has_data_orient(ROTATION_PITCH_270)) {
control_sensors_health |= MAV_SYS_STATUS_SENSOR_LASER_POSITION
}
}

const AP_OpticalFlow *optflow = AP::opticalflow()
if (optflow && optflow->enabled()) {
control_sensors_present |= MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW
control_sensors_enabled |= MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW
}
if (optflow && optflow->healthy()) {
control_sensors_health |= MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW
}

if (copter.precland.enabled()) {
control_sensors_present |= MAV_SYS_STATUS_SENSOR_VISION_POSITION
control_sensors_enabled |= MAV_SYS_STATUS_SENSOR_VISION_POSITION
}
if (copter.precland.enabled() && copter.precland.healthy()) {
control_sensors_health |= MAV_SYS_STATUS_SENSOR_VISION_POSITION
}

switch (copter.terrain.status()) {
case AP_Terrain::TerrainStatusDisabled:
break
case AP_Terrain::TerrainStatusUnhealthy:
case AP_Terrain::TerrainStatusOK:
control_sensors_present |= MAV_SYS_STATUS_TERRAIN
control_sensors_enabled |= MAV_SYS_STATUS_TERRAIN
control_sensors_health  |= MAV_SYS_STATUS_TERRAIN
break
}

control_sensors_present |= MAV_SYS_STATUS_SENSOR_PROPULSION
control_sensors_enabled |= MAV_SYS_STATUS_SENSOR_PROPULSION
if (!copter.motors->get_thrust_boost()) {
control_sensors_health |= MAV_SYS_STATUS_SENSOR_PROPULSION
}
}
"
147,Arducopter\GCS_Mavlink.cpp_frame_type,"MAV_TYPE GCS_Copter::frame_type() const
{
if (copter.motors == nullptr) {
return MAV_TYPE_GENERIC
}
return copter.motors->get_frame_mav_type()
}
"
148,Arducopter\GCS_Mavlink.cpp_base_mode,"MAV_MODE GCS_MAVLINK_Copter::base_mode() const
{
uint8_t _base_mode = MAV_MODE_FLAG_STABILIZE_ENABLED
switch (copter.flightmode->mode_number()) {
case Mode::Number::AUTO:
case Mode::Number::AUTO_RTL:
case Mode::Number::RTL:
case Mode::Number::LOITER:
case Mode::Number::AVOID_ADSB:
case Mode::Number::FOLLOW:
case Mode::Number::GUIDED:
case Mode::Number::CIRCLE:
case Mode::Number::POSHOLD:
case Mode::Number::BRAKE:
case Mode::Number::SMART_RTL:
_base_mode |= MAV_MODE_FLAG_GUIDED_ENABLED
break
default:
break
}

_base_mode |= MAV_MODE_FLAG_MANUAL_INPUT_ENABLED

if (copter.motors != nullptr && copter.motors->armed()) {
_base_mode |= MAV_MODE_FLAG_SAFETY_ARMED
}

_base_mode |= MAV_MODE_FLAG_CUSTOM_MODE_ENABLED

return (MAV_MODE)_base_mode
}
"
149,Arducopter\GCS_Mavlink.cpp_custom_mode,"uint32_t GCS_Copter::custom_mode() const
{
return (uint32_t)copter.flightmode->mode_number()
}
"
150,Arducopter\GCS_Mavlink.cpp_vehicle_system_status,"MAV_STATE GCS_MAVLINK_Copter::vehicle_system_status() const
{
if (copter.any_failsafe_triggered())  {
return MAV_STATE_CRITICAL
}

if (copter.ap.land_complete) {
return MAV_STATE_STANDBY
}

return MAV_STATE_ACTIVE
}
"
151,Arducopter\GCS_Mavlink.cpp_send_attitude_target,"void GCS_MAVLINK_Copter::send_attitude_target()
{
const Quaternion quat  = copter.attitude_control->get_attitude_target_quat()
const Vector3f ang_vel = copter.attitude_control->get_attitude_target_ang_vel()
const float thrust = copter.attitude_control->get_throttle_in()

const float quat_out[4] {quat.q1, quat.q2, quat.q3, quat.q4}

const uint16_t typemask = 0

mavlink_msg_attitude_target_send(
chan,
AP_HAL::millis(),       // time since boot (ms)
typemask,               // Bitmask that tells the system what control dimensions should be ignored by the vehicle
quat_out,               // Attitude quaternion [w, x, y, z] order, zero-rotation is [1, 0, 0, 0], unit-length
ang_vel.x,              // roll rate (rad/s)
ang_vel.y,              // pitch rate (rad/s)
ang_vel.z,              // yaw rate (rad/s)
thrust)
}
"
152,Arducopter\GCS_Mavlink.cpp_send_position_target_global_int,"void GCS_MAVLINK_Copter::send_position_target_global_int()
{
Location target
if (!copter.flightmode->get_wp(target)) {
return
}

if (!target.change_alt_frame(Location::AltFrame::ABSOLUTE)) {
return
}
static constexpr uint16_t POSITION_TARGET_TYPEMASK_LAST_BYTE = 0xF000
static constexpr uint16_t TYPE_MASK = POSITION_TARGET_TYPEMASK_VX_IGNORE | POSITION_TARGET_TYPEMASK_VY_IGNORE | POSITION_TARGET_TYPEMASK_VZ_IGNORE |
POSITION_TARGET_TYPEMASK_AX_IGNORE | POSITION_TARGET_TYPEMASK_AY_IGNORE | POSITION_TARGET_TYPEMASK_AZ_IGNORE |
POSITION_TARGET_TYPEMASK_YAW_IGNORE | POSITION_TARGET_TYPEMASK_YAW_RATE_IGNORE | POSITION_TARGET_TYPEMASK_LAST_BYTE
mavlink_msg_position_target_global_int_send(
chan,
AP_HAL::millis(), // time_boot_ms
MAV_FRAME_GLOBAL, // targets are always global altitude
TYPE_MASK, // ignore everything except the x/y/z components
target.lat, // latitude as 1e7
target.lng, // longitude as 1e7
target.alt * 0.01f, // altitude is sent as a float
0.0f, // vx
0.0f, // vy
0.0f, // vz
0.0f, // afx
0.0f, // afy
0.0f, // afz
0.0f, // yaw
0.0f)
}
"
153,Arducopter\GCS_Mavlink.cpp_send_position_target_local_ned,"void GCS_MAVLINK_Copter::send_position_target_local_ned()
{
if (!copter.flightmode->in_guided_mode()) {
return
}

const ModeGuided::SubMode guided_mode = copter.mode_guided.submode()
Vector3f target_pos
Vector3f target_vel
Vector3f target_accel
uint16_t type_mask = 0

switch (guided_mode) {
case ModeGuided::SubMode::Angle:
return
case ModeGuided::SubMode::TakeOff:
case ModeGuided::SubMode::WP:
case ModeGuided::SubMode::Pos:
type_mask = POSITION_TARGET_TYPEMASK_VX_IGNORE | POSITION_TARGET_TYPEMASK_VY_IGNORE | POSITION_TARGET_TYPEMASK_VZ_IGNORE |
POSITION_TARGET_TYPEMASK_AX_IGNORE | POSITION_TARGET_TYPEMASK_AY_IGNORE | POSITION_TARGET_TYPEMASK_AZ_IGNORE |
POSITION_TARGET_TYPEMASK_YAW_IGNORE| POSITION_TARGET_TYPEMASK_YAW_RATE_IGNORE
target_pos = copter.mode_guided.get_target_pos().tofloat() * 0.01
break
case ModeGuided::SubMode::PosVelAccel:
type_mask = POSITION_TARGET_TYPEMASK_YAW_IGNORE| POSITION_TARGET_TYPEMASK_YAW_RATE_IGNORE
target_pos = copter.mode_guided.get_target_pos().tofloat() * 0.01
target_vel = copter.mode_guided.get_target_vel() * 0.01f
target_accel = copter.mode_guided.get_target_accel() * 0.01f
break
case ModeGuided::SubMode::VelAccel:
type_mask = POSITION_TARGET_TYPEMASK_X_IGNORE | POSITION_TARGET_TYPEMASK_Y_IGNORE | POSITION_TARGET_TYPEMASK_Z_IGNORE |
POSITION_TARGET_TYPEMASK_YAW_IGNORE| POSITION_TARGET_TYPEMASK_YAW_RATE_IGNORE
target_vel = copter.mode_guided.get_target_vel() * 0.01f
target_accel = copter.mode_guided.get_target_accel() * 0.01f
break
case ModeGuided::SubMode::Accel:
type_mask = POSITION_TARGET_TYPEMASK_X_IGNORE | POSITION_TARGET_TYPEMASK_Y_IGNORE | POSITION_TARGET_TYPEMASK_Z_IGNORE |
POSITION_TARGET_TYPEMASK_VX_IGNORE | POSITION_TARGET_TYPEMASK_VY_IGNORE | POSITION_TARGET_TYPEMASK_VZ_IGNORE |
POSITION_TARGET_TYPEMASK_YAW_IGNORE| POSITION_TARGET_TYPEMASK_YAW_RATE_IGNORE
target_accel = copter.mode_guided.get_target_accel() * 0.01f
break
}

mavlink_msg_position_target_local_ned_send(
chan,
AP_HAL::millis(), // time boot ms
MAV_FRAME_LOCAL_NED,
type_mask,
target_pos.x,   // x in metres
target_pos.y,   // y in metres
-target_pos.z,  // z in metres NED frame
target_vel.x,   // vx in m/s
target_vel.y,   // vy in m/s
-target_vel.z,  // vz in m/s NED frame
target_accel.x, // afx in m/s/s
target_accel.y, // afy in m/s/s
-target_accel.z,// afz in m/s/s NED frame
0.0f, // yaw
0.0f)
}
"
154,Arducopter\GCS_Mavlink.cpp_send_nav_controller_output,"void GCS_MAVLINK_Copter::send_nav_controller_output() const
{
if (!copter.ap.initialised) {
return
}
const Vector3f &targets = copter.attitude_control->get_att_target_euler_cd()
const Mode *flightmode = copter.flightmode
mavlink_msg_nav_controller_output_send(
chan,
targets.x * 1.0e-2f,
targets.y * 1.0e-2f,
targets.z * 1.0e-2f,
flightmode->wp_bearing() * 1.0e-2f,
MIN(flightmode->wp_distance() * 1.0e-2f, UINT16_MAX),
copter.pos_control->get_pos_error_z_cm() * 1.0e-2f,
0,
flightmode->crosstrack_error() * 1.0e-2f)
}
"
155,Arducopter\GCS_Mavlink.cpp_vfr_hud_airspeed,"float GCS_MAVLINK_Copter::vfr_hud_airspeed() const
{
if (copter.airspeed.enabled() && copter.airspeed.healthy()) {
return copter.airspeed.get_airspeed()
}

Vector3f airspeed_vec_bf
if (AP::ahrs().airspeed_vector_true(airspeed_vec_bf)) {
return airspeed_vec_bf.length()
}
return AP::gps().ground_speed()
}
"
156,Arducopter\GCS_Mavlink.cpp_vfr_hud_throttle,"int16_t GCS_MAVLINK_Copter::vfr_hud_throttle() const
{
if (copter.motors == nullptr) {
return 0
}
return (int16_t)(copter.motors->get_throttle() * 100)
}
"
157,Arducopter\GCS_Mavlink.cpp_send_pid_tuning,"void GCS_MAVLINK_Copter::send_pid_tuning()
{
static const PID_TUNING_AXIS axes[] = {
PID_TUNING_ROLL,
PID_TUNING_PITCH,
PID_TUNING_YAW,
PID_TUNING_ACCZ
}
for (uint8_t i=0
if (!(copter.g.gcs_pid_mask & (1<<(axes[i]-1)))) {
continue
}
if (!HAVE_PAYLOAD_SPACE(chan, PID_TUNING)) {
return
}
const AP_PIDInfo *pid_info = nullptr
switch (axes[i]) {
case PID_TUNING_ROLL:
pid_info = &copter.attitude_control->get_rate_roll_pid().get_pid_info()
break
case PID_TUNING_PITCH:
pid_info = &copter.attitude_control->get_rate_pitch_pid().get_pid_info()
break
case PID_TUNING_YAW:
pid_info = &copter.attitude_control->get_rate_yaw_pid().get_pid_info()
break
case PID_TUNING_ACCZ:
pid_info = &copter.pos_control->get_accel_z_pid().get_pid_info()
break
default:
continue
}
if (pid_info != nullptr) {
mavlink_msg_pid_tuning_send(chan,
axes[i],
pid_info->target,
pid_info->actual,
pid_info->FF,
pid_info->P,
pid_info->I,
pid_info->D,
pid_info->slew_rate,
pid_info->Dmod)
}
}
}
"
158,Arducopter\GCS_Mavlink.cpp_send_winch_status,"void GCS_MAVLINK_Copter::send_winch_status() const
{
AP_Winch *winch = AP::winch()
if (winch == nullptr) {
return
}
winch->send_status(*this)
}
"
159,Arducopter\GCS_Mavlink.cpp_sysid_my_gcs,"uint8_t GCS_MAVLINK_Copter::sysid_my_gcs() const
{
return copter.g.sysid_my_gcs
}
"
160,Arducopter\GCS_Mavlink.cpp_sysid_enforce,"bool GCS_MAVLINK_Copter::sysid_enforce() const
{
return copter.g2.sysid_enforce
}
"
161,Arducopter\GCS_Mavlink.cpp_telem_delay,"uint32_t GCS_MAVLINK_Copter::telem_delay() const
{
return (uint32_t)(copter.g.telem_delay)
}
"
162,Arducopter\GCS_Mavlink.cpp_vehicle_initialised,"bool GCS_Copter::vehicle_initialised() const {
return copter.ap.initialised
}
"
163,Arducopter\GCS_Mavlink.cpp_try_send_message,"bool GCS_MAVLINK_Copter::try_send_message(enum ap_message id)
{
switch(id) {

case MSG_TERRAIN:
CHECK_PAYLOAD_SIZE(TERRAIN_REQUEST)
copter.terrain.send_request(chan)
break

case MSG_WIND:
CHECK_PAYLOAD_SIZE(WIND)
send_wind()
break

case MSG_SERVO_OUT:
case MSG_AOA_SSA:
case MSG_LANDING:
break

case MSG_ADSB_VEHICLE: {
CHECK_PAYLOAD_SIZE(ADSB_VEHICLE)
copter.adsb.send_adsb_vehicle(chan)
AP_OADatabase *oadb = AP_OADatabase::get_singleton()
if (oadb != nullptr) {
CHECK_PAYLOAD_SIZE(ADSB_VEHICLE)
uint16_t interval_ms = 0
if (get_ap_message_interval(id, interval_ms)) {
oadb->send_adsb_vehicle(chan, interval_ms)
}
}
break
}

default:
return GCS_MAVLINK::try_send_message(id)
}
return true
}
"
164,Arducopter\GCS_Mavlink.cpp_handle_guided_request,"bool GCS_MAVLINK_Copter::handle_guided_request(AP_Mission::Mission_Command &cmd)
{
return copter.mode_auto.do_guided(cmd)
return false
}
"
165,Arducopter\GCS_Mavlink.cpp_packetReceived,"void GCS_MAVLINK_Copter::packetReceived(const mavlink_status_t &status,
const mavlink_message_t &msg)
{
if (copter.g2.dev_options.get() & DevOptionADSBMAVLink) {
copter.avoidance_adsb.handle_msg(msg)
}
copter.g2.follow.handle_msg(msg)
GCS_MAVLINK::packetReceived(status, msg)
}
"
166,Arducopter\GCS_Mavlink.cpp_params_ready,"bool GCS_MAVLINK_Copter::params_ready() const
{
if (AP_BoardConfig::in_config_error()) {
return true
}
return copter.ap.initialised_params
}
"
167,Arducopter\GCS_Mavlink.cpp_send_banner,"void GCS_MAVLINK_Copter::send_banner()
{
GCS_MAVLINK::send_banner()
if (copter.motors == nullptr) {
send_text(MAV_SEVERITY_INFO, ""motors not allocated"")
return
}
char frame_and_type_string[30]
copter.motors->get_frame_and_type_string(frame_and_type_string, ARRAY_SIZE(frame_and_type_string))
send_text(MAV_SEVERITY_INFO, ""%s"", frame_and_type_string)
}
"
168,Arducopter\GCS_Mavlink.cpp_handle_command_ack,"void GCS_MAVLINK_Copter::handle_command_ack(const mavlink_message_t &msg)
{
copter.command_ack_counter++
GCS_MAVLINK::handle_command_ack(msg)
}
"
169,Arducopter\GCS_Mavlink.cpp_handle_landing_target,"void GCS_MAVLINK_Copter::handle_landing_target(const mavlink_landing_target_t &packet, uint32_t timestamp_ms)
{
copter.precland.handle_msg(packet, timestamp_ms)
}
"
170,Arducopter\GCS_Mavlink.cpp__handle_command_preflight_calibration,"MAV_RESULT GCS_MAVLINK_Copter::_handle_command_preflight_calibration(const mavlink_command_long_t &packet)
{
if (is_equal(packet.param6,1.0f)) {
return copter.mavlink_compassmot(*this)
}

return GCS_MAVLINK::_handle_command_preflight_calibration(packet)
}
"
171,Arducopter\GCS_Mavlink.cpp_handle_command_do_set_roi,"MAV_RESULT GCS_MAVLINK_Copter::handle_command_do_set_roi(const Location &roi_loc)
{
if (!roi_loc.check_latlng()) {
return MAV_RESULT_FAILED
}
copter.flightmode->auto_yaw.set_roi(roi_loc)
return MAV_RESULT_ACCEPTED
}
"
172,Arducopter\GCS_Mavlink.cpp_handle_preflight_reboot,"MAV_RESULT GCS_MAVLINK_Copter::handle_preflight_reboot(const mavlink_command_long_t &packet, const mavlink_message_t &msg)
{
if (copter.g.esc_calibrate == (uint8_t)Copter::ESCCalibrationModes::ESCCAL_AUTO) {
send_text(MAV_SEVERITY_CRITICAL, ""Reboot rejected, ESC cal on reboot"")
return MAV_RESULT_FAILED
}

return GCS_MAVLINK::handle_preflight_reboot(packet, msg)
}
"
173,Arducopter\GCS_Mavlink.cpp_set_home_to_current_location,"bool GCS_MAVLINK_Copter::set_home_to_current_location(bool _lock) {
return copter.set_home_to_current_location(_lock)
}
"
174,Arducopter\GCS_Mavlink.cpp_set_home,"bool GCS_MAVLINK_Copter::set_home(const Location& loc, bool _lock) {
return copter.set_home(loc, _lock)
}
"
175,Arducopter\GCS_Mavlink.cpp_handle_command_int_do_reposition,"MAV_RESULT GCS_MAVLINK_Copter::handle_command_int_do_reposition(const mavlink_command_int_t &packet)
{
const bool change_modes = ((int32_t)packet.param2 & MAV_DO_REPOSITION_FLAGS_CHANGE_MODE) == MAV_DO_REPOSITION_FLAGS_CHANGE_MODE
if (!copter.flightmode->in_guided_mode() && !change_modes) {
return MAV_RESULT_DENIED
}

if (!check_latlng(packet.x, packet.y)) {
return MAV_RESULT_DENIED
}

Location request_location
if (!location_from_command_t(packet, request_location)) {
return MAV_RESULT_DENIED
}

if (request_location.sanitize(copter.current_loc)) {
return MAV_RESULT_DENIED
}

if (!copter.mode_guided.set_destination(request_location, false, 0, false, 0)) {
return MAV_RESULT_FAILED
}

if (!copter.flightmode->in_guided_mode()) {
if (!copter.set_mode(Mode::Number::GUIDED, ModeReason::GCS_COMMAND)) {
return MAV_RESULT_FAILED
}
if (!copter.mode_guided.set_destination(request_location, false, 0, false, 0)) {
return MAV_RESULT_FAILED
}
}

return MAV_RESULT_ACCEPTED
}
"
176,Arducopter\GCS_Mavlink.cpp_handle_command_int_packet,"MAV_RESULT GCS_MAVLINK_Copter::handle_command_int_packet(const mavlink_command_int_t &packet)
{
switch(packet.command) {
case MAV_CMD_DO_FOLLOW:
if ((packet.param1 > 0) && (packet.param1 <= 255)) {
copter.g2.follow.set_target_sysid((uint8_t)packet.param1)
return MAV_RESULT_ACCEPTED
}
return MAV_RESULT_UNSUPPORTED

case MAV_CMD_DO_REPOSITION:
return handle_command_int_do_reposition(packet)

case MAV_CMD_DO_PAUSE_CONTINUE:
return handle_command_pause_continue(packet)

default:
return GCS_MAVLINK::handle_command_int_packet(packet)
}
}
"
177,Arducopter\GCS_Mavlink.cpp_handle_command_mount,"MAV_RESULT GCS_MAVLINK_Copter::handle_command_mount(const mavlink_command_long_t &packet)
{
switch (packet.command) {
case MAV_CMD_DO_MOUNT_CONTROL:
if ((copter.camera_mount.get_mount_type() != copter.camera_mount.MountType::Mount_Type_None) &&
!copter.camera_mount.has_pan_control()) {
copter.flightmode->auto_yaw.set_yaw_angle_rate((float)packet.param3, 0.0f)
}
break
default:
break
}
return GCS_MAVLINK::handle_command_mount(packet)
}
"
178,Arducopter\GCS_Mavlink.cpp_handle_command_long_packet,"MAV_RESULT GCS_MAVLINK_Copter::handle_command_long_packet(const mavlink_command_long_t &packet)
{
switch(packet.command) {

case MAV_CMD_NAV_VTOL_TAKEOFF:
case MAV_CMD_NAV_TAKEOFF: {

float takeoff_alt = packet.param7 * 100

if (!copter.flightmode->do_user_takeoff(takeoff_alt, is_zero(packet.param3))) {
return MAV_RESULT_FAILED
}
return MAV_RESULT_ACCEPTED
}

case MAV_CMD_DO_LAND_START:
if (copter.mode_auto.jump_to_landing_sequence_auto_RTL(ModeReason::GCS_COMMAND)) {
return MAV_RESULT_ACCEPTED
}
return MAV_RESULT_FAILED

case MAV_CMD_NAV_LOITER_UNLIM:
if (!copter.set_mode(Mode::Number::LOITER, ModeReason::GCS_COMMAND)) {
return MAV_RESULT_FAILED
}
return MAV_RESULT_ACCEPTED

case MAV_CMD_NAV_RETURN_TO_LAUNCH:
if (!copter.set_mode(Mode::Number::RTL, ModeReason::GCS_COMMAND)) {
return MAV_RESULT_FAILED
}
return MAV_RESULT_ACCEPTED

case MAV_CMD_NAV_VTOL_LAND:
case MAV_CMD_NAV_LAND:
if (!copter.set_mode(Mode::Number::LAND, ModeReason::GCS_COMMAND)) {
return MAV_RESULT_FAILED
}
return MAV_RESULT_ACCEPTED

case MAV_CMD_DO_FOLLOW:
if ((packet.param1 > 0) && (packet.param1 <= 255)) {
copter.g2.follow.set_target_sysid((uint8_t)packet.param1)
return MAV_RESULT_ACCEPTED
}
return MAV_RESULT_FAILED

case MAV_CMD_CONDITION_YAW:
if ((packet.param1 >= 0.0f)   &&
(packet.param1 <= 360.0f) &&
(is_zero(packet.param4) || is_equal(packet.param4,1.0f))) {
copter.flightmode->auto_yaw.set_fixed_yaw(
packet.param1,
packet.param2,
(int8_t)packet.param3,
is_positive(packet.param4))
return MAV_RESULT_ACCEPTED
}
return MAV_RESULT_FAILED

case MAV_CMD_DO_CHANGE_SPEED:
if (packet.param2 > 0.0f) {
if (packet.param1 > 2.9f) { // 3 = speed down
if (copter.flightmode->set_speed_down(packet.param2 * 100.0f)) {
return MAV_RESULT_ACCEPTED
}
return MAV_RESULT_FAILED
} else if (packet.param1 > 1.9f) { // 2 = speed up
if (copter.flightmode->set_speed_up(packet.param2 * 100.0f)) {
return MAV_RESULT_ACCEPTED
}
return MAV_RESULT_FAILED
} else {
if (copter.flightmode->set_speed_xy(packet.param2 * 100.0f)) {
return MAV_RESULT_ACCEPTED
}
return MAV_RESULT_FAILED
}
}
return MAV_RESULT_FAILED

case MAV_CMD_MISSION_START:
if (copter.set_mode(Mode::Number::AUTO, ModeReason::GCS_COMMAND)) {
copter.set_auto_armed(true)
if (copter.mode_auto.mission.state() != AP_Mission::MISSION_RUNNING) {
copter.mode_auto.mission.start_or_resume()
}
return MAV_RESULT_ACCEPTED
}
return MAV_RESULT_FAILED

case MAV_CMD_DO_PARACHUTE:
switch ((uint16_t)packet.param1) {
case PARACHUTE_DISABLE:
copter.parachute.enabled(false)
return MAV_RESULT_ACCEPTED
case PARACHUTE_ENABLE:
copter.parachute.enabled(true)
return MAV_RESULT_ACCEPTED
case PARACHUTE_RELEASE:
copter.parachute_manual_release()
return MAV_RESULT_ACCEPTED
}
return MAV_RESULT_FAILED

case MAV_CMD_DO_MOTOR_TEST:
return copter.mavlink_motor_test_start(*this,
(uint8_t)packet.param1,
(uint8_t)packet.param2,
packet.param3,
packet.param4,
(uint8_t)packet.param5)

case MAV_CMD_DO_WINCH:
if (!copter.g2.winch.enabled()) {
return MAV_RESULT_FAILED
}
switch ((uint8_t)packet.param2) {
case WINCH_RELAXED:
copter.g2.winch.relax()
return MAV_RESULT_ACCEPTED
case WINCH_RELATIVE_LENGTH_CONTROL: {
copter.g2.winch.release_length(packet.param3)
return MAV_RESULT_ACCEPTED
}
case WINCH_RATE_CONTROL:
copter.g2.winch.set_desired_rate(packet.param4)
return MAV_RESULT_ACCEPTED
default:
break
}
return MAV_RESULT_FAILED

case MAV_CMD_AIRFRAME_CONFIGURATION: {
switch ((uint8_t)packet.param2) {
case 1:
copter.landinggear.set_position(AP_LandingGear::LandingGear_Retract)
return MAV_RESULT_ACCEPTED
default:
copter.landinggear.set_position(AP_LandingGear::LandingGear_Deploy)
return MAV_RESULT_ACCEPTED
}
return MAV_RESULT_FAILED
}

case MAV_CMD_SOLO_BTN_FLY_CLICK: {
if (copter.failsafe.radio) {
return MAV_RESULT_ACCEPTED
}

if (!copter.set_mode(Mode::Number::LOITER, ModeReason::GCS_COMMAND)) {
copter.set_mode(Mode::Number::ALT_HOLD, ModeReason::GCS_COMMAND)
}
return MAV_RESULT_ACCEPTED
}

case MAV_CMD_SOLO_BTN_FLY_HOLD: {
if (copter.failsafe.radio) {
return MAV_RESULT_ACCEPTED
}

if (!copter.motors->armed()) {
copter.arming.arm(AP_Arming::Method::MAVLINK)
} else if (copter.ap.land_complete) {
if (copter.set_mode(Mode::Number::LOITER, ModeReason::GCS_COMMAND)) {
copter.flightmode->do_user_takeoff(packet.param1*100, true)
}
} else {
copter.set_mode(Mode::Number::LAND, ModeReason::GCS_COMMAND)
}
return MAV_RESULT_ACCEPTED
}

case MAV_CMD_SOLO_BTN_PAUSE_CLICK: {
if (copter.failsafe.radio) {
return MAV_RESULT_ACCEPTED
}

if (copter.motors->armed()) {
if (copter.ap.land_complete) {
copter.arming.disarm(AP_Arming::Method::SOLOPAUSEWHENLANDED)
} else {
bool shot_mode = (!is_zero(packet.param1) && (copter.flightmode->mode_number() == Mode::Number::GUIDED || copter.flightmode->mode_number() == Mode::Number::GUIDED_NOGPS))

if (!shot_mode) {
if (copter.set_mode(Mode::Number::BRAKE, ModeReason::GCS_COMMAND)) {
copter.mode_brake.timeout_to_loiter_ms(2500)
} else {
copter.set_mode(Mode::Number::ALT_HOLD, ModeReason::GCS_COMMAND)
}
copter.set_mode(Mode::Number::ALT_HOLD, ModeReason::GCS_COMMAND)
} else {
}
}
}
return MAV_RESULT_ACCEPTED
}

case MAV_CMD_DO_PAUSE_CONTINUE: {
mavlink_command_int_t packet_int
GCS_MAVLINK_Copter::convert_COMMAND_LONG_to_COMMAND_INT(packet, packet_int)
return handle_command_pause_continue(packet_int)
}
default:
return GCS_MAVLINK::handle_command_long_packet(packet)
}
}
"
179,Arducopter\GCS_Mavlink.cpp_handle_command_pause_continue,"MAV_RESULT GCS_MAVLINK_Copter::handle_command_pause_continue(const mavlink_command_int_t &packet)
{
if ((uint8_t) packet.param1 == 0) {
if (copter.flightmode->pause()) {
return MAV_RESULT_ACCEPTED
}
send_text(MAV_SEVERITY_INFO, ""Failed to pause"")
return MAV_RESULT_FAILED
}

if ((uint8_t) packet.param1 == 1) {
if (copter.flightmode->resume()) {
return MAV_RESULT_ACCEPTED
}
send_text(MAV_SEVERITY_INFO, ""Failed to resume"")
return MAV_RESULT_FAILED
}
return MAV_RESULT_DENIED
}
"
180,Arducopter\GCS_Mavlink.cpp_handle_mount_message,"void GCS_MAVLINK_Copter::handle_mount_message(const mavlink_message_t &msg)
{
switch (msg.msgid) {
case MAVLINK_MSG_ID_MOUNT_CONTROL:
if ((copter.camera_mount.get_mount_type() != copter.camera_mount.MountType::Mount_Type_None) &&
!copter.camera_mount.has_pan_control()) {
copter.flightmode->auto_yaw.set_yaw_angle_rate(
mavlink_msg_mount_control_get_input_c(&msg) * 0.01f,
0.0f)

break
}
}
GCS_MAVLINK::handle_mount_message(msg)
}
"
181,Arducopter\GCS_Mavlink.cpp_handleMessage,"void GCS_MAVLINK_Copter::handleMessage(const mavlink_message_t &msg)
{
constexpr uint32_t MAVLINK_SET_POS_TYPE_MASK_POS_IGNORE =
POSITION_TARGET_TYPEMASK_X_IGNORE |
POSITION_TARGET_TYPEMASK_Y_IGNORE |
POSITION_TARGET_TYPEMASK_Z_IGNORE

constexpr uint32_t MAVLINK_SET_POS_TYPE_MASK_VEL_IGNORE =
POSITION_TARGET_TYPEMASK_VX_IGNORE |
POSITION_TARGET_TYPEMASK_VY_IGNORE |
POSITION_TARGET_TYPEMASK_VZ_IGNORE

constexpr uint32_t MAVLINK_SET_POS_TYPE_MASK_ACC_IGNORE =
POSITION_TARGET_TYPEMASK_AX_IGNORE |
POSITION_TARGET_TYPEMASK_AY_IGNORE |
POSITION_TARGET_TYPEMASK_AZ_IGNORE

constexpr uint32_t MAVLINK_SET_POS_TYPE_MASK_YAW_IGNORE =
POSITION_TARGET_TYPEMASK_YAW_IGNORE
constexpr uint32_t MAVLINK_SET_POS_TYPE_MASK_YAW_RATE_IGNORE =
POSITION_TARGET_TYPEMASK_YAW_RATE_IGNORE
constexpr uint32_t MAVLINK_SET_POS_TYPE_MASK_FORCE_SET =
POSITION_TARGET_TYPEMASK_FORCE_SET

switch (msg.msgid) {

case MAVLINK_MSG_ID_MANUAL_CONTROL:
{
if (msg.sysid != copter.g.sysid_my_gcs) {
break
}

mavlink_manual_control_t packet
mavlink_msg_manual_control_decode(&msg, &packet)

if (packet.target != copter.g.sysid_this_mav) {
break
}

if (packet.z < 0) { // Copter doesn't do negative thrust
break
}

uint32_t tnow = AP_HAL::millis()

manual_override(copter.channel_roll, packet.y, 1000, 2000, tnow)
manual_override(copter.channel_pitch, packet.x, 1000, 2000, tnow, true)
manual_override(copter.channel_throttle, packet.z, 0, 1000, tnow)
manual_override(copter.channel_yaw, packet.r, 1000, 2000, tnow)

gcs().sysid_myggcs_seen(tnow)
break
}

case MAVLINK_MSG_ID_SET_ATTITUDE_TARGET:   // MAV ID: 82
{
mavlink_set_attitude_target_t packet
mavlink_msg_set_attitude_target_decode(&msg, &packet)

if (!copter.flightmode->in_guided_mode()) {
break
}

const bool roll_rate_ignore   = packet.type_mask & ATTITUDE_TARGET_TYPEMASK_BODY_ROLL_RATE_IGNORE
const bool pitch_rate_ignore  = packet.type_mask & ATTITUDE_TARGET_TYPEMASK_BODY_PITCH_RATE_IGNORE
const bool yaw_rate_ignore    = packet.type_mask & ATTITUDE_TARGET_TYPEMASK_BODY_YAW_RATE_IGNORE
const bool throttle_ignore    = packet.type_mask & ATTITUDE_TARGET_TYPEMASK_THROTTLE_IGNORE
const bool attitude_ignore    = packet.type_mask & ATTITUDE_TARGET_TYPEMASK_ATTITUDE_IGNORE

if (throttle_ignore) {
break
}

Quaternion attitude_quat
if (attitude_ignore) {
attitude_quat.zero()
} else {
attitude_quat = Quaternion(packet.q[0],packet.q[1],packet.q[2],packet.q[3])

if (!attitude_quat.is_unit_length()) {
break
}
}

const bool use_thrust = copter.mode_guided.set_attitude_target_provides_thrust()

float climb_rate_or_thrust
if (use_thrust) {
climb_rate_or_thrust = constrain_float(packet.thrust, -1.0f, 1.0f)
} else {
packet.thrust = constrain_float(packet.thrust, 0.0f, 1.0f)
if (is_equal(packet.thrust, 0.5f)) {
climb_rate_or_thrust = 0.0f
} else if (packet.thrust > 0.5f) {
climb_rate_or_thrust = (packet.thrust - 0.5f) * 2.0f * copter.wp_nav->get_default_speed_up()
} else {
climb_rate_or_thrust = (0.5f - packet.thrust) * 2.0f * -copter.wp_nav->get_default_speed_down()
}
}

Vector3f ang_vel
if (!roll_rate_ignore) {
ang_vel.x = packet.body_roll_rate
}
if (!pitch_rate_ignore) {
ang_vel.y = packet.body_pitch_rate
}
if (!yaw_rate_ignore) {
ang_vel.z = packet.body_yaw_rate
}

copter.mode_guided.set_angle(attitude_quat, ang_vel,
climb_rate_or_thrust, use_thrust)

break
}

case MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED:     // MAV ID: 84
{
mavlink_set_position_target_local_ned_t packet
mavlink_msg_set_position_target_local_ned_decode(&msg, &packet)

if (!copter.flightmode->in_guided_mode()) {
break
}

if (packet.coordinate_frame != MAV_FRAME_LOCAL_NED &&
packet.coordinate_frame != MAV_FRAME_LOCAL_OFFSET_NED &&
packet.coordinate_frame != MAV_FRAME_BODY_NED &&
packet.coordinate_frame != MAV_FRAME_BODY_OFFSET_NED) {
copter.mode_guided.init(true)
break
}

bool pos_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_POS_IGNORE
bool vel_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_VEL_IGNORE
bool acc_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_ACC_IGNORE
bool yaw_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_IGNORE
bool yaw_rate_ignore = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_RATE_IGNORE
bool force_set       = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_FORCE_SET

if (force_set && !acc_ignore) {
break
}

Vector3f pos_vector
if (!pos_ignore) {
pos_vector = Vector3f(packet.x * 100.0f, packet.y * 100.0f, -packet.z * 100.0f)
if (packet.coordinate_frame == MAV_FRAME_BODY_NED ||
packet.coordinate_frame == MAV_FRAME_BODY_OFFSET_NED) {
copter.rotate_body_frame_to_NE(pos_vector.x, pos_vector.y)
}
if (packet.coordinate_frame == MAV_FRAME_LOCAL_OFFSET_NED ||
packet.coordinate_frame == MAV_FRAME_BODY_NED ||
packet.coordinate_frame == MAV_FRAME_BODY_OFFSET_NED) {
pos_vector += copter.inertial_nav.get_position_neu_cm()
}
}

Vector3f vel_vector
if (!vel_ignore) {
vel_vector = Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f)
if (packet.coordinate_frame == MAV_FRAME_BODY_NED || packet.coordinate_frame == MAV_FRAME_BODY_OFFSET_NED) {
copter.rotate_body_frame_to_NE(vel_vector.x, vel_vector.y)
}
}

Vector3f accel_vector
if (!acc_ignore) {
accel_vector = Vector3f(packet.afx * 100.0f, packet.afy * 100.0f, -packet.afz * 100.0f)
if (packet.coordinate_frame == MAV_FRAME_BODY_NED || packet.coordinate_frame == MAV_FRAME_BODY_OFFSET_NED) {
copter.rotate_body_frame_to_NE(accel_vector.x, accel_vector.y)
}
}

float yaw_cd = 0.0f
bool yaw_relative = false
float yaw_rate_cds = 0.0f
if (!yaw_ignore) {
yaw_cd = ToDeg(packet.yaw) * 100.0f
yaw_relative = packet.coordinate_frame == MAV_FRAME_BODY_NED || packet.coordinate_frame == MAV_FRAME_BODY_OFFSET_NED
}
if (!yaw_rate_ignore) {
yaw_rate_cds = ToDeg(packet.yaw_rate) * 100.0f
}

if (!pos_ignore && !vel_ignore) {
copter.mode_guided.set_destination_posvelaccel(pos_vector, vel_vector, accel_vector, !yaw_ignore, yaw_cd, !yaw_rate_ignore, yaw_rate_cds, yaw_relative)
} else if (pos_ignore && !vel_ignore) {
copter.mode_guided.set_velaccel(vel_vector, accel_vector, !yaw_ignore, yaw_cd, !yaw_rate_ignore, yaw_rate_cds, yaw_relative)
} else if (pos_ignore && vel_ignore && !acc_ignore) {
copter.mode_guided.set_accel(accel_vector, !yaw_ignore, yaw_cd, !yaw_rate_ignore, yaw_rate_cds, yaw_relative)
} else if (!pos_ignore && vel_ignore && acc_ignore) {
copter.mode_guided.set_destination(pos_vector, !yaw_ignore, yaw_cd, !yaw_rate_ignore, yaw_rate_cds, yaw_relative, false)
} else {
copter.mode_guided.init(true)
}

break
}

case MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT:    // MAV ID: 86
{
mavlink_set_position_target_global_int_t packet
mavlink_msg_set_position_target_global_int_decode(&msg, &packet)

if (!copter.flightmode->in_guided_mode()) {
break
}


bool pos_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_POS_IGNORE
bool vel_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_VEL_IGNORE
bool acc_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_ACC_IGNORE
bool yaw_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_IGNORE
bool yaw_rate_ignore = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_RATE_IGNORE
bool force_set       = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_FORCE_SET

if (force_set && !acc_ignore) {
break
}

Location loc
if (!pos_ignore) {
if (!check_latlng(packet.lat_int, packet.lon_int)) {
copter.mode_guided.init(true)
break
}
Location::AltFrame frame
if (!mavlink_coordinate_frame_to_location_alt_frame((MAV_FRAME)packet.coordinate_frame, frame)) {
copter.mode_guided.init(true)
break
}
loc = {packet.lat_int, packet.lon_int, int32_t(packet.alt*100), frame}
}

Vector3f vel_vector
if (!vel_ignore) {
vel_vector = Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f)
}

Vector3f accel_vector
if (!acc_ignore) {
accel_vector = Vector3f(packet.afx * 100.0f, packet.afy * 100.0f, -packet.afz * 100.0f)
}

float yaw_cd = 0.0f
float yaw_rate_cds = 0.0f
if (!yaw_ignore) {
yaw_cd = ToDeg(packet.yaw) * 100.0f
}
if (!yaw_rate_ignore) {
yaw_rate_cds = ToDeg(packet.yaw_rate) * 100.0f
}

if (!pos_ignore && !vel_ignore) {
if (loc.get_alt_frame() == Location::AltFrame::ABOVE_TERRAIN) {
copter.mode_guided.init(true)
break
}
Vector3f pos_neu_cm
if (!loc.get_vector_from_origin_NEU(pos_neu_cm)) {
copter.mode_guided.init(true)
break
}
copter.mode_guided.set_destination_posvel(pos_neu_cm, vel_vector, !yaw_ignore, yaw_cd, !yaw_rate_ignore, yaw_rate_cds)
} else if (pos_ignore && !vel_ignore) {
copter.mode_guided.set_velaccel(vel_vector, accel_vector, !yaw_ignore, yaw_cd, !yaw_rate_ignore, yaw_rate_cds)
} else if (pos_ignore && vel_ignore && !acc_ignore) {
copter.mode_guided.set_accel(accel_vector, !yaw_ignore, yaw_cd, !yaw_rate_ignore, yaw_rate_cds)
} else if (!pos_ignore && vel_ignore && acc_ignore) {
copter.mode_guided.set_destination(loc, !yaw_ignore, yaw_cd, !yaw_rate_ignore, yaw_rate_cds)
} else {
copter.mode_guided.init(true)
}

break
}

case MAVLINK_MSG_ID_RADIO:
case MAVLINK_MSG_ID_RADIO_STATUS:       // MAV ID: 109
{
handle_radio_status(msg, copter.should_log(MASK_LOG_PM))
break
}

case MAVLINK_MSG_ID_TERRAIN_DATA:
case MAVLINK_MSG_ID_TERRAIN_CHECK:
copter.terrain.handle_data(chan, msg)
break

case MAVLINK_MSG_ID_NAMED_VALUE_INT:
copter.g2.toy_mode.handle_message(msg)
break

default:
handle_common_message(msg)
break
}     // end switch
} // end handle mavlink
"
182,Arducopter\GCS_Mavlink.cpp_handle_flight_termination,"MAV_RESULT GCS_MAVLINK_Copter::handle_flight_termination(const mavlink_command_long_t &packet) {
if (GCS_MAVLINK::handle_flight_termination(packet) == MAV_RESULT_ACCEPTED) {
return MAV_RESULT_ACCEPTED
}
if (packet.param1 > 0.5f) {
copter.arming.disarm(AP_Arming::Method::TERMINATION)
return MAV_RESULT_ACCEPTED
}

return MAV_RESULT_FAILED
}
"
183,Arducopter\GCS_Mavlink.cpp_vfr_hud_alt,"float GCS_MAVLINK_Copter::vfr_hud_alt() const
{
if (copter.g2.dev_options.get() & DevOptionVFR_HUDRelativeAlt) {
return copter.current_loc.alt * 0.01f
}
return GCS_MAVLINK::vfr_hud_alt()
}
"
184,Arducopter\GCS_Mavlink.cpp_capabilities,"uint64_t GCS_MAVLINK_Copter::capabilities() const
{
return (MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT |
MAV_PROTOCOL_CAPABILITY_MISSION_INT |
MAV_PROTOCOL_CAPABILITY_COMMAND_INT |
MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED |
MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT |
MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION |
MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET |
(copter.terrain.enabled() ? MAV_PROTOCOL_CAPABILITY_TERRAIN : 0) |
GCS_MAVLINK::capabilities())
}
"
185,Arducopter\GCS_Mavlink.cpp_landed_state,"MAV_LANDED_STATE GCS_MAVLINK_Copter::landed_state() const
{
if (copter.ap.land_complete) {
return MAV_LANDED_STATE_ON_GROUND
}
if (copter.flightmode->is_landing()) {
return MAV_LANDED_STATE_LANDING
}
if (copter.flightmode->is_taking_off()) {
return MAV_LANDED_STATE_TAKEOFF
}
return MAV_LANDED_STATE_IN_AIR
}
"
186,Arducopter\GCS_Mavlink.cpp_send_wind,"void GCS_MAVLINK_Copter::send_wind() const
{
Vector3f airspeed_vec_bf
if (!AP::ahrs().airspeed_vector_true(airspeed_vec_bf)) {
return
}
const Vector3f wind = AP::ahrs().wind_estimate()
mavlink_msg_wind_send(
chan,
degrees(atan2f(-wind.y, -wind.x)),
wind.length(),
wind.z)
}
"
187,Arducopter\GCS_Mavlink.cpp_high_latency_target_altitude,"int16_t GCS_MAVLINK_Copter::high_latency_target_altitude() const
{
AP_AHRS &ahrs = AP::ahrs()
struct Location global_position_current
UNUSED_RESULT(ahrs.get_location(global_position_current))

if (copter.ap.initialised) {
return 0.01 * (global_position_current.alt + copter.pos_control->get_pos_error_z_cm())
}
return 0

}
"
188,Arducopter\GCS_Mavlink.cpp_high_latency_tgt_heading,"uint8_t GCS_MAVLINK_Copter::high_latency_tgt_heading() const
{
if (copter.ap.initialised) {
const Mode *flightmode = copter.flightmode
return wrap_360_cd(flightmode->wp_bearing()) / 200
}
return 0
}
"
189,Arducopter\GCS_Mavlink.cpp_high_latency_tgt_dist,"uint16_t GCS_MAVLINK_Copter::high_latency_tgt_dist() const
{
if (copter.ap.initialised) {
const Mode *flightmode = copter.flightmode
return MIN(flightmode->wp_distance() * 1.0e-2, UINT16_MAX) / 10
}
return 0
}
"
190,Arducopter\GCS_Mavlink.cpp_high_latency_tgt_airspeed,"uint8_t GCS_MAVLINK_Copter::high_latency_tgt_airspeed() const
{
if (copter.ap.initialised) {
return MIN(copter.pos_control->get_vel_target_cms().length() * 5.0e-2, UINT8_MAX)
}
return 0
}
"
191,Arducopter\GCS_Mavlink.cpp_high_latency_wind_speed,"uint8_t GCS_MAVLINK_Copter::high_latency_wind_speed() const
{
Vector3f airspeed_vec_bf
Vector3f wind
if (AP::ahrs().airspeed_vector_true(airspeed_vec_bf)) {
wind = AP::ahrs().wind_estimate()
return wind.length() * 5
}
return 0
}
"
192,Arducopter\GCS_Mavlink.cpp_high_latency_wind_direction,"uint8_t GCS_MAVLINK_Copter::high_latency_wind_direction() const
{
Vector3f airspeed_vec_bf
Vector3f wind
if (AP::ahrs().airspeed_vector_true(airspeed_vec_bf)) {
wind = AP::ahrs().wind_estimate()
return wrap_360(degrees(atan2f(-wind.y, -wind.x))) / 2
}
return 0
}
"
193,Arducopter\heli.cpp_heli_init,"void Copter::heli_init()
{
input_manager.set_use_stab_col(true)
input_manager.set_stab_col_ramp(1.0)
}
"
194,Arducopter\heli.cpp_check_dynamic_flight,"void Copter::check_dynamic_flight(void)
{
if (motors->get_spool_state() != AP_Motors::SpoolState::THROTTLE_UNLIMITED ||
flightmode->is_landing()) {
heli_dynamic_flight_counter = 0
heli_flags.dynamic_flight = false
return
}

bool moving = false

if (position_ok()) {
const float speed = inertial_nav.get_speed_xy_cms()
moving = (speed >= HELI_DYNAMIC_FLIGHT_SPEED_MIN)
}else{
moving = (motors->get_throttle() > 0.8f || ahrs.pitch_sensor < -1500)
}

if (!moving && rangefinder_state.enabled && rangefinder.status_orient(ROTATION_PITCH_270) == RangeFinder::Status::Good) {
moving = (rangefinder.distance_cm_orient(ROTATION_PITCH_270) > 200)
}

if (moving) {
if (!heli_flags.dynamic_flight) {
heli_dynamic_flight_counter++
if (heli_dynamic_flight_counter >= 100) {
heli_flags.dynamic_flight = true
heli_dynamic_flight_counter = 100
}
}
}else{
if (heli_flags.dynamic_flight) {
if (heli_dynamic_flight_counter > 0) {
heli_dynamic_flight_counter--
}else{
heli_flags.dynamic_flight = false
}
}
}
}
"
195,Arducopter\heli.cpp_update_heli_control_dynamics,"void Copter::update_heli_control_dynamics(void)
{

if (!motors->using_leaky_integrator()) {
attitude_control->use_leaky_i(false)
if (ap.land_complete || ap.land_complete_maybe) {
motors->set_land_complete(true)
} else {
motors->set_land_complete(false)
}
} else {
attitude_control->use_leaky_i(!heli_flags.dynamic_flight)
motors->set_land_complete(false)
}

if (ap.land_complete || (is_zero(motors->get_desired_rotor_speed()))){
hover_roll_trim_scalar_slew--
} else {
hover_roll_trim_scalar_slew++
}
hover_roll_trim_scalar_slew = constrain_int16(hover_roll_trim_scalar_slew, 0, scheduler.get_loop_rate_hz())

attitude_control->set_hover_roll_trim_scalar((float) hover_roll_trim_scalar_slew/(float) scheduler.get_loop_rate_hz())
}
"
196,Arducopter\heli.cpp_should_use_landing_swash,"bool Copter::should_use_landing_swash() const
{
if (flightmode->has_manual_throttle() ||
flightmode->mode_number() == Mode::Number::DRIFT) {
return false
}
if (flightmode->is_landing()) {
return true
}
if (ap.land_complete) {
return true
}
if (!ap.auto_armed) {
return true
}
if (!heli_flags.dynamic_flight) {
return true
}
return false
}
"
197,Arducopter\heli.cpp_heli_update_landing_swash,"void Copter::heli_update_landing_swash()
{
motors->set_collective_for_landing(should_use_landing_swash())
update_collective_low_flag(channel_throttle->get_control_in())
}
"
198,Arducopter\heli.cpp_get_pilot_desired_rotor_speed,"float Copter::get_pilot_desired_rotor_speed() const
{
RC_Channel *rc_ptr = rc().find_channel_for_option(RC_Channel::AUX_FUNC::MOTOR_INTERLOCK)
if (rc_ptr != nullptr) {
rc_ptr->set_range(1000)
return (float)rc_ptr->get_control_in() * 0.001f
}
return 0.0f
}
"
199,Arducopter\heli.cpp_heli_update_rotor_speed_targets,"void Copter::heli_update_rotor_speed_targets()
{

static bool rotor_runup_complete_last = false

uint8_t rsc_control_mode = motors->get_rsc_mode()

switch (rsc_control_mode) {
case ROTOR_CONTROL_MODE_PASSTHROUGH:
if (get_pilot_desired_rotor_speed() > 0.01) {
ap.motor_interlock_switch = true
motors->set_desired_rotor_speed(get_pilot_desired_rotor_speed())
} else {
ap.motor_interlock_switch = false
motors->set_desired_rotor_speed(0.0f)
}
break
case ROTOR_CONTROL_MODE_SETPOINT:
case ROTOR_CONTROL_MODE_THROTTLECURVE:
case ROTOR_CONTROL_MODE_AUTOTHROTTLE:
if (motors->get_interlock()) {
motors->set_desired_rotor_speed(motors->get_rsc_setpoint())
}else{
motors->set_desired_rotor_speed(0.0f)
}
break
}

if (!rotor_runup_complete_last && motors->rotor_runup_complete()){
AP::logger().Write_Event(LogEvent::ROTOR_RUNUP_COMPLETE)
} else if (rotor_runup_complete_last && !motors->rotor_runup_complete()){
AP::logger().Write_Event(LogEvent::ROTOR_SPEED_BELOW_CRITICAL)
}
rotor_runup_complete_last = motors->rotor_runup_complete()
}
"
200,Arducopter\heli.cpp_heli_update_autorotation,"void Copter::heli_update_autorotation()
{
if (!ap.land_complete && !motors->get_interlock() && g2.arot.is_enable()) {
if (!flightmode->has_manual_throttle()) {
set_mode(Mode::Number::AUTOROTATE, ModeReason::AUTOROTATION_START)
}
heli_flags.in_autorotation = true
} else {
heli_flags.in_autorotation = false
}

heli_set_autorotation(heli_flags.in_autorotation)
if (!ap.land_complete && g2.arot.is_enable()) {
motors->set_enable_bailout(true)
} else {
motors->set_enable_bailout(false)
}
heli_flags.in_autorotation = false
motors->set_enable_bailout(false)
}
"
201,Arducopter\heli.cpp_heli_set_autorotation,"void Copter::heli_set_autorotation(bool autorotation)
{
motors->set_in_autorotation(autorotation)
}
"
202,Arducopter\heli.cpp_update_collective_low_flag,"void Copter::update_collective_low_flag(int16_t throttle_control)
{
static uint32_t last_nonzero_collective_ms = 0
uint32_t tnow_ms = millis()

if (throttle_control > 0) {
last_nonzero_collective_ms = tnow_ms
heli_flags.coll_stk_low = false
} else if (tnow_ms - last_nonzero_collective_ms > 400) {
heli_flags.coll_stk_low = true
}
}
"
203,Arducopter\inertia.cpp_read_inertia,"void Copter::read_inertia()
{
inertial_nav.update(vibration_check.high_vibes)

Location loc
ahrs.get_location(loc)
current_loc.lat = loc.lat
current_loc.lng = loc.lng

if (!inertial_nav.get_filter_status().flags.vert_pos) {
return
}

const int32_t alt_above_origin_cm = inertial_nav.get_position_z_up_cm()
current_loc.set_alt_cm(alt_above_origin_cm, Location::AltFrame::ABOVE_ORIGIN)
if (!ahrs.home_is_set() || !current_loc.change_alt_frame(Location::AltFrame::ABOVE_HOME)) {
current_loc.set_alt_cm(alt_above_origin_cm, Location::AltFrame::ABOVE_HOME)
}
}
"
204,Arducopter\landing_gear.cpp_landinggear_update,"void Copter::landinggear_update()
{
if (!SRV_Channels::function_assigned(SRV_Channel::k_landing_gear_control)) {
return
}

int32_t height_cm = flightmode->get_alt_above_ground_cm()

switch (rangefinder.status_orient(ROTATION_PITCH_270)) {
case RangeFinder::Status::NotConnected:
case RangeFinder::Status::NoData:
break

case RangeFinder::Status::OutOfRangeLow:
height_cm = 0
break

case RangeFinder::Status::OutOfRangeHigh:
case RangeFinder::Status::Good:
height_cm = rangefinder_state.alt_cm_filt.get()
break
}

landinggear.update(height_cm * 0.01f)
}
"
205,Arducopter\land_detector.cpp_update_land_and_crash_detectors,"void Copter::update_land_and_crash_detectors()
{
Vector3f accel_ef = ahrs.get_accel_ef()
accel_ef.z += GRAVITY_MSS
land_accel_ef_filter.apply(accel_ef, scheduler.get_loop_period_s())

update_land_detector()

parachute_check()

crash_check()
thrust_loss_check()
yaw_imbalance_check()
}
"
206,Arducopter\land_detector.cpp_set_land_complete,"void Copter::set_land_complete(bool b)
{
if( ap.land_complete == b )
return

land_detector_count = 0

if(b){
AP::logger().Write_Event(LogEvent::LAND_COMPLETE)
} else {
AP::logger().Write_Event(LogEvent::NOT_LANDED)
}
ap.land_complete = b

g2.stats.set_flying(!b)

set_likely_flying(!b)

bool disarm_on_land_configured = (g.throttle_behavior & THR_BEHAVE_DISARM_ON_LAND_DETECT) != 0
const bool mode_disarms_on_land = flightmode->allows_arming(AP_Arming::Method::LANDING) && !flightmode->has_manual_throttle()

if (ap.land_complete && motors->armed() && disarm_on_land_configured && mode_disarms_on_land) {
arming.disarm(AP_Arming::Method::LANDED)
}
}
"
207,Arducopter\land_detector.cpp_set_land_complete_maybe,"void Copter::set_land_complete_maybe(bool b)
{
if (ap.land_complete_maybe == b)
return

if (b) {
AP::logger().Write_Event(LogEvent::LAND_COMPLETE_MAYBE)
}
ap.land_complete_maybe = b
}
"
208,Arducopter\land_detector.cpp_update_throttle_mix,"void Copter::update_throttle_mix()
{
if (!motors->armed() || ap.land_complete) {
attitude_control->set_throttle_mix_min()
return
}

if (flightmode->has_manual_throttle()) {
if (channel_throttle->get_control_in() <= 0 && air_mode != AirMode::AIRMODE_ENABLED) {
attitude_control->set_throttle_mix_min()
} else {
attitude_control->set_throttle_mix_man()
}
} else {

const Vector3f angle_target = attitude_control->get_att_target_euler_cd()
bool large_angle_request = angle_target.xy().length() > LAND_CHECK_LARGE_ANGLE_CD

const float angle_error = attitude_control->get_att_error_angle_deg()
bool large_angle_error = (angle_error > LAND_CHECK_ANGLE_ERROR_DEG)

const bool accel_moving = (land_accel_ef_filter.get().length() > LAND_CHECK_ACCEL_MOVING)

bool descent_not_demanded = pos_control->get_vel_desired_cms().z >= 0.0f

const bool landing = flightmode->is_landing()

if (((large_angle_request || force_flying) && !landing) || large_angle_error || accel_moving || descent_not_demanded) {
attitude_control->set_throttle_mix_max(pos_control->get_vel_z_control_ratio())
} else {
attitude_control->set_throttle_mix_min()
}
}
}
"
209,Arducopter\Log.cpp_Log_Write_Control_Tuning,"void Copter::Log_Write_Control_Tuning()
{
float terr_alt = 0.0f
if (!terrain.height_above_terrain(terr_alt, true)) {
terr_alt = logger.quiet_nan()
}
float des_alt_m = 0.0f
int16_t target_climb_rate_cms = 0
if (!flightmode->has_manual_throttle()) {
des_alt_m = pos_control->get_pos_target_z_cm() * 0.01f
target_climb_rate_cms = pos_control->get_vel_target_z_cms()
}

float desired_rangefinder_alt
if (!surface_tracking.get_target_dist_for_logging(desired_rangefinder_alt)) {
desired_rangefinder_alt = AP::logger().quiet_nan()
}

struct log_Control_Tuning pkt = {
LOG_PACKET_HEADER_INIT(LOG_CONTROL_TUNING_MSG),
time_us             : AP_HAL::micros64(),
throttle_in         : attitude_control->get_throttle_in(),
angle_boost         : attitude_control->angle_boost(),
throttle_out        : motors->get_throttle(),
throttle_hover      : motors->get_throttle_hover(),
desired_alt         : des_alt_m,
inav_alt            : inertial_nav.get_position_z_up_cm() * 0.01f,
baro_alt            : baro_alt,
desired_rangefinder_alt : desired_rangefinder_alt,
rangefinder_alt     : surface_tracking.get_dist_for_logging(),
terr_alt            : terr_alt,
target_climb_rate   : target_climb_rate_cms,
climb_rate          : int16_t(inertial_nav.get_velocity_z_up_cms()) // float -> int16_t
}
logger.WriteBlock(&pkt, sizeof(pkt))
}
"
210,Arducopter\Log.cpp_Log_Write_Attitude,"void Copter::Log_Write_Attitude()
{
Vector3f targets = attitude_control->get_att_target_euler_cd()
targets.z = wrap_360_cd(targets.z)
ahrs.Write_Attitude(targets)
ahrs_view->Write_Rate(*motors, *attitude_control, *pos_control)
}
"
211,Arducopter\Log.cpp_Log_Write_PIDS,"void Copter::Log_Write_PIDS()
{
if (should_log(MASK_LOG_PID)) {
logger.Write_PID(LOG_PIDR_MSG, attitude_control->get_rate_roll_pid().get_pid_info())
logger.Write_PID(LOG_PIDP_MSG, attitude_control->get_rate_pitch_pid().get_pid_info())
logger.Write_PID(LOG_PIDY_MSG, attitude_control->get_rate_yaw_pid().get_pid_info())
logger.Write_PID(LOG_PIDA_MSG, pos_control->get_accel_z_pid().get_pid_info() )
if (should_log(MASK_LOG_NTUN) && (flightmode->requires_GPS() || landing_with_GPS())) {
logger.Write_PID(LOG_PIDN_MSG, pos_control->get_vel_xy_pid().get_pid_info_x())
logger.Write_PID(LOG_PIDE_MSG, pos_control->get_vel_xy_pid().get_pid_info_y())
}
}
}
"
212,Arducopter\Log.cpp_Log_Write_EKF_POS,"void Copter::Log_Write_EKF_POS()
{
AP::ahrs().Log_Write()
}
"
213,Arducopter\Log.cpp_Log_Write_Data,"void Copter::Log_Write_Data(LogDataID id, int16_t value)
{
if (should_log(MASK_LOG_ANY)) {
struct log_Data_Int16t pkt = {
LOG_PACKET_HEADER_INIT(LOG_DATA_INT16_MSG),
time_us     : AP_HAL::micros64(),
id          : (uint8_t)id,
data_value  : value
}
logger.WriteCriticalBlock(&pkt, sizeof(pkt))
}
}
"
214,Arducopter\Log.cpp_Log_Write_Data,"void Copter::Log_Write_Data(LogDataID id, uint16_t value)
{
if (should_log(MASK_LOG_ANY)) {
struct log_Data_UInt16t pkt = {
LOG_PACKET_HEADER_INIT(LOG_DATA_UINT16_MSG),
time_us     : AP_HAL::micros64(),
id          : (uint8_t)id,
data_value  : value
}
logger.WriteCriticalBlock(&pkt, sizeof(pkt))
}
}
"
215,Arducopter\Log.cpp_Log_Write_Data,"void Copter::Log_Write_Data(LogDataID id, int32_t value)
{
if (should_log(MASK_LOG_ANY)) {
struct log_Data_Int32t pkt = {
LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),
time_us  : AP_HAL::micros64(),
id          : (uint8_t)id,
data_value  : value
}
logger.WriteCriticalBlock(&pkt, sizeof(pkt))
}
}
"
216,Arducopter\Log.cpp_Log_Write_Data,"void Copter::Log_Write_Data(LogDataID id, uint32_t value)
{
if (should_log(MASK_LOG_ANY)) {
struct log_Data_UInt32t pkt = {
LOG_PACKET_HEADER_INIT(LOG_DATA_UINT32_MSG),
time_us     : AP_HAL::micros64(),
id          : (uint8_t)id,
data_value  : value
}
logger.WriteCriticalBlock(&pkt, sizeof(pkt))
}
}
"
217,Arducopter\Log.cpp_Log_Write_Data,"void Copter::Log_Write_Data(LogDataID id, float value)
{
if (should_log(MASK_LOG_ANY)) {
struct log_Data_Float pkt = {
LOG_PACKET_HEADER_INIT(LOG_DATA_FLOAT_MSG),
time_us     : AP_HAL::micros64(),
id          : (uint8_t)id,
data_value  : value
}
logger.WriteCriticalBlock(&pkt, sizeof(pkt))
}
}
"
218,Arducopter\Log.cpp_Log_Write_Parameter_Tuning,"void Copter::Log_Write_Parameter_Tuning(uint8_t param, float tuning_val, float tune_min, float tune_max)
{
struct log_ParameterTuning pkt_tune = {
LOG_PACKET_HEADER_INIT(LOG_PARAMTUNE_MSG),
time_us        : AP_HAL::micros64(),
parameter      : param,
tuning_value   : tuning_val,
tuning_min     : tune_min,
tuning_max     : tune_max
}

logger.WriteBlock(&pkt_tune, sizeof(pkt_tune))
}
"
219,Arducopter\Log.cpp_Log_Video_Stabilisation,"void Copter::Log_Video_Stabilisation()
{
if (!should_log(MASK_LOG_VIDEO_STABILISATION)) {
return
}
ahrs.write_video_stabilisation()
}
"
220,Arducopter\Log.cpp_Log_Write_SysID_Data,"void Copter::Log_Write_SysID_Data(float waveform_time, float waveform_sample, float waveform_freq, float angle_x, float angle_y, float angle_z, float accel_x, float accel_y, float accel_z)
{
struct log_SysIdD pkt_sidd = {
LOG_PACKET_HEADER_INIT(LOG_SYSIDD_MSG),
time_us         : AP_HAL::micros64(),
waveform_time   : waveform_time,
waveform_sample : waveform_sample,
waveform_freq   : waveform_freq,
angle_x         : angle_x,
angle_y         : angle_y,
angle_z         : angle_z,
accel_x         : accel_x,
accel_y         : accel_y,
accel_z         : accel_z
}
logger.WriteBlock(&pkt_sidd, sizeof(pkt_sidd))
}
"
221,Arducopter\Log.cpp_Log_Write_SysID_Setup,"void Copter::Log_Write_SysID_Setup(uint8_t systemID_axis, float waveform_magnitude, float frequency_start, float frequency_stop, float time_fade_in, float time_const_freq, float time_record, float time_fade_out)
{
struct log_SysIdS pkt_sids = {
LOG_PACKET_HEADER_INIT(LOG_SYSIDS_MSG),
time_us             : AP_HAL::micros64(),
systemID_axis       : systemID_axis,
waveform_magnitude  : waveform_magnitude,
frequency_start     : frequency_start,
frequency_stop      : frequency_stop,
time_fade_in        : time_fade_in,
time_const_freq     : time_const_freq,
time_record         : time_record,
time_fade_out       : time_fade_out
}
logger.WriteBlock(&pkt_sids, sizeof(pkt_sids))
}
"
222,Arducopter\Log.cpp_Log_Write_Heli,"void Copter::Log_Write_Heli()
{
struct log_Heli pkt_heli = {
LOG_PACKET_HEADER_INIT(LOG_HELI_MSG),
time_us                 : AP_HAL::micros64(),
desired_rotor_speed     : motors->get_desired_rotor_speed(),
main_rotor_speed        : motors->get_main_rotor_speed(),
governor_output         : motors->get_governor_output(),
control_output          : motors->get_control_output(),
}
logger.WriteBlock(&pkt_heli, sizeof(pkt_heli))
}
"
223,Arducopter\Log.cpp_Log_Write_Guided_Position_Target,"void Copter::Log_Write_Guided_Position_Target(ModeGuided::SubMode target_type, const Vector3f& pos_target, bool terrain_alt, const Vector3f& vel_target, const Vector3f& accel_target)
{
const log_Guided_Position_Target pkt {
LOG_PACKET_HEADER_INIT(LOG_GUIDED_POSITION_TARGET_MSG),
time_us         : AP_HAL::micros64(),
type            : (uint8_t)target_type,
pos_target_x    : pos_target.x,
pos_target_y    : pos_target.y,
pos_target_z    : pos_target.z,
terrain         : terrain_alt,
vel_target_x    : vel_target.x,
vel_target_y    : vel_target.y,
vel_target_z    : vel_target.z,
accel_target_x  : accel_target.x,
accel_target_y  : accel_target.y,
accel_target_z  : accel_target.z
}
logger.WriteBlock(&pkt, sizeof(pkt))
}
"
224,Arducopter\Log.cpp_Log_Write_Guided_Attitude_Target,"void Copter::Log_Write_Guided_Attitude_Target(ModeGuided::SubMode target_type, float roll, float pitch, float yaw, const Vector3f &ang_vel, float thrust, float climb_rate)
{
const log_Guided_Attitude_Target pkt {
LOG_PACKET_HEADER_INIT(LOG_GUIDED_ATTITUDE_TARGET_MSG),
time_us         : AP_HAL::micros64(),
type            : (uint8_t)target_type,
roll            : degrees(roll),       // rad to deg
pitch           : degrees(pitch),      // rad to deg
yaw             : degrees(yaw),        // rad to deg
roll_rate       : degrees(ang_vel.x),  // rad/s to deg/s
pitch_rate      : degrees(ang_vel.y),  // rad/s to deg/s
yaw_rate        : degrees(ang_vel.z),  // rad/s to deg/s
thrust          : thrust,
climb_rate      : climb_rate
}
logger.WriteBlock(&pkt, sizeof(pkt))
}
"
225,Arducopter\Log.cpp_Log_Write_Vehicle_Startup_Messages,"void Copter::Log_Write_Vehicle_Startup_Messages()
{
char frame_and_type_string[30]
copter.motors->get_frame_and_type_string(frame_and_type_string, ARRAY_SIZE(frame_and_type_string))
logger.Write_MessageF(""%s"", frame_and_type_string)
logger.Write_Mode((uint8_t)flightmode->mode_number(), control_mode_reason)
ahrs.Log_Write_Home_And_Origin()
gps.Write_AP_Logger_Log_Startup_messages()
}
"
226,Arducopter\Log.cpp_log_init,"void Copter::log_init(void)
{
logger.Init(log_structure, ARRAY_SIZE(log_structure))
}
"
227,Arducopter\Log.cpp_Log_Write_Control_Tuning,"void Copter::Log_Write_Control_Tuning() {}
"
228,Arducopter\Log.cpp_Log_Write_Attitude,"void Copter::Log_Write_Attitude(void) {}
"
229,Arducopter\Log.cpp_Log_Write_EKF_POS,"void Copter::Log_Write_EKF_POS() {}
"
230,Arducopter\Log.cpp_Log_Write_Data,"void Copter::Log_Write_Data(LogDataID id, int32_t value) {}
"
231,Arducopter\Log.cpp_Log_Write_Data,"void Copter::Log_Write_Data(LogDataID id, uint32_t value) {}
"
232,Arducopter\Log.cpp_Log_Write_Data,"void Copter::Log_Write_Data(LogDataID id, int16_t value) {}
"
233,Arducopter\Log.cpp_Log_Write_Data,"void Copter::Log_Write_Data(LogDataID id, uint16_t value) {}
"
234,Arducopter\Log.cpp_Log_Write_Data,"void Copter::Log_Write_Data(LogDataID id, float value) {}
"
235,Arducopter\Log.cpp_Log_Write_Parameter_Tuning,"void Copter::Log_Write_Parameter_Tuning(uint8_t param, float tuning_val, float tune_min, float tune_max) {}
"
236,Arducopter\Log.cpp_Log_Write_Guided_Position_Target,"void Copter::Log_Write_Guided_Position_Target(ModeGuided::SubMode target_type, const Vector3f& pos_target, bool terrain_alt, const Vector3f& vel_target, const Vector3f& accel_target) {}
"
237,Arducopter\Log.cpp_Log_Write_Guided_Attitude_Target,"void Copter::Log_Write_Guided_Attitude_Target(ModeGuided::SubMode target_type, float roll, float pitch, float yaw, const Vector3f &ang_vel, float thrust, float climb_rate) {}
"
238,Arducopter\Log.cpp_Log_Write_SysID_Setup,"void Copter::Log_Write_SysID_Setup(uint8_t systemID_axis, float waveform_magnitude, float frequency_start, float frequency_stop, float time_fade_in, float time_const_freq, float time_record, float time_fade_out) {}
"
239,Arducopter\Log.cpp_Log_Write_SysID_Data,"void Copter::Log_Write_SysID_Data(float waveform_time, float waveform_sample, float waveform_freq, float angle_x, float angle_y, float angle_z, float accel_x, float accel_y, float accel_z) {}
"
240,Arducopter\Log.cpp_Log_Write_Vehicle_Startup_Messages,"void Copter::Log_Write_Vehicle_Startup_Messages() {}
"
241,Arducopter\Log.cpp_Log_Write_Heli,"void Copter::Log_Write_Heli() {}
"
242,Arducopter\Log.cpp_log_init,"void Copter::log_init(void) {}
"
243,Arducopter\mode.cpp_Mode,"Mode::Mode(void) :
g(copter.g),
g2(copter.g2),
wp_nav(copter.wp_nav),
loiter_nav(copter.loiter_nav),
pos_control(copter.pos_control),
inertial_nav(copter.inertial_nav),
ahrs(copter.ahrs),
attitude_control(copter.attitude_control),
motors(copter.motors),
channel_roll(copter.channel_roll),
channel_pitch(copter.channel_pitch),
channel_throttle(copter.channel_throttle),
channel_yaw(copter.channel_yaw),
G_Dt(copter.G_Dt)
{ }
"
244,Arducopter\mode.cpp_mode_from_mode_num,"Mode *Copter::mode_from_mode_num(const Mode::Number mode)
{
Mode *ret = nullptr

switch (mode) {
case Mode::Number::ACRO:
ret = &mode_acro
break

case Mode::Number::STABILIZE:
ret = &mode_stabilize
break

case Mode::Number::ALT_HOLD:
ret = &mode_althold
break

case Mode::Number::AUTO:
ret = &mode_auto
break

case Mode::Number::CIRCLE:
ret = &mode_circle
break

case Mode::Number::LOITER:
ret = &mode_loiter
break

case Mode::Number::GUIDED:
ret = &mode_guided
break

case Mode::Number::LAND:
ret = &mode_land
break

case Mode::Number::RTL:
ret = &mode_rtl
break

case Mode::Number::DRIFT:
ret = &mode_drift
break

case Mode::Number::SPORT:
ret = &mode_sport
break

case Mode::Number::FLIP:
ret = &mode_flip
break

case Mode::Number::AUTOTUNE:
ret = &mode_autotune
break

case Mode::Number::POSHOLD:
ret = &mode_poshold
break

case Mode::Number::BRAKE:
ret = &mode_brake
break

case Mode::Number::THROW:
ret = &mode_throw
break

case Mode::Number::AVOID_ADSB:
ret = &mode_avoid_adsb
break

case Mode::Number::GUIDED_NOGPS:
ret = &mode_guided_nogps
break

case Mode::Number::SMART_RTL:
ret = &mode_smartrtl
break

case Mode::Number::FLOWHOLD:
ret = (Mode *)g2.mode_flowhold_ptr
break

case Mode::Number::FOLLOW:
ret = &mode_follow
break

case Mode::Number::ZIGZAG:
ret = &mode_zigzag
break

case Mode::Number::SYSTEMID:
ret = (Mode *)g2.mode_systemid_ptr
break

case Mode::Number::AUTOROTATE:
ret = &mode_autorotate
break

case Mode::Number::TURTLE:
ret = &mode_turtle
break

default:
break
}

return ret
}
"
245,Arducopter\mode.cpp_mode_change_failed,"void Copter::mode_change_failed(const Mode *mode, const char *reason)
{
gcs().send_text(MAV_SEVERITY_WARNING, ""Mode change to %s failed: %s"", mode->name(), reason)
AP::logger().Write_Error(LogErrorSubsystem::FLIGHT_MODE, LogErrorCode(mode->mode_number()))
if (copter.ap.initialised) {
AP_Notify::events.user_mode_change_failed = 1
}
}
"
246,Arducopter\mode.cpp_set_mode,"bool Copter::set_mode(Mode::Number mode, ModeReason reason)
{
const ModeReason last_reason = _last_reason
_last_reason = reason

if (mode == flightmode->mode_number()) {
control_mode_reason = reason
if (reason == ModeReason::INITIALISED && mode == Mode::Number::STABILIZE) {
attitude_control->set_yaw_rate_tc(g2.command_model_pilot.get_rate_tc())
}
if (copter.ap.initialised && (reason != last_reason)) {
AP_Notify::events.user_mode_change = 1
}
return true
}

if (mode == Mode::Number::AUTO_RTL) {
return mode_auto.jump_to_landing_sequence_auto_RTL(reason)
}

Mode *new_flightmode = mode_from_mode_num(mode)
if (new_flightmode == nullptr) {
notify_no_such_mode((uint8_t)mode)
return false
}

bool ignore_checks = !motors->armed()

if (!ignore_checks && !new_flightmode->has_manual_throttle() &&
(motors->get_spool_state() == AP_Motors::SpoolState::SPOOLING_UP || motors->get_spool_state() == AP_Motors::SpoolState::SPOOLING_DOWN)) {
bool in_autorotation_check = (flightmode != &mode_autorotate || new_flightmode != &mode_autorotate)
bool in_autorotation_check = false

if (!in_autorotation_check) {
mode_change_failed(new_flightmode, ""runup not complete"")
return false
}
}

bool user_throttle = new_flightmode->has_manual_throttle()
if (new_flightmode == &mode_drift) {
user_throttle = true
}
if (!ignore_checks &&
ap.land_complete &&
user_throttle &&
!copter.flightmode->has_manual_throttle() &&
new_flightmode->get_pilot_desired_throttle() > copter.get_non_takeoff_throttle()) {
mode_change_failed(new_flightmode, ""throttle too high"")
return false
}

if (!ignore_checks &&
new_flightmode->requires_GPS() &&
!copter.position_ok()) {
mode_change_failed(new_flightmode, ""requires position"")
return false
}

if (!ignore_checks &&
!copter.ekf_alt_ok() &&
flightmode->has_manual_throttle() &&
!new_flightmode->has_manual_throttle()) {
mode_change_failed(new_flightmode, ""need alt estimate"")
return false
}

if (!new_flightmode->init(ignore_checks)) {
mode_change_failed(new_flightmode, ""init failed"")
return false
}

exit_mode(flightmode, new_flightmode)

prev_control_mode = flightmode->mode_number()

flightmode = new_flightmode
control_mode_reason = reason
logger.Write_Mode((uint8_t)flightmode->mode_number(), reason)
gcs().send_message(MSG_HEARTBEAT)

adsb.set_is_auto_mode((mode == Mode::Number::AUTO) || (mode == Mode::Number::RTL) || (mode == Mode::Number::GUIDED))

fence.manual_recovery_start()

camera.set_is_auto_mode(flightmode->mode_number() == Mode::Number::AUTO)

attitude_control->set_roll_pitch_rate_tc(g2.command_model_acro_rp.get_rate_tc())
attitude_control->set_yaw_rate_tc(g2.command_model_pilot.get_rate_tc())
if (mode== Mode::Number::ACRO || mode== Mode::Number::DRIFT) {
attitude_control->set_yaw_rate_tc(g2.command_model_acro_y.get_rate_tc())
}

notify_flight_mode()

if (copter.ap.initialised) {
AP_Notify::events.user_mode_change = 1
}

return true
}
"
247,Arducopter\mode.cpp_set_mode,"bool Copter::set_mode(const uint8_t new_mode, const ModeReason reason)
{
static_assert(sizeof(Mode::Number) == sizeof(new_mode), ""The new mode can't be mapped to the vehicles mode number"")
if (reason == ModeReason::GCS_COMMAND && copter.failsafe.radio) {
return false
}
return copter.set_mode(static_cast<Mode::Number>(new_mode), reason)
}
"
248,Arducopter\mode.cpp_update_flight_mode,"void Copter::update_flight_mode()
{
surface_tracking.invalidate_for_logging()

flightmode->run()
}
"
249,Arducopter\mode.cpp_exit_mode,"void Copter::exit_mode(Mode *&old_flightmode,
Mode *&new_flightmode)
{
if (old_flightmode->has_manual_throttle() && !new_flightmode->has_manual_throttle() && motors->armed() && !ap.land_complete) {
set_accel_throttle_I_from_pilot_throttle()
}

old_flightmode->takeoff_stop()

old_flightmode->exit()

if (old_flightmode == &mode_acro) {
attitude_control->use_flybar_passthrough(false, false)
motors->set_acro_tail(false)
}

if (!old_flightmode->has_manual_throttle()){
if (new_flightmode == &mode_stabilize){
input_manager.set_stab_col_ramp(1.0)
} else if (new_flightmode == &mode_acro){
input_manager.set_stab_col_ramp(0.0)
}
}
}
"
250,Arducopter\mode.cpp_notify_flight_mode,"void Copter::notify_flight_mode() {
AP_Notify::flags.autopilot_mode = flightmode->is_autopilot()
AP_Notify::flags.flight_mode = (uint8_t)flightmode->mode_number()
notify.set_flight_mode_str(flightmode->name4())
}
"
251,Arducopter\mode.cpp_get_pilot_desired_lean_angles,"void Mode::get_pilot_desired_lean_angles(float &roll_out_cd, float &pitch_out_cd, float angle_max_cd, float angle_limit_cd) const
{
if (copter.failsafe.radio || !copter.ap.rc_receiver_present) {
roll_out_cd = 0.0
pitch_out_cd = 0.0
return
}

float roll_out_deg
float pitch_out_deg
rc_input_to_roll_pitch(channel_roll->get_control_in()*(1.0/ROLL_PITCH_YAW_INPUT_MAX), channel_pitch->get_control_in()*(1.0/ROLL_PITCH_YAW_INPUT_MAX), angle_max_cd * 0.01,  angle_limit_cd * 0.01, roll_out_deg, pitch_out_deg)

roll_out_cd = roll_out_deg * 100.0
pitch_out_cd = pitch_out_deg * 100.0
}
"
252,Arducopter\mode.cpp_get_pilot_desired_velocity,"Vector2f Mode::get_pilot_desired_velocity(float vel_max) const
{
Vector2f vel

if (copter.failsafe.radio || !copter.ap.rc_receiver_present) {
return vel
}
float roll_out = channel_roll->get_control_in()
float pitch_out = channel_pitch->get_control_in()

float scaler = 1.0 / (float)ROLL_PITCH_YAW_INPUT_MAX
roll_out *= scaler
pitch_out *= scaler

vel = Vector2f(-pitch_out, roll_out)
if (vel.is_zero()) {
return vel
}
copter.rotate_body_frame_to_NE(vel.x, vel.y)

Vector2f vel_scaler = vel / MAX(fabsf(vel.x), fabsf(vel.y))
vel *= vel_max / vel_scaler.length()
return vel
}
"
253,Arducopter\mode.cpp_triggered,"bool Mode::_TakeOff::triggered(const float target_climb_rate) const
{
if (!copter.ap.land_complete) {
return false
}
if (target_climb_rate <= 0.0f) {
return false
}

if (copter.motors->get_spool_state() != AP_Motors::SpoolState::THROTTLE_UNLIMITED) {
return false
}

return true
}
"
254,Arducopter\mode.cpp_is_disarmed_or_landed,"bool Mode::is_disarmed_or_landed() const
{
if (!motors->armed() || !copter.ap.auto_armed || copter.ap.land_complete) {
return true
}
return false
}
"
255,Arducopter\mode.cpp_zero_throttle_and_relax_ac,"void Mode::zero_throttle_and_relax_ac(bool spool_up)
{
if (spool_up) {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)
} else {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE)
}
attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0.0f, 0.0f, 0.0f)
attitude_control->set_throttle_out(0.0f, false, copter.g.throttle_filt)
}
"
256,Arducopter\mode.cpp_zero_throttle_and_hold_attitude,"void Mode::zero_throttle_and_hold_attitude()
{
attitude_control->input_rate_bf_roll_pitch_yaw(0.0f, 0.0f, 0.0f)
attitude_control->set_throttle_out(0.0f, false, copter.g.throttle_filt)
}
"
257,Arducopter\mode.cpp_make_safe_ground_handling,"void Mode::make_safe_ground_handling(bool force_throttle_unlimited)
{
if (force_throttle_unlimited) {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)
} else {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE)
}

attitude_control->reset_rate_controller_I_terms_smoothly()

switch (motors->get_spool_state()) {
case AP_Motors::SpoolState::SHUT_DOWN:
case AP_Motors::SpoolState::GROUND_IDLE:
attitude_control->reset_yaw_target_and_rate()
break
case AP_Motors::SpoolState::SPOOLING_UP:
case AP_Motors::SpoolState::THROTTLE_UNLIMITED:
case AP_Motors::SpoolState::SPOOLING_DOWN:
break
}

pos_control->relax_velocity_controller_xy()
pos_control->update_xy_controller()
pos_control->relax_z_controller(0.0f)
pos_control->update_z_controller()
attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0.0f, 0.0f, 0.0f)
}
"
258,Arducopter\mode.cpp_get_alt_above_ground_cm,"int32_t Mode::get_alt_above_ground_cm(void)
{
int32_t alt_above_ground_cm
if (copter.get_rangefinder_height_interpolated_cm(alt_above_ground_cm)) {
return alt_above_ground_cm
}
if (!pos_control->is_active_xy()) {
return copter.current_loc.alt
}
if (copter.current_loc.get_alt_cm(Location::AltFrame::ABOVE_TERRAIN, alt_above_ground_cm)) {
return alt_above_ground_cm
}

return copter.current_loc.alt
}
"
259,Arducopter\mode.cpp_land_run_vertical_control,"void Mode::land_run_vertical_control(bool pause_descent)
{
float cmb_rate = 0
bool ignore_descent_limit = false
if (!pause_descent) {

ignore_descent_limit = (MAX(g2.land_alt_low,100) > get_alt_above_ground_cm()) || copter.ap.land_complete_maybe

float max_land_descent_velocity
if (g.land_speed_high > 0) {
max_land_descent_velocity = -g.land_speed_high
} else {
max_land_descent_velocity = pos_control->get_max_speed_down_cms()
}

max_land_descent_velocity = MIN(max_land_descent_velocity, -abs(g.land_speed))

cmb_rate = sqrt_controller(MAX(g2.land_alt_low,100)-get_alt_above_ground_cm(), pos_control->get_pos_z_p().kP(), pos_control->get_max_accel_z_cmss(), G_Dt)

cmb_rate = constrain_float(cmb_rate, max_land_descent_velocity, -abs(g.land_speed))

const bool navigating = pos_control->is_active_xy()
bool doing_precision_landing = !copter.ap.land_repo_active && copter.precland.target_acquired() && navigating

if (doing_precision_landing) {
Vector2f target_pos
float target_error_cm = 0.0f
if (copter.precland.get_target_position_cm(target_pos)) {
const Vector2f current_pos = inertial_nav.get_position_xy_cm()
target_error_cm = (target_pos - current_pos).length()
}
const float max_horiz_pos_error_cm = copter.precland.get_max_xy_error_before_descending_cm()
Vector3f target_pos_meas
copter.precland.get_target_position_measurement_cm(target_pos_meas)
if (target_error_cm > max_horiz_pos_error_cm && !is_zero(max_horiz_pos_error_cm)) {
cmb_rate = 0.0f
} else if (target_pos_meas.z > 35.0f && target_pos_meas.z < 200.0f) {
const float precland_acceptable_error_cm = 15.0f
const float precland_min_descent_speed_cms = 10.0f
const float max_descent_speed_cms = abs(g.land_speed)*0.5f
const float land_slowdown = MAX(0.0f, target_error_cm*(max_descent_speed_cms/precland_acceptable_error_cm))
cmb_rate = MIN(-precland_min_descent_speed_cms, -max_descent_speed_cms+land_slowdown)
}
}
}

pos_control->land_at_climb_rate_cm(cmb_rate, ignore_descent_limit)
pos_control->update_z_controller()
}
"
260,Arducopter\mode.cpp_land_run_horizontal_control,"void Mode::land_run_horizontal_control()
{
Vector2f vel_correction
float target_yaw_rate = 0

if (copter.ap.land_complete_maybe) {
pos_control->soften_for_landing_xy()
}

if (!copter.failsafe.radio) {
if ((g.throttle_behavior & THR_BEHAVE_HIGH_THROTTLE_CANCELS_LAND) != 0 && copter.rc_throttle_control_in_filter.get() > LAND_CANCEL_TRIGGER_THR){
AP::logger().Write_Event(LogEvent::LAND_CANCELLED_BY_PILOT)
if (!set_mode(Mode::Number::LOITER, ModeReason::THROTTLE_LAND_ESCAPE)) {
set_mode(Mode::Number::ALT_HOLD, ModeReason::THROTTLE_LAND_ESCAPE)
}
}

if (g.land_repositioning) {
update_simple_mode()

const float max_pilot_vel = wp_nav->get_wp_acceleration() * 0.5
vel_correction = get_pilot_desired_velocity(max_pilot_vel)

if (!vel_correction.is_zero()) {
if (!copter.ap.land_repo_active) {
AP::logger().Write_Event(LogEvent::LAND_REPO_ACTIVE)
}
copter.ap.land_repo_active = true
}
}

target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
if (!is_zero(target_yaw_rate)) {
auto_yaw.set_mode(AUTO_YAW_HOLD)
}
}

copter.ap.prec_land_active = false
copter.ap.prec_land_active = !copter.ap.land_repo_active && copter.precland.target_acquired()
if (copter.ap.prec_land_active) {
Vector2f target_pos, target_vel
if (!copter.precland.get_target_position_cm(target_pos)) {
target_pos = inertial_nav.get_position_xy_cm()
}
copter.precland.get_target_velocity_cms(inertial_nav.get_velocity_xy_cms(), target_vel)

Vector2f zero
Vector2p landing_pos = target_pos.topostype()
pos_control->input_pos_vel_accel_xy(landing_pos, target_vel, zero)
}

if (!copter.ap.prec_land_active) {
Vector2f accel
pos_control->input_vel_accel_xy(vel_correction, accel)
}

pos_control->update_xy_controller()
Vector3f thrust_vector = pos_control->get_thrust_vector()

if (g2.wp_navalt_min > 0) {
const float attitude_limit_cd = linear_interpolate(700, copter.aparm.angle_max, get_alt_above_ground_cm(),
g2.wp_navalt_min*100U, (g2.wp_navalt_min+1)*100U)
const float thrust_vector_max = sinf(radians(attitude_limit_cd * 0.01f)) * GRAVITY_MSS * 100.0f
const float thrust_vector_mag = thrust_vector.xy().length()
if (thrust_vector_mag > thrust_vector_max) {
float ratio = thrust_vector_max / thrust_vector_mag
thrust_vector.x *= ratio
thrust_vector.y *= ratio

pos_control->set_externally_limited_xy()
}
}

if (auto_yaw.mode() == AUTO_YAW_HOLD) {
attitude_control->input_thrust_vector_rate_heading(thrust_vector, target_yaw_rate)
} else {
attitude_control->input_thrust_vector_heading(thrust_vector, auto_yaw.yaw())
}
}
"
261,Arducopter\mode.cpp_land_run_normal_or_precland,"void Mode::land_run_normal_or_precland(bool pause_descent)
{
if (pause_descent || !copter.precland.enabled()) {
land_run_horiz_and_vert_control(pause_descent)
} else {
precland_run()
}
land_run_horiz_and_vert_control(pause_descent)
}
"
262,Arducopter\mode.cpp_precland_retry_position,"void Mode::precland_retry_position(const Vector3f &retry_pos)
{
float target_yaw_rate = 0
if (!copter.failsafe.radio) {
if ((g.throttle_behavior & THR_BEHAVE_HIGH_THROTTLE_CANCELS_LAND) != 0 && copter.rc_throttle_control_in_filter.get() > LAND_CANCEL_TRIGGER_THR){
AP::logger().Write_Event(LogEvent::LAND_CANCELLED_BY_PILOT)
if (!set_mode(Mode::Number::LOITER, ModeReason::THROTTLE_LAND_ESCAPE)) {
set_mode(Mode::Number::ALT_HOLD, ModeReason::THROTTLE_LAND_ESCAPE)
}
}

if (g.land_repositioning) {
float target_roll = 0.0f
float target_pitch = 0.0f
get_pilot_desired_lean_angles(target_roll, target_pitch, loiter_nav->get_angle_max_cd(), attitude_control->get_althold_lean_angle_max_cd())

if (!is_zero(target_roll) || !is_zero(target_pitch)) {
if (!copter.ap.land_repo_active) {
AP::logger().Write_Event(LogEvent::LAND_REPO_ACTIVE)
}
copter.ap.land_repo_active = true
}
}

target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
if (!is_zero(target_yaw_rate)) {
auto_yaw.set_mode(AUTO_YAW_HOLD)
}
}

Vector3p retry_pos_NEU{retry_pos.x, retry_pos.y, retry_pos.z * -1.0f}
retry_pos_NEU = retry_pos_NEU * 100.0f
pos_control->input_pos_xyz(retry_pos_NEU, 0.0f, 1000.0f)

pos_control->update_xy_controller()
pos_control->update_z_controller()

const Vector3f thrust_vector{pos_control->get_thrust_vector()}

if (auto_yaw.mode() == AUTO_YAW_HOLD) {
attitude_control->input_thrust_vector_rate_heading(thrust_vector, target_yaw_rate)
} else {
attitude_control->input_thrust_vector_heading(thrust_vector, auto_yaw.yaw())
}
}
"
263,Arducopter\mode.cpp_precland_run,"void Mode::precland_run()
{
if (!copter.ap.land_repo_active) {
Vector3f retry_pos

switch (copter.precland_statemachine.update(retry_pos)) {
case AC_PrecLand_StateMachine::Status::RETRYING:
precland_retry_position(retry_pos)
break

case AC_PrecLand_StateMachine::Status::FAILSAFE: {
switch (copter.precland_statemachine.get_failsafe_actions()) {
case AC_PrecLand_StateMachine::FailSafeAction::DESCEND:
land_run_horiz_and_vert_control()
break
case AC_PrecLand_StateMachine::FailSafeAction::HOLD_POS:
land_run_horiz_and_vert_control(true)
break
}
break
}
case AC_PrecLand_StateMachine::Status::ERROR:
INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control)
FALLTHROUGH
case AC_PrecLand_StateMachine::Status::DESCEND:
land_run_horiz_and_vert_control()
break
}
} else {
land_run_horiz_and_vert_control()
}
}
"
264,Arducopter\mode.cpp_throttle_hover,"float Mode::throttle_hover() const
{
return motors->get_throttle_hover()
}
"
265,Arducopter\mode.cpp_get_pilot_desired_throttle,"float Mode::get_pilot_desired_throttle() const
{
const float thr_mid = throttle_hover()
int16_t throttle_control = channel_throttle->get_control_in()

int16_t mid_stick = copter.get_throttle_mid()
if (mid_stick <= 0) {
mid_stick = 500
}

throttle_control = constrain_int16(throttle_control,0,1000)

float throttle_in
if (throttle_control < mid_stick) {
throttle_in = ((float)throttle_control)*0.5f/(float)mid_stick
} else {
throttle_in = 0.5f + ((float)(throttle_control-mid_stick)) * 0.5f / (float)(1000-mid_stick)
}

const float expo = constrain_float(-(thr_mid-0.5f)/0.375f, -0.5f, 1.0f)
float throttle_out = throttle_in*(1.0f-expo) + expo*throttle_in*throttle_in*throttle_in
return throttle_out
}
"
266,Arducopter\mode.cpp_get_avoidance_adjusted_climbrate,"float Mode::get_avoidance_adjusted_climbrate(float target_rate)
{
AP::ac_avoid()->adjust_velocity_z(pos_control->get_pos_z_p().kP(), pos_control->get_max_accel_z_cmss(), target_rate, G_Dt)
return target_rate
return target_rate
}
"
267,Arducopter\mode.cpp_output_to_motors,"void Mode::output_to_motors()
{
motors->output()
}
"
268,Arducopter\mode.cpp_get_alt_hold_state,"Mode::AltHoldModeState Mode::get_alt_hold_state(float target_climb_rate_cms)
{
if (!motors->armed()) {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::SHUT_DOWN)

switch (motors->get_spool_state()) {

case AP_Motors::SpoolState::SHUT_DOWN:
return AltHold_MotorStopped

case AP_Motors::SpoolState::GROUND_IDLE:
return AltHold_Landed_Ground_Idle

default:
return AltHold_Landed_Pre_Takeoff
}

} else if (takeoff.running() || takeoff.triggered(target_climb_rate_cms)) {
return AltHold_Takeoff

} else if (!copter.ap.auto_armed || copter.ap.land_complete) {
if (target_climb_rate_cms < 0.0f && !copter.ap.using_interlock) {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE)

} else {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)
}

if (motors->get_spool_state() == AP_Motors::SpoolState::GROUND_IDLE) {
return AltHold_Landed_Ground_Idle

} else {
return AltHold_Landed_Pre_Takeoff
}

} else {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)
return AltHold_Flying
}
}
"
269,Arducopter\mode.cpp_get_pilot_desired_yaw_rate,"float Mode::get_pilot_desired_yaw_rate(float yaw_in)
{
if (copter.failsafe.radio || !copter.ap.rc_receiver_present) {
return 0.0f
}

return g2.command_model_pilot.get_rate() * 100.0 * input_expo(yaw_in, g2.command_model_pilot.get_expo())
}
"
270,Arducopter\mode.cpp_get_pilot_desired_climb_rate,"float Mode::get_pilot_desired_climb_rate(float throttle_control)
{
return copter.get_pilot_desired_climb_rate(throttle_control)
}
"
271,Arducopter\mode.cpp_get_non_takeoff_throttle,"float Mode::get_non_takeoff_throttle()
{
return copter.get_non_takeoff_throttle()
}
"
272,Arducopter\mode.cpp_update_simple_mode,"void Mode::update_simple_mode(void) {
copter.update_simple_mode()
}
"
273,Arducopter\mode.cpp_set_mode,"bool Mode::set_mode(Mode::Number mode, ModeReason reason)
{
return copter.set_mode(mode, reason)
}
"
274,Arducopter\mode.cpp_set_land_complete,"void Mode::set_land_complete(bool b)
{
return copter.set_land_complete(b)
}
"
275,Arducopter\mode.cpp_gcs,"GCS_Copter &Mode::gcs()
{
return copter.gcs()
}
"
276,Arducopter\mode.cpp_get_pilot_speed_dn,"uint16_t Mode::get_pilot_speed_dn()
{
return copter.get_pilot_speed_dn()
}
"
277,Arducopter\mode_acro.cpp_run,"void ModeAcro::run()
{
float target_roll, target_pitch, target_yaw
get_pilot_desired_angle_rates(channel_roll->norm_input_dz(), channel_pitch->norm_input_dz(), channel_yaw->norm_input_dz(), target_roll, target_pitch, target_yaw)

if (!motors->armed()) {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::SHUT_DOWN)
} else if (copter.ap.throttle_zero
|| (copter.air_mode == AirMode::AIRMODE_ENABLED && motors->get_spool_state() == AP_Motors::SpoolState::SHUT_DOWN)) {

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE)
} else {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)
}

float pilot_desired_throttle = get_pilot_desired_throttle()

switch (motors->get_spool_state()) {
case AP_Motors::SpoolState::SHUT_DOWN:
attitude_control->reset_target_and_rate(true)
attitude_control->reset_rate_controller_I_terms()
pilot_desired_throttle = 0.0f
break

case AP_Motors::SpoolState::GROUND_IDLE:
attitude_control->reset_target_and_rate()
attitude_control->reset_rate_controller_I_terms_smoothly()
pilot_desired_throttle = 0.0f
break

case AP_Motors::SpoolState::THROTTLE_UNLIMITED:
if (!motors->limit.throttle_lower) {
set_land_complete(false)
}
break

case AP_Motors::SpoolState::SPOOLING_UP:
case AP_Motors::SpoolState::SPOOLING_DOWN:
break
}

if (g2.acro_options.get() & uint8_t(AcroOptions::RATE_LOOP_ONLY)) {
attitude_control->input_rate_bf_roll_pitch_yaw_2(target_roll, target_pitch, target_yaw)
} else {
attitude_control->input_rate_bf_roll_pitch_yaw(target_roll, target_pitch, target_yaw)
}

attitude_control->set_throttle_out(pilot_desired_throttle, false, copter.g.throttle_filt)
}
"
278,Arducopter\mode_acro.cpp_init,"bool ModeAcro::init(bool ignore_checks)
{
if (g2.acro_options.get() & uint8_t(AcroOptions::AIR_MODE)) {
disable_air_mode_reset = false
copter.air_mode = AirMode::AIRMODE_ENABLED
}

return true
}
"
279,Arducopter\mode_acro.cpp_exit,"void ModeAcro::exit()
{
if (!disable_air_mode_reset && (g2.acro_options.get() & uint8_t(AcroOptions::AIR_MODE))) {
copter.air_mode = AirMode::AIRMODE_DISABLED
}
disable_air_mode_reset = false
}
"
280,Arducopter\mode_acro.cpp_air_mode_aux_changed,"void ModeAcro::air_mode_aux_changed()
{
disable_air_mode_reset = true
}
"
281,Arducopter\mode_acro.cpp_throttle_hover,"float ModeAcro::throttle_hover() const
{
if (g2.acro_thr_mid > 0) {
return g2.acro_thr_mid
}
return Mode::throttle_hover()
}
"
282,Arducopter\mode_acro.cpp_get_pilot_desired_angle_rates,"void ModeAcro::get_pilot_desired_angle_rates(float roll_in, float pitch_in, float yaw_in, float &roll_out, float &pitch_out, float &yaw_out)
{
float rate_limit
Vector3f rate_ef_level_cd, rate_bf_level_cd, rate_bf_request_cd

float total_in = norm(pitch_in, roll_in)

if (total_in > 1.0) {
float ratio = 1.0 / total_in
roll_in *= ratio
pitch_in *= ratio
}


rate_bf_request_cd.x = g2.command_model_acro_rp.get_rate() * 100.0 * input_expo(roll_in, g2.command_model_acro_rp.get_expo())

rate_bf_request_cd.y = g2.command_model_acro_rp.get_rate() * 100.0 * input_expo(pitch_in, g2.command_model_acro_rp.get_expo())

rate_bf_request_cd.z = g2.command_model_acro_y.get_rate() * 100.0 * input_expo(yaw_in, g2.command_model_acro_y.get_expo())


if (g.acro_trainer != (uint8_t)Trainer::OFF) {

const Vector3f att_target = attitude_control->get_att_target_euler_cd()

int32_t roll_angle = wrap_180_cd(att_target.x)
rate_ef_level_cd.x = -constrain_int32(roll_angle, -ACRO_LEVEL_MAX_ANGLE, ACRO_LEVEL_MAX_ANGLE) * g.acro_balance_roll

int32_t pitch_angle = wrap_180_cd(att_target.y)
rate_ef_level_cd.y = -constrain_int32(pitch_angle, -ACRO_LEVEL_MAX_ANGLE, ACRO_LEVEL_MAX_ANGLE) * g.acro_balance_pitch

rate_ef_level_cd.z = 0

if (g.acro_trainer == (uint8_t)Trainer::LIMITED) {
const float angle_max = copter.aparm.angle_max
if (roll_angle > angle_max){
rate_ef_level_cd.x += sqrt_controller(angle_max - roll_angle, g2.command_model_acro_rp.get_rate() * 100.0 / ACRO_LEVEL_MAX_OVERSHOOT, attitude_control->get_accel_roll_max_cdss(), G_Dt)
}else if (roll_angle < -angle_max) {
rate_ef_level_cd.x += sqrt_controller(-angle_max - roll_angle, g2.command_model_acro_rp.get_rate() * 100.0 / ACRO_LEVEL_MAX_OVERSHOOT, attitude_control->get_accel_roll_max_cdss(), G_Dt)
}

if (pitch_angle > angle_max){
rate_ef_level_cd.y += sqrt_controller(angle_max - pitch_angle, g2.command_model_acro_rp.get_rate() * 100.0 / ACRO_LEVEL_MAX_OVERSHOOT, attitude_control->get_accel_pitch_max_cdss(), G_Dt)
}else if (pitch_angle < -angle_max) {
rate_ef_level_cd.y += sqrt_controller(-angle_max - pitch_angle, g2.command_model_acro_rp.get_rate() * 100.0 / ACRO_LEVEL_MAX_OVERSHOOT, attitude_control->get_accel_pitch_max_cdss(), G_Dt)
}
}

attitude_control->euler_rate_to_ang_vel(attitude_control->get_att_target_euler_cd() * radians(0.01f), rate_ef_level_cd, rate_bf_level_cd)

if (g.acro_trainer == (uint8_t)Trainer::LIMITED) {
rate_bf_request_cd.x += rate_bf_level_cd.x
rate_bf_request_cd.y += rate_bf_level_cd.y
rate_bf_request_cd.z += rate_bf_level_cd.z
}else{
float acro_level_mix = constrain_float(1-float(MAX(MAX(abs(roll_in), abs(pitch_in)), abs(yaw_in))/4500.0), 0, 1)*ahrs.cos_pitch()

rate_bf_level_cd = rate_bf_level_cd * acro_level_mix

rate_limit = fabsf(fabsf(rate_bf_request_cd.x)-fabsf(rate_bf_level_cd.x))
rate_bf_request_cd.x += rate_bf_level_cd.x
rate_bf_request_cd.x = constrain_float(rate_bf_request_cd.x, -rate_limit, rate_limit)

rate_limit = fabsf(fabsf(rate_bf_request_cd.y)-fabsf(rate_bf_level_cd.y))
rate_bf_request_cd.y += rate_bf_level_cd.y
rate_bf_request_cd.y = constrain_float(rate_bf_request_cd.y, -rate_limit, rate_limit)

rate_limit = fabsf(fabsf(rate_bf_request_cd.z)-fabsf(rate_bf_level_cd.z))
rate_bf_request_cd.z += rate_bf_level_cd.z
rate_bf_request_cd.z = constrain_float(rate_bf_request_cd.z, -rate_limit, rate_limit)
}
}

roll_out = rate_bf_request_cd.x
pitch_out = rate_bf_request_cd.y
yaw_out = rate_bf_request_cd.z
}
"
283,Arducopter\mode_acro_heli.cpp_init,"bool ModeAcro_Heli::init(bool ignore_checks)
{
attitude_control->use_flybar_passthrough(motors->has_flybar(), motors->supports_yaw_passthrough())

motors->set_acro_tail(true)

copter.input_manager.set_use_stab_col(false)

return true
}
"
284,Arducopter\mode_acro_heli.cpp_run,"void ModeAcro_Heli::run()
{
float target_roll, target_pitch, target_yaw
float pilot_throttle_scaled


if (!motors->armed()) {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::SHUT_DOWN)
} else {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)
}

switch (motors->get_spool_state()) {
case AP_Motors::SpoolState::SHUT_DOWN:
attitude_control->reset_target_and_rate(false)
attitude_control->reset_rate_controller_I_terms()
break
case AP_Motors::SpoolState::GROUND_IDLE:
if ((motors->init_targets_on_arming() && motors->using_leaky_integrator()) || (copter.ap.land_complete && !motors->using_leaky_integrator())) {
attitude_control->reset_target_and_rate(false)
attitude_control->reset_rate_controller_I_terms_smoothly()
}
break
case AP_Motors::SpoolState::THROTTLE_UNLIMITED:
if (copter.ap.land_complete && !motors->using_leaky_integrator()) {
attitude_control->reset_rate_controller_I_terms_smoothly()
}
break
case AP_Motors::SpoolState::SPOOLING_UP:
case AP_Motors::SpoolState::SPOOLING_DOWN:
break
}

if (!motors->has_flybar()){
get_pilot_desired_angle_rates(channel_roll->norm_input_dz(), channel_pitch->norm_input_dz(), channel_yaw->norm_input_dz(), target_roll, target_pitch, target_yaw)
if ((Trainer)g.acro_trainer.get() == Trainer::OFF) {
if (copter.ap.land_complete) {
virtual_flybar(target_roll, target_pitch, target_yaw, 3.0f, 3.0f)
} else {
virtual_flybar(target_roll, target_pitch, target_yaw, g.acro_balance_pitch, g.acro_balance_roll)
}
}
if (motors->supports_yaw_passthrough()) {
target_yaw = channel_yaw->get_control_in_zero_dz()
}

if (g2.acro_options.get() & uint8_t(AcroOptions::RATE_LOOP_ONLY)) {
attitude_control->input_rate_bf_roll_pitch_yaw_2(target_roll, target_pitch, target_yaw)
} else {
attitude_control->input_rate_bf_roll_pitch_yaw(target_roll, target_pitch, target_yaw)
}
}else{
for fly-bar passthrough use control_in values with no
deadzone. This gives true pass-through.
float roll_in = channel_roll->get_control_in_zero_dz()
float pitch_in = channel_pitch->get_control_in_zero_dz()
float yaw_in

if (motors->supports_yaw_passthrough()) {
yaw_in = channel_yaw->get_control_in_zero_dz()
} else {
yaw_in = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
}

attitude_control->passthrough_bf_roll_pitch_rate_yaw(roll_in, pitch_in, yaw_in)
}

pilot_throttle_scaled = copter.input_manager.get_pilot_desired_collective(channel_throttle->get_control_in())

attitude_control->set_throttle_out(pilot_throttle_scaled, false, g.throttle_filt)
}
"
285,Arducopter\mode_acro_heli.cpp_virtual_flybar,"void ModeAcro_Heli::virtual_flybar( float &roll_out, float &pitch_out, float &yaw_out, float pitch_leak, float roll_leak)
{
Vector3f rate_ef_level, rate_bf_level

const Vector3f att_target = attitude_control->get_att_target_euler_cd()

rate_ef_level.x = -wrap_180_cd(att_target.x - ahrs.roll_sensor) * roll_leak

rate_ef_level.y = -wrap_180_cd(att_target.y - ahrs.pitch_sensor) * pitch_leak

rate_ef_level.z = 0

attitude_control->euler_rate_to_ang_vel(attitude_control->get_att_target_euler_cd()*radians(0.01f), rate_ef_level, rate_bf_level)

roll_out += rate_bf_level.x
pitch_out += rate_bf_level.y
yaw_out += rate_bf_level.z

}
"
286,Arducopter\mode_althold.cpp_init,"bool ModeAltHold::init(bool ignore_checks)
{

if (!pos_control->is_active_z()) {
pos_control->init_z_controller()
}

pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)
pos_control->set_correction_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)

return true
}
"
287,Arducopter\mode_althold.cpp_run,"void ModeAltHold::run()
{
pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)

update_simple_mode()

float target_roll, target_pitch
get_pilot_desired_lean_angles(target_roll, target_pitch, copter.aparm.angle_max, attitude_control->get_althold_lean_angle_max_cd())

float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())

float target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->get_control_in())
target_climb_rate = constrain_float(target_climb_rate, -get_pilot_speed_dn(), g.pilot_speed_up)

AltHoldModeState althold_state = get_alt_hold_state(target_climb_rate)

switch (althold_state) {

case AltHold_MotorStopped:
attitude_control->reset_rate_controller_I_terms()
attitude_control->reset_yaw_target_and_rate(false)
pos_control->relax_z_controller(0.0f)
break

case AltHold_Landed_Ground_Idle:
attitude_control->reset_yaw_target_and_rate()
FALLTHROUGH

case AltHold_Landed_Pre_Takeoff:
attitude_control->reset_rate_controller_I_terms_smoothly()
pos_control->relax_z_controller(0.0f)
break

case AltHold_Takeoff:
if (!takeoff.running()) {
takeoff.start(constrain_float(g.pilot_takeoff_alt,0.0f,1000.0f))
}

target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate)

takeoff.do_pilot_takeoff(target_climb_rate)
break

case AltHold_Flying:
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

copter.avoid.adjust_roll_pitch(target_roll, target_pitch, copter.aparm.angle_max)

target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate)

copter.surface_tracking.update_surface_offset()

pos_control->set_pos_target_z_from_climb_rate_cm(target_climb_rate)
break
}

attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate)

pos_control->update_z_controller()
}
"
288,Arducopter\mode_auto.cpp_init,"bool ModeAuto::init(bool ignore_checks)
{
auto_RTL = false
if (mission.num_commands() > 1 || ignore_checks) {
if (motors->armed() && copter.ap.land_complete && !mission.starts_with_takeoff_cmd()) {
gcs().send_text(MAV_SEVERITY_CRITICAL, ""Auto: Missing Takeoff Cmd"")
return false
}

_mode = SubMode::LOITER

if (auto_yaw.mode() == AUTO_YAW_ROI) {
auto_yaw.set_mode(AUTO_YAW_HOLD)
}

wp_nav->wp_and_spline_init()

waiting_to_start = true

IGNORE_RETURN(mis_change_detector.check_for_mission_change())

copter.mode_guided.limit_clear()

copter.ap.land_repo_active = false

copter.precland_statemachine.init()

return true
} else {
return false
}
}
"
289,Arducopter\mode_auto.cpp_exit,"void ModeAuto::exit()
{
if (copter.mode_auto.mission.state() == AP_Mission::MISSION_RUNNING) {
copter.mode_auto.mission.stop()
}
copter.camera_mount.set_mode_to_default()

auto_RTL = false
}
"
290,Arducopter\mode_auto.cpp_run,"void ModeAuto::run()
{
if (waiting_to_start) {
Location loc
if (copter.ahrs.get_origin(loc)) {
mission.start_or_resume()
waiting_to_start = false

IGNORE_RETURN(mis_change_detector.check_for_mission_change())
}
} else {
if (mis_change_detector.check_for_mission_change()) {
if ((mission.state() == AP_Mission::MISSION_RUNNING) && (_mode == SubMode::WP)) {
if (mission.restart_current_nav_cmd()) {
gcs().send_text(MAV_SEVERITY_CRITICAL, ""Auto mission changed, restarted command"")
} else {
gcs().send_text(MAV_SEVERITY_CRITICAL, ""Auto mission changed but failed to restart command"")
}
}
}

mission.update()
}

switch (_mode) {

case SubMode::TAKEOFF:
takeoff_run()
break

case SubMode::WP:
case SubMode::CIRCLE_MOVE_TO_EDGE:
wp_run()
break

case SubMode::LAND:
land_run()
break

case SubMode::RTL:
rtl_run()
break

case SubMode::CIRCLE:
circle_run()
break

case SubMode::NAVGUIDED:
case SubMode::NAV_SCRIPT_TIME:
nav_guided_run()
break

case SubMode::LOITER:
loiter_run()
break

case SubMode::LOITER_TO_ALT:
loiter_to_alt_run()
break

case SubMode::NAV_PAYLOAD_PLACE:
payload_place_run()
break

case SubMode::NAV_ATTITUDE_TIME:
nav_attitude_time_run()
break
}

if (auto_RTL && (!(mission.get_in_landing_sequence_flag() || mission.state() == AP_Mission::mission_state::MISSION_COMPLETE))) {
auto_RTL = false
copter.logger.Write_Mode((uint8_t)copter.flightmode->mode_number(), ModeReason::AUTO_RTL_EXIT)
}
}
"
291,Arducopter\mode_auto.cpp_requires_GPS,"bool ModeAuto::requires_GPS() const
{
return _mode != SubMode::NAV_ATTITUDE_TIME
}
"
292,Arducopter\mode_auto.cpp_set_submode,"void ModeAuto::set_submode(SubMode new_submode)
{
if (new_submode == _mode) {
return
}

SubMode old_submode = _mode

_mode = new_submode

if (old_submode == SubMode::NAV_ATTITUDE_TIME) {
copter.failsafe_ekf_recheck()
}
}
"
293,Arducopter\mode_auto.cpp_allows_arming,"bool ModeAuto::allows_arming(AP_Arming::Method method) const
{
return ((copter.g2.auto_options & (uint32_t)Options::AllowArming) != 0) && !auto_RTL
}
"
294,Arducopter\mode_auto.cpp_jump_to_landing_sequence_auto_RTL,"bool ModeAuto::jump_to_landing_sequence_auto_RTL(ModeReason reason)
{
if (mission.jump_to_landing_sequence()) {
mission.set_force_resume(true)
if ((copter.flightmode == &copter.mode_auto) || set_mode(Mode::Number::AUTO, reason)) {
auto_RTL = true
copter.logger.Write_Mode((uint8_t)copter.flightmode->mode_number(), reason)

if (copter.ap.initialised) {
AP_Notify::events.user_mode_change = 1
}
return true
}
mission.set_force_resume(false)

gcs().send_text(MAV_SEVERITY_WARNING, ""Mode change to AUTO RTL failed"")
} else {
gcs().send_text(MAV_SEVERITY_WARNING, ""Mode change to AUTO RTL failed: No landing sequence found"")
}

AP::logger().Write_Error(LogErrorSubsystem::FLIGHT_MODE, LogErrorCode(Number::AUTO_RTL))
if (copter.ap.initialised) {
AP_Notify::events.user_mode_change_failed = 1
}
return false
}
"
295,Arducopter\mode_auto.cpp_nav_script_time,"bool ModeAuto::nav_script_time(uint16_t &id, uint8_t &cmd, float &arg1, float &arg2)
{
if (_mode == SubMode::NAV_SCRIPT_TIME) {
id = nav_scripting.id
cmd = nav_scripting.command
arg1 = nav_scripting.arg1
arg2 = nav_scripting.arg2
return true
}
return false
}
"
296,Arducopter\mode_auto.cpp_nav_script_time_done,"void ModeAuto::nav_script_time_done(uint16_t id)
{
if ((_mode == SubMode::NAV_SCRIPT_TIME) && (id == nav_scripting.id)) {
nav_scripting.done = true
}
}
"
297,Arducopter\mode_auto.cpp_loiter_start,"bool ModeAuto::loiter_start()
{
if (!copter.position_ok()) {
return false
}
_mode = SubMode::LOITER

Vector3f stopping_point
wp_nav->get_wp_stopping_point(stopping_point)

wp_nav->set_wp_destination(stopping_point)

auto_yaw.set_mode(AUTO_YAW_HOLD)

return true
}
"
298,Arducopter\mode_auto.cpp_rtl_start,"void ModeAuto::rtl_start()
{
if (copter.mode_rtl.init(true)) {
set_submode(SubMode::RTL)
} else {
INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control)
}
}
"
299,Arducopter\mode_auto.cpp_takeoff_start,"void ModeAuto::takeoff_start(const Location& dest_loc)
{
if (!copter.current_loc.initialised()) {
INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control)
return
}

int32_t alt_target_cm
bool alt_target_terrain = false
float current_alt_cm = inertial_nav.get_position_z_up_cm()
float terrain_offset
if ((dest_loc.get_alt_frame() == Location::AltFrame::ABOVE_TERRAIN) && wp_nav->get_terrain_offset(terrain_offset)) {
current_alt_cm -= terrain_offset

alt_target_cm = dest_loc.alt
alt_target_terrain = true
} else {
Location dest(dest_loc)
dest.lat = copter.current_loc.lat
dest.lng = copter.current_loc.lng

if (!dest.get_alt_cm(Location::AltFrame::ABOVE_ORIGIN, alt_target_cm)) {
AP::logger().Write_Error(LogErrorSubsystem::TERRAIN, LogErrorCode::MISSING_TERRAIN_DATA)
alt_target_cm = current_alt_cm + dest.alt
}
}

int32_t alt_target_min_cm = current_alt_cm + (copter.ap.land_complete ? 100 : 0)
alt_target_cm = MAX(alt_target_cm, alt_target_min_cm)

auto_yaw.set_mode(AUTO_YAW_HOLD)

pos_control->init_z_controller()

auto_takeoff_start(alt_target_cm, alt_target_terrain)

set_submode(SubMode::TAKEOFF)
}
"
300,Arducopter\mode_auto.cpp_wp_start,"void ModeAuto::wp_start(const Location& dest_loc)
{
if (!wp_nav->is_active()) {
Vector3f stopping_point
if (_mode == SubMode::TAKEOFF) {
Vector3p takeoff_complete_pos
if (auto_takeoff_get_position(takeoff_complete_pos)) {
stopping_point = takeoff_complete_pos.tofloat()
}
}
wp_nav->wp_and_spline_init(0, stopping_point)
}

if (!wp_nav->set_wp_destination_loc(dest_loc)) {
copter.failsafe_terrain_on_event()
return
}

if (auto_yaw.mode() != AUTO_YAW_ROI) {
auto_yaw.set_mode_to_default(false)
}

set_submode(SubMode::WP)
}
"
301,Arducopter\mode_auto.cpp_land_start,"void ModeAuto::land_start()
{
pos_control->set_max_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_wp_acceleration())
pos_control->set_correction_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_wp_acceleration())

if (!pos_control->is_active_xy()) {
pos_control->init_xy_controller()
}

pos_control->set_max_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z())
pos_control->set_correction_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z())

if (!pos_control->is_active_z()) {
pos_control->init_z_controller()
}

auto_yaw.set_mode(AUTO_YAW_HOLD)

copter.landinggear.deploy_for_landing()

copter.fence.auto_disable_fence_for_landing()

copter.ap.land_repo_active = false

copter.ap.prec_land_active = false

set_submode(SubMode::LAND)
}
"
302,Arducopter\mode_auto.cpp_circle_movetoedge_start,"void ModeAuto::circle_movetoedge_start(const Location &circle_center, float radius_m)
{
copter.circle_nav->set_center(circle_center)

if (!is_zero(radius_m)) {
copter.circle_nav->set_radius_cm(radius_m * 100.0f)
}

Vector3f circle_edge_neu
copter.circle_nav->get_closest_point_on_circle(circle_edge_neu)
float dist_to_edge = (inertial_nav.get_position_neu_cm() - circle_edge_neu).length()

if (dist_to_edge > 300.0f) {
Location circle_edge(circle_edge_neu, Location::AltFrame::ABOVE_ORIGIN)

circle_edge.set_alt_cm(circle_center.alt, circle_center.get_alt_frame())

if (!wp_nav->set_wp_destination_loc(circle_edge)) {
copter.failsafe_terrain_on_event()
}

const float dist_to_center = get_horizontal_distance_cm(inertial_nav.get_position_xy_cm().topostype(), copter.circle_nav->get_center().xy())
if (auto_yaw.mode() != AUTO_YAW_ROI) {
if (dist_to_center > copter.circle_nav->get_radius() && dist_to_center > 500) {
auto_yaw.set_mode_to_default(false)
} else {
auto_yaw.set_mode(AUTO_YAW_HOLD)
}
}

set_submode(SubMode::CIRCLE_MOVE_TO_EDGE)
} else {
circle_start()
}
}
"
303,Arducopter\mode_auto.cpp_circle_start,"void ModeAuto::circle_start()
{
copter.circle_nav->init(copter.circle_nav->get_center(), copter.circle_nav->center_is_terrain_alt())

if (auto_yaw.mode() != AUTO_YAW_ROI) {
auto_yaw.set_mode(AUTO_YAW_CIRCLE)
}

set_submode(SubMode::CIRCLE)
}
"
304,Arducopter\mode_auto.cpp_nav_guided_start,"void ModeAuto::nav_guided_start()
{
if (!copter.mode_guided.init(true)) {
INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control)
return
}

copter.mode_guided.limit_init_time_and_pos()

set_submode(SubMode::NAVGUIDED)
}
"
305,Arducopter\mode_auto.cpp_is_landing,"bool ModeAuto::is_landing() const
{
switch(_mode) {
case SubMode::LAND:
return true
case SubMode::RTL:
return copter.mode_rtl.is_landing()
default:
return false
}
return false
}
"
306,Arducopter\mode_auto.cpp_is_taking_off,"bool ModeAuto::is_taking_off() const
{
return ((_mode == SubMode::TAKEOFF) && !auto_takeoff_complete)
}
"
307,Arducopter\mode_auto.cpp_payload_place_start,"void ModeAuto::payload_place_start()
{
nav_payload_place.state = PayloadPlaceStateType_Calibrating_Hover_Start

pos_control->set_max_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_wp_acceleration())
pos_control->set_correction_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_wp_acceleration())

if (!pos_control->is_active_xy()) {
pos_control->init_xy_controller()
}

pos_control->set_max_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z())
pos_control->set_correction_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z())

if (!pos_control->is_active_z()) {
pos_control->init_z_controller()
}

auto_yaw.set_mode(AUTO_YAW_HOLD)

set_submode(SubMode::NAV_PAYLOAD_PLACE)
}
"
308,Arducopter\mode_auto.cpp_use_pilot_yaw,"bool ModeAuto::use_pilot_yaw(void) const
{
return (copter.g2.auto_options.get() & uint32_t(Options::IgnorePilotYaw)) == 0
}
"
309,Arducopter\mode_auto.cpp_set_speed_xy,"bool ModeAuto::set_speed_xy(float speed_xy_cms)
{
copter.wp_nav->set_speed_xy(speed_xy_cms)
return true
}
"
310,Arducopter\mode_auto.cpp_set_speed_up,"bool ModeAuto::set_speed_up(float speed_up_cms)
{
copter.wp_nav->set_speed_up(speed_up_cms)
return true
}
"
311,Arducopter\mode_auto.cpp_set_speed_down,"bool ModeAuto::set_speed_down(float speed_down_cms)
{
copter.wp_nav->set_speed_down(speed_down_cms)
return true
}
"
312,Arducopter\mode_auto.cpp_start_command,"bool ModeAuto::start_command(const AP_Mission::Mission_Command& cmd)
{
if (copter.should_log(MASK_LOG_CMD)) {
copter.logger.Write_Mission_Cmd(mission, cmd)
}

switch(cmd.id) {

case MAV_CMD_NAV_VTOL_TAKEOFF:
case MAV_CMD_NAV_TAKEOFF:                   // 22
do_takeoff(cmd)
break

case MAV_CMD_NAV_WAYPOINT:                  // 16  Navigate to Waypoint
do_nav_wp(cmd)
break

case MAV_CMD_NAV_VTOL_LAND:
case MAV_CMD_NAV_LAND:              // 21 LAND to Waypoint
do_land(cmd)
break

case MAV_CMD_NAV_LOITER_UNLIM:              // 17 Loiter indefinitely
do_loiter_unlimited(cmd)
break

case MAV_CMD_NAV_LOITER_TURNS:              //18 Loiter N Times
do_circle(cmd)
break

case MAV_CMD_NAV_LOITER_TIME:              // 19
do_loiter_time(cmd)
break

case MAV_CMD_NAV_LOITER_TO_ALT:
do_loiter_to_alt(cmd)
break

case MAV_CMD_NAV_RETURN_TO_LAUNCH:             //20
do_RTL()
break

case MAV_CMD_NAV_SPLINE_WAYPOINT:           // 82  Navigate to Waypoint using spline
do_spline_wp(cmd)
break

case MAV_CMD_NAV_GUIDED_ENABLE:             // 92  accept navigation commands from external nav computer
do_nav_guided_enable(cmd)
break

case MAV_CMD_NAV_DELAY:                    // 93 Delay the next navigation command
do_nav_delay(cmd)
break

case MAV_CMD_NAV_PAYLOAD_PLACE:              // 94 place at Waypoint
do_payload_place(cmd)
break

case MAV_CMD_NAV_SCRIPT_TIME:
do_nav_script_time(cmd)
break

case MAV_CMD_NAV_ATTITUDE_TIME:
do_nav_attitude_time(cmd)
break

case MAV_CMD_CONDITION_DELAY:             // 112
do_wait_delay(cmd)
break

case MAV_CMD_CONDITION_DISTANCE:             // 114
do_within_distance(cmd)
break

case MAV_CMD_CONDITION_YAW:             // 115
do_yaw(cmd)
break

case MAV_CMD_DO_CHANGE_SPEED:             // 178
do_change_speed(cmd)
break

case MAV_CMD_DO_SET_HOME:             // 179
do_set_home(cmd)
break

case MAV_CMD_DO_SET_ROI:                // 201
do_roi(cmd)
break

case MAV_CMD_DO_MOUNT_CONTROL:          // 205
do_mount_control(cmd)
break

case MAV_CMD_DO_FENCE_ENABLE:
if (cmd.p1 == 0) { //disable
copter.fence.enable(false)
gcs().send_text(MAV_SEVERITY_INFO, ""Fence Disabled"")
} else { //enable fence
copter.fence.enable(true)
gcs().send_text(MAV_SEVERITY_INFO, ""Fence Enabled"")
}
break

case MAV_CMD_DO_GUIDED_LIMITS:                      // 220  accept guided mode limits
do_guided_limits(cmd)
break

case MAV_CMD_DO_WINCH:                             // Mission command to control winch
do_winch(cmd)
break

case MAV_CMD_DO_LAND_START:
break

default:
return false
}

return true
}
"
313,Arducopter\mode_auto.cpp_exit_mission,"void ModeAuto::exit_mission()
{
AP_Notify::events.mission_complete = 1
if (!copter.ap.land_complete) {
if (!loiter_start()) {
set_mode(Mode::Number::LAND, ModeReason::MISSION_END)
}
} else {
copter.arming.disarm(AP_Arming::Method::MISSIONEXIT)
}
}
"
314,Arducopter\mode_auto.cpp_do_guided,"bool ModeAuto::do_guided(const AP_Mission::Mission_Command& cmd)
{
if (copter.flightmode->mode_number() != Mode::Number::GUIDED && !(copter.flightmode->mode_number() == Mode::Number::AUTO && _mode == SubMode::NAVGUIDED)) {
return false
}

switch (cmd.id) {

case MAV_CMD_NAV_WAYPOINT:
{
Location dest(cmd.content.location)
return copter.mode_guided.set_destination(dest)
}

case MAV_CMD_CONDITION_YAW:
do_yaw(cmd)
return true

default:
return false
}

return true
}
"
315,Arducopter\mode_auto.cpp_wp_distance,"uint32_t ModeAuto::wp_distance() const
{
switch (_mode) {
case SubMode::CIRCLE:
return copter.circle_nav->get_distance_to_target()
case SubMode::WP:
case SubMode::CIRCLE_MOVE_TO_EDGE:
default:
return wp_nav->get_wp_distance_to_destination()
}
}
"
316,Arducopter\mode_auto.cpp_wp_bearing,"int32_t ModeAuto::wp_bearing() const
{
switch (_mode) {
case SubMode::CIRCLE:
return copter.circle_nav->get_bearing_to_target()
case SubMode::WP:
case SubMode::CIRCLE_MOVE_TO_EDGE:
default:
return wp_nav->get_wp_bearing_to_destination()
}
}
"
317,Arducopter\mode_auto.cpp_get_wp,"bool ModeAuto::get_wp(Location& destination) const
{
switch (_mode) {
case SubMode::NAVGUIDED:
return copter.mode_guided.get_wp(destination)
case SubMode::WP:
return wp_nav->get_oa_wp_destination(destination)
case SubMode::RTL:
return copter.mode_rtl.get_wp(destination)
default:
return false
}
}
"
318,Arducopter\mode_auto.cpp_verify_command,"bool ModeAuto::verify_command(const AP_Mission::Mission_Command& cmd)
{
if (copter.flightmode != &copter.mode_auto) {
return false
}

bool cmd_complete = false

switch (cmd.id) {
case MAV_CMD_NAV_VTOL_TAKEOFF:
case MAV_CMD_NAV_TAKEOFF:
cmd_complete = verify_takeoff()
break

case MAV_CMD_NAV_WAYPOINT:
cmd_complete = verify_nav_wp(cmd)
break

case MAV_CMD_NAV_VTOL_LAND:
case MAV_CMD_NAV_LAND:
cmd_complete = verify_land()
break

case MAV_CMD_NAV_PAYLOAD_PLACE:
cmd_complete = verify_payload_place()
break

case MAV_CMD_NAV_LOITER_UNLIM:
cmd_complete = verify_loiter_unlimited()
break

case MAV_CMD_NAV_LOITER_TURNS:
cmd_complete = verify_circle(cmd)
break

case MAV_CMD_NAV_LOITER_TIME:
cmd_complete = verify_loiter_time(cmd)
break

case MAV_CMD_NAV_LOITER_TO_ALT:
return verify_loiter_to_alt()

case MAV_CMD_NAV_RETURN_TO_LAUNCH:
cmd_complete = verify_RTL()
break

case MAV_CMD_NAV_SPLINE_WAYPOINT:
cmd_complete = verify_spline_wp(cmd)
break

case MAV_CMD_NAV_GUIDED_ENABLE:
cmd_complete = verify_nav_guided_enable(cmd)
break

case MAV_CMD_NAV_DELAY:
cmd_complete = verify_nav_delay(cmd)
break

case MAV_CMD_NAV_SCRIPT_TIME:
cmd_complete = verify_nav_script_time()
break

case MAV_CMD_NAV_ATTITUDE_TIME:
cmd_complete = verify_nav_attitude_time(cmd)
break

case MAV_CMD_CONDITION_DELAY:
cmd_complete = verify_wait_delay()
break

case MAV_CMD_CONDITION_DISTANCE:
cmd_complete = verify_within_distance()
break

case MAV_CMD_CONDITION_YAW:
cmd_complete = verify_yaw()
break

case MAV_CMD_DO_CHANGE_SPEED:
case MAV_CMD_DO_SET_HOME:
case MAV_CMD_DO_SET_ROI:
case MAV_CMD_DO_MOUNT_CONTROL:
case MAV_CMD_DO_GUIDED_LIMITS:
case MAV_CMD_DO_FENCE_ENABLE:
case MAV_CMD_DO_WINCH:
case MAV_CMD_DO_LAND_START:
cmd_complete = true
break

default:
gcs().send_text(MAV_SEVERITY_WARNING,""Skipping invalid cmd #%i"",cmd.id)
cmd_complete = true
break
}


if (cmd_complete) {
gcs().send_mission_item_reached_message(cmd.index)
}

return cmd_complete
}
"
319,Arducopter\mode_auto.cpp_takeoff_run,"void ModeAuto::takeoff_run()
{
if ((copter.g2.auto_options & (int32_t)Options::AllowTakeOffWithoutRaisingThrottle) != 0) {
copter.set_auto_armed(true)
}
auto_takeoff_run()
}
"
320,Arducopter\mode_auto.cpp_wp_run,"void ModeAuto::wp_run()
{
float target_yaw_rate = 0
if (!copter.failsafe.radio && use_pilot_yaw()) {
target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
if (!is_zero(target_yaw_rate)) {
auto_yaw.set_mode(AUTO_YAW_HOLD)
}
}

if (is_disarmed_or_landed()) {
make_safe_ground_handling()
return
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

copter.failsafe_terrain_set_status(wp_nav->update_wpnav())

pos_control->update_z_controller()

if (auto_yaw.mode() == AUTO_YAW_HOLD) {
attitude_control->input_thrust_vector_rate_heading(wp_nav->get_thrust_vector(), target_yaw_rate)
} else {
attitude_control->input_thrust_vector_heading(wp_nav->get_thrust_vector(), auto_yaw.yaw(), auto_yaw.rate_cds())
}
}
"
321,Arducopter\mode_auto.cpp_land_run,"void ModeAuto::land_run()
{

if (is_disarmed_or_landed()) {
make_safe_ground_handling()
return
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

land_run_normal_or_precland()
}
"
322,Arducopter\mode_auto.cpp_rtl_run,"void ModeAuto::rtl_run()
{
copter.mode_rtl.run(false)
}
"
323,Arducopter\mode_auto.cpp_circle_run,"void ModeAuto::circle_run()
{
float target_yaw_rate = 0
if (!copter.failsafe.radio && use_pilot_yaw()) {
target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
if (!is_zero(target_yaw_rate)) {
auto_yaw.set_mode(AUTO_YAW_HOLD)
}
}

copter.failsafe_terrain_set_status(copter.circle_nav->update())

pos_control->update_z_controller()

if (auto_yaw.mode() == AUTO_YAW_HOLD) {
attitude_control->input_thrust_vector_rate_heading(copter.circle_nav->get_thrust_vector(), target_yaw_rate)
} else {
attitude_control->input_thrust_vector_heading(copter.circle_nav->get_thrust_vector(), auto_yaw.yaw())
}
}
"
324,Arducopter\mode_auto.cpp_nav_guided_run,"void ModeAuto::nav_guided_run()
{
copter.mode_guided.run()
}
"
325,Arducopter\mode_auto.cpp_loiter_run,"void ModeAuto::loiter_run()
{
if (is_disarmed_or_landed()) {
make_safe_ground_handling()
return
}

float target_yaw_rate = 0
if (!copter.failsafe.radio && use_pilot_yaw()) {
target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

copter.failsafe_terrain_set_status(wp_nav->update_wpnav())

pos_control->update_z_controller()
attitude_control->input_thrust_vector_rate_heading(wp_nav->get_thrust_vector(), target_yaw_rate)
}
"
326,Arducopter\mode_auto.cpp_loiter_to_alt_run,"void ModeAuto::loiter_to_alt_run()
{
if (is_disarmed_or_landed() || !motors->get_interlock()) {
make_safe_ground_handling()
return
}

if (!loiter_to_alt.reached_destination_xy) {
loiter_to_alt.reached_destination_xy = wp_nav->reached_wp_destination_xy()
if (!loiter_to_alt.reached_destination_xy) {
wp_run()
return
}
}

if (!loiter_to_alt.loiter_start_done) {
pos_control->set_max_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_wp_acceleration())
pos_control->set_correction_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_wp_acceleration())

if (!pos_control->is_active_xy()) {
pos_control->init_xy_controller()
}

loiter_to_alt.loiter_start_done = true
}
const float alt_error_cm = copter.current_loc.alt - loiter_to_alt.alt
if (fabsf(alt_error_cm) < 5.0) { // random numbers R US
loiter_to_alt.reached_alt = true
} else if (alt_error_cm * loiter_to_alt.alt_error_cm < 0) {
loiter_to_alt.reached_alt = true
}
loiter_to_alt.alt_error_cm = alt_error_cm


land_run_horizontal_control()

float target_climb_rate = sqrt_controller(
-alt_error_cm,
pos_control->get_pos_z_p().kP(),
pos_control->get_max_accel_z_cmss(),
G_Dt)
target_climb_rate = constrain_float(target_climb_rate, pos_control->get_max_speed_down_cms(), pos_control->get_max_speed_up_cms())

target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate)

copter.surface_tracking.update_surface_offset()

pos_control->set_pos_target_z_from_climb_rate_cm(target_climb_rate)

pos_control->update_z_controller()
}
"
327,Arducopter\mode_auto.cpp_nav_attitude_time_run,"void ModeAuto::nav_attitude_time_run()
{
if (is_disarmed_or_landed() || !motors->get_interlock()) {
make_safe_ground_handling()
return
}

float target_climb_rate_cms = constrain_float(nav_attitude_time.climb_rate * 100.0, pos_control->get_max_speed_down_cms(), pos_control->get_max_speed_up_cms())

target_climb_rate_cms = get_avoidance_adjusted_climbrate(target_climb_rate_cms)

const float angle_limit_cd = MAX(1000.0f, MIN(copter.aparm.angle_max, attitude_control->get_althold_lean_angle_max_cd()))
Vector2f target_rp_cd(nav_attitude_time.roll_deg * 100, nav_attitude_time.pitch_deg * 100)
target_rp_cd.limit_length(angle_limit_cd)

attitude_control->input_euler_angle_roll_pitch_yaw(target_rp_cd.x, target_rp_cd.y, nav_attitude_time.yaw_deg * 100, true)

pos_control->set_pos_target_z_from_climb_rate_cm(target_climb_rate_cms)

pos_control->update_z_controller()
}
"
328,Arducopter\mode_auto.cpp_payload_place_run,"void ModeAuto::payload_place_run()
{
if (!payload_place_run_should_run()) {
zero_throttle_and_relax_ac()
return
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

switch (nav_payload_place.state) {
case PayloadPlaceStateType_FlyToLocation:
return wp_run()
case PayloadPlaceStateType_Calibrating_Hover_Start:
case PayloadPlaceStateType_Calibrating_Hover:
return payload_place_run_hover()
case PayloadPlaceStateType_Descending_Start:
case PayloadPlaceStateType_Descending:
return payload_place_run_descend()
case PayloadPlaceStateType_Releasing_Start:
case PayloadPlaceStateType_Releasing:
case PayloadPlaceStateType_Released:
case PayloadPlaceStateType_Ascending_Start:
return payload_place_run_hover()
case PayloadPlaceStateType_Ascending:
case PayloadPlaceStateType_Done:
return takeoff_run()
}
}
"
329,Arducopter\mode_auto.cpp_payload_place_run_should_run,"bool ModeAuto::payload_place_run_should_run()
{
if (!motors->armed()) {
return false
}
if (!copter.ap.auto_armed) {
return false
}
if (copter.ap.land_complete && (nav_payload_place.state == PayloadPlaceStateType_FlyToLocation || nav_payload_place.state == PayloadPlaceStateType_Calibrating_Hover_Start)) {
return false
}
if (!motors->get_interlock()) {
return false
}

return true
}
"
330,Arducopter\mode_auto.cpp_payload_place_run_hover,"void ModeAuto::payload_place_run_hover()
{
land_run_horizontal_control()
land_run_vertical_control(true)
}
"
331,Arducopter\mode_auto.cpp_payload_place_run_descend,"void ModeAuto::payload_place_run_descend()
{
land_run_horizontal_control()
land_run_vertical_control()
}
"
332,Arducopter\mode_auto.cpp_shift_alt_to_current_alt,"bool ModeAuto::shift_alt_to_current_alt(Location& target_loc) const
{
if ((target_loc.get_alt_frame() == Location::AltFrame::ABOVE_TERRAIN) &&
(wp_nav->get_terrain_source() == AC_WPNav::TerrainSource::TERRAIN_FROM_RANGEFINDER)) {
int32_t curr_rngfnd_alt_cm
if (copter.get_rangefinder_height_interpolated_cm(curr_rngfnd_alt_cm)) {
target_loc.set_alt_cm(MAX(curr_rngfnd_alt_cm, 200), Location::AltFrame::ABOVE_TERRAIN)
return true
}
return false
}

Location currloc = copter.current_loc
if (!currloc.change_alt_frame(target_loc.get_alt_frame())) {
return false
}

target_loc.set_alt_cm(currloc.alt, currloc.get_alt_frame())
return true
}
"
333,Arducopter\mode_auto.cpp_do_takeoff,"void ModeAuto::do_takeoff(const AP_Mission::Mission_Command& cmd)
{
takeoff_start(cmd.content.location)
}
"
334,Arducopter\mode_auto.cpp_loc_from_cmd,"Location ModeAuto::loc_from_cmd(const AP_Mission::Mission_Command& cmd, const Location& default_loc) const
{
Location ret(cmd.content.location)

if (ret.lat == 0 && ret.lng == 0) {
ret.lat = default_loc.lat
ret.lng = default_loc.lng
}
if (ret.alt == 0) {
int32_t default_alt
if (default_loc.get_alt_cm(ret.get_alt_frame(), default_alt)) {
ret.set_alt_cm(default_alt, ret.get_alt_frame())
} else {
ret.set_alt_cm(default_loc.alt, default_loc.get_alt_frame())
}
}
return ret
}
"
335,Arducopter\mode_auto.cpp_do_nav_wp,"void ModeAuto::do_nav_wp(const AP_Mission::Mission_Command& cmd)
{
Location default_loc = copter.current_loc
if (wp_nav->is_active() && wp_nav->reached_wp_destination()) {
if (!wp_nav->get_wp_destination_loc(default_loc)) {
INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control)
}
}

if (!wp_nav->is_active()) {
Vector3f stopping_point
if (_mode == SubMode::TAKEOFF) {
Vector3p takeoff_complete_pos
if (auto_takeoff_get_position(takeoff_complete_pos)) {
stopping_point = takeoff_complete_pos.tofloat()
}
}
wp_nav->wp_and_spline_init(0, stopping_point)
}

const Location dest_loc = loc_from_cmd(cmd, default_loc)
if (!wp_nav->set_wp_destination_loc(dest_loc)) {
copter.failsafe_terrain_on_event()
return
}

loiter_time = 0
loiter_time_max = cmd.p1

if (!set_next_wp(cmd, dest_loc)) {
copter.failsafe_terrain_on_event()
return
}

if (auto_yaw.mode() != AUTO_YAW_ROI) {
auto_yaw.set_mode_to_default(false)
}

set_submode(SubMode::WP)
}
"
336,Arducopter\mode_auto.cpp_set_next_wp,"bool ModeAuto::set_next_wp(const AP_Mission::Mission_Command& current_cmd, const Location &default_loc)
{
if (current_cmd.p1 > 0) {
return true
}

AP_Mission::Mission_Command next_cmd
if (!mission.get_next_nav_cmd(current_cmd.index+1, next_cmd)) {
return true
}

switch (next_cmd.id) {
case MAV_CMD_NAV_WAYPOINT:
case MAV_CMD_NAV_LOITER_UNLIM:
case MAV_CMD_NAV_LOITER_TIME: {
const Location dest_loc = loc_from_cmd(current_cmd, default_loc)
const Location next_dest_loc = loc_from_cmd(next_cmd, dest_loc)
return wp_nav->set_wp_destination_next_loc(next_dest_loc)
}
case MAV_CMD_NAV_SPLINE_WAYPOINT: {
Location next_dest_loc, next_next_dest_loc
bool next_next_dest_loc_is_spline
get_spline_from_cmd(next_cmd, default_loc, next_dest_loc, next_next_dest_loc, next_next_dest_loc_is_spline)
return wp_nav->set_spline_destination_next_loc(next_dest_loc, next_next_dest_loc, next_next_dest_loc_is_spline)
}
case MAV_CMD_NAV_VTOL_LAND:
case MAV_CMD_NAV_LAND:
case MAV_CMD_NAV_LOITER_TURNS:
case MAV_CMD_NAV_RETURN_TO_LAUNCH:
case MAV_CMD_NAV_VTOL_TAKEOFF:
case MAV_CMD_NAV_TAKEOFF:
default:
break
}

return true
}
"
337,Arducopter\mode_auto.cpp_do_land,"void ModeAuto::do_land(const AP_Mission::Mission_Command& cmd)
{

if (cmd.content.location.lat != 0 || cmd.content.location.lng != 0) {
state = State::FlyToLocation

Location target_loc(cmd.content.location)
if (!shift_alt_to_current_alt(target_loc)) {
target_loc.set_alt_cm(copter.current_loc.alt, Location::AltFrame::ABOVE_HOME)
AP::logger().Write_Error(LogErrorSubsystem::TERRAIN, LogErrorCode::MISSING_TERRAIN_DATA)
gcs().send_text(MAV_SEVERITY_CRITICAL, ""Land: no terrain data, using alt-above-home"")
}

wp_start(target_loc)
} else {
state = State::Descending

land_start()
}
}
"
338,Arducopter\mode_auto.cpp_do_loiter_unlimited,"void ModeAuto::do_loiter_unlimited(const AP_Mission::Mission_Command& cmd)
{
Location target_loc(cmd.content.location)

if (target_loc.lat == 0 && target_loc.lng == 0) {
Vector3f temp_pos
copter.wp_nav->get_wp_stopping_point_xy(temp_pos.xy())
const Location temp_loc(temp_pos, Location::AltFrame::ABOVE_ORIGIN)
target_loc.lat = temp_loc.lat
target_loc.lng = temp_loc.lng
}

if (target_loc.alt == 0) {
int32_t curr_alt
if (copter.current_loc.get_alt_cm(target_loc.get_alt_frame(),curr_alt)) {
target_loc.set_alt_cm(curr_alt, target_loc.get_alt_frame())
} else {
target_loc.set_alt_cm(copter.current_loc.alt,
copter.current_loc.get_alt_frame())
}
}

wp_start(target_loc)
}
"
339,Arducopter\mode_auto.cpp_do_circle,"void ModeAuto::do_circle(const AP_Mission::Mission_Command& cmd)
{
const Location circle_center = loc_from_cmd(cmd, copter.current_loc)

uint16_t circle_radius_m = HIGHBYTE(cmd.p1)
if (cmd.id == MAV_CMD_NAV_LOITER_TURNS &&
cmd.type_specific_bits & (1U << 0)) {
circle_radius_m *= 10
}

circle_movetoedge_start(circle_center, circle_radius_m)
}
"
340,Arducopter\mode_auto.cpp_do_loiter_time,"void ModeAuto::do_loiter_time(const AP_Mission::Mission_Command& cmd)
{
do_loiter_unlimited(cmd)

loiter_time     = 0
loiter_time_max = cmd.p1
}
"
341,Arducopter\mode_auto.cpp_do_loiter_to_alt,"void ModeAuto::do_loiter_to_alt(const AP_Mission::Mission_Command& cmd)
{
do_loiter_unlimited(cmd)

Location target_loc(cmd.content.location)
if (target_loc.lat == 0 && target_loc.lng == 0) {
target_loc.lat = copter.current_loc.lat
target_loc.lng = copter.current_loc.lng
}

if (!target_loc.get_alt_cm(Location::AltFrame::ABOVE_HOME, loiter_to_alt.alt)) {
loiter_to_alt.reached_destination_xy = true
loiter_to_alt.reached_alt = true
gcs().send_text(MAV_SEVERITY_INFO, ""bad do_loiter_to_alt"")
return
}
loiter_to_alt.reached_destination_xy = false
loiter_to_alt.loiter_start_done = false
loiter_to_alt.reached_alt = false
loiter_to_alt.alt_error_cm = 0

pos_control->set_max_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z())
pos_control->set_correction_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z())

set_submode(SubMode::LOITER_TO_ALT)
}
"
342,Arducopter\mode_auto.cpp_do_spline_wp,"void ModeAuto::do_spline_wp(const AP_Mission::Mission_Command& cmd)
{
Location default_loc = copter.current_loc
if (wp_nav->is_active() && wp_nav->reached_wp_destination()) {
if (!wp_nav->get_wp_destination_loc(default_loc)) {
INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control)
}
}

Location dest_loc, next_dest_loc
bool next_dest_loc_is_spline
get_spline_from_cmd(cmd, default_loc, dest_loc, next_dest_loc, next_dest_loc_is_spline)
if (!wp_nav->set_spline_destination_loc(dest_loc, next_dest_loc, next_dest_loc_is_spline)) {
copter.failsafe_terrain_on_event()
return
}

loiter_time = 0
loiter_time_max = cmd.p1

if (!set_next_wp(cmd, dest_loc)) {
copter.failsafe_terrain_on_event()
return
}

if (auto_yaw.mode() != AUTO_YAW_ROI) {
auto_yaw.set_mode_to_default(false)
}

set_submode(SubMode::WP)
}
"
343,Arducopter\mode_auto.cpp_get_spline_from_cmd,"void ModeAuto::get_spline_from_cmd(const AP_Mission::Mission_Command& cmd, const Location& default_loc, Location& dest_loc, Location& next_dest_loc, bool& next_dest_loc_is_spline)
{
dest_loc = loc_from_cmd(cmd, default_loc)

AP_Mission::Mission_Command temp_cmd
if (cmd.p1 == 0 && mission.get_next_nav_cmd(cmd.index+1, temp_cmd)) {
next_dest_loc = loc_from_cmd(temp_cmd, dest_loc)
next_dest_loc_is_spline = temp_cmd.id == MAV_CMD_NAV_SPLINE_WAYPOINT
} else {
next_dest_loc = dest_loc
next_dest_loc_is_spline = false
}
}
"
344,Arducopter\mode_auto.cpp_do_nav_guided_enable,"void ModeAuto::do_nav_guided_enable(const AP_Mission::Mission_Command& cmd)
{
if (cmd.p1 > 0) {
nav_guided_start()
}
}
"
345,Arducopter\mode_auto.cpp_do_guided_limits,"void ModeAuto::do_guided_limits(const AP_Mission::Mission_Command& cmd)
{
copter.mode_guided.limit_set(
cmd.p1 * 1000, // convert seconds to ms
cmd.content.guided_limits.alt_min * 100.0f,    // convert meters to cm
cmd.content.guided_limits.alt_max * 100.0f,    // convert meters to cm
cmd.content.guided_limits.horiz_max * 100.0f)
}
"
346,Arducopter\mode_auto.cpp_do_nav_delay,"void ModeAuto::do_nav_delay(const AP_Mission::Mission_Command& cmd)
{
nav_delay_time_start_ms = millis()

if (cmd.content.nav_delay.seconds > 0) {
nav_delay_time_max_ms = cmd.content.nav_delay.seconds * 1000
} else {
nav_delay_time_max_ms = AP::rtc().get_time_utc(cmd.content.nav_delay.hour_utc, cmd.content.nav_delay.min_utc, cmd.content.nav_delay.sec_utc, 0)
}
gcs().send_text(MAV_SEVERITY_INFO, ""Delaying %u sec"", (unsigned)(nav_delay_time_max_ms/1000))
}
"
347,Arducopter\mode_auto.cpp_do_nav_script_time,"void ModeAuto::do_nav_script_time(const AP_Mission::Mission_Command& cmd)
{
if (copter.mode_guided.init(true)) {
nav_scripting.done = false
nav_scripting.id++
nav_scripting.start_ms = millis()
nav_scripting.command = cmd.content.nav_script_time.command
nav_scripting.timeout_s = cmd.content.nav_script_time.timeout_s
nav_scripting.arg1 = cmd.content.nav_script_time.arg1
nav_scripting.arg2 = cmd.content.nav_script_time.arg2
set_submode(SubMode::NAV_SCRIPT_TIME)
} else {
nav_scripting.done = true
}
}
"
348,Arducopter\mode_auto.cpp_do_nav_attitude_time,"void ModeAuto::do_nav_attitude_time(const AP_Mission::Mission_Command& cmd)
{
nav_attitude_time.roll_deg = cmd.content.nav_attitude_time.roll_deg
nav_attitude_time.pitch_deg = cmd.content.nav_attitude_time.pitch_deg
nav_attitude_time.yaw_deg = cmd.content.nav_attitude_time.yaw_deg
nav_attitude_time.climb_rate = cmd.content.nav_attitude_time.climb_rate
nav_attitude_time.start_ms = AP_HAL::millis()
set_submode(SubMode::NAV_ATTITUDE_TIME)
}
"
349,Arducopter\mode_auto.cpp_do_wait_delay,"void ModeAuto::do_wait_delay(const AP_Mission::Mission_Command& cmd)
{
condition_start = millis()
condition_value = cmd.content.delay.seconds * 1000
}
"
350,Arducopter\mode_auto.cpp_do_within_distance,"void ModeAuto::do_within_distance(const AP_Mission::Mission_Command& cmd)
{
condition_value  = cmd.content.distance.meters * 100
}
"
351,Arducopter\mode_auto.cpp_do_yaw,"void ModeAuto::do_yaw(const AP_Mission::Mission_Command& cmd)
{
auto_yaw.set_fixed_yaw(
cmd.content.yaw.angle_deg,
cmd.content.yaw.turn_rate_dps,
cmd.content.yaw.direction,
cmd.content.yaw.relative_angle > 0)
}
"
352,Arducopter\mode_auto.cpp_do_change_speed,"void ModeAuto::do_change_speed(const AP_Mission::Mission_Command& cmd)
{
if (cmd.content.speed.target_ms > 0) {
if (cmd.content.speed.speed_type == 2)  {
copter.wp_nav->set_speed_up(cmd.content.speed.target_ms * 100.0f)
} else if (cmd.content.speed.speed_type == 3)  {
copter.wp_nav->set_speed_down(cmd.content.speed.target_ms * 100.0f)
} else {
copter.wp_nav->set_speed_xy(cmd.content.speed.target_ms * 100.0f)
}
}
}
"
353,Arducopter\mode_auto.cpp_do_set_home,"void ModeAuto::do_set_home(const AP_Mission::Mission_Command& cmd)
{
if (cmd.p1 == 1 || (cmd.content.location.lat == 0 && cmd.content.location.lng == 0 && cmd.content.location.alt == 0)) {
if (!copter.set_home_to_current_location(false)) {
}
} else {
if (!copter.set_home(cmd.content.location, false)) {
}
}
}
"
354,Arducopter\mode_auto.cpp_do_roi,"void ModeAuto::do_roi(const AP_Mission::Mission_Command& cmd)
{
auto_yaw.set_roi(cmd.content.location)
}
"
355,Arducopter\mode_auto.cpp_do_mount_control,"void ModeAuto::do_mount_control(const AP_Mission::Mission_Command& cmd)
{
if ((copter.camera_mount.get_mount_type() != copter.camera_mount.MountType::Mount_Type_None) &&
!copter.camera_mount.has_pan_control()) {
auto_yaw.set_yaw_angle_rate(cmd.content.mount_control.yaw,0.0f)
}
copter.camera_mount.set_angle_target(cmd.content.mount_control.roll, cmd.content.mount_control.pitch, cmd.content.mount_control.yaw, false)
}
"
356,Arducopter\mode_auto.cpp_do_winch,"void ModeAuto::do_winch(const AP_Mission::Mission_Command& cmd)
{
switch (cmd.content.winch.action) {
case WINCH_RELAXED:
g2.winch.relax()
break
case WINCH_RELATIVE_LENGTH_CONTROL:
g2.winch.release_length(cmd.content.winch.release_length)
break
case WINCH_RATE_CONTROL:
g2.winch.set_desired_rate(cmd.content.winch.release_rate)
break
default:
break
}
}
"
357,Arducopter\mode_auto.cpp_do_payload_place,"void ModeAuto::do_payload_place(const AP_Mission::Mission_Command& cmd)
{
if (cmd.content.location.lat != 0 || cmd.content.location.lng != 0) {
nav_payload_place.state = PayloadPlaceStateType_FlyToLocation

Location target_loc(cmd.content.location)
if (!shift_alt_to_current_alt(target_loc)) {
target_loc.set_alt_cm(copter.current_loc.alt, Location::AltFrame::ABOVE_HOME)
AP::logger().Write_Error(LogErrorSubsystem::TERRAIN, LogErrorCode::MISSING_TERRAIN_DATA)
gcs().send_text(MAV_SEVERITY_CRITICAL, ""PayloadPlace: no terrain data, using alt-above-home"")
}

wp_start(target_loc)
} else {
nav_payload_place.state = PayloadPlaceStateType_Calibrating_Hover_Start

payload_place_start()
}
nav_payload_place.descend_max = cmd.p1
}
"
358,Arducopter\mode_auto.cpp_do_RTL,"void ModeAuto::do_RTL(void)
{
rtl_start()
}
"
359,Arducopter\mode_auto.cpp_verify_takeoff,"bool ModeAuto::verify_takeoff()
{
if (auto_takeoff_complete) {
copter.landinggear.retract_after_takeoff()
}

return auto_takeoff_complete
}
"
360,Arducopter\mode_auto.cpp_verify_land,"bool ModeAuto::verify_land()
{
bool retval = false

switch (state) {
case State::FlyToLocation:
if (copter.wp_nav->reached_wp_destination()) {
land_start()

state = State::Descending
}
break

case State::Descending:
retval = copter.ap.land_complete && (motors->get_spool_state() == AP_Motors::SpoolState::GROUND_IDLE)
if (retval && !mission.continue_after_land_check_for_takeoff() && copter.motors->armed()) {
we want to stop mission processing on land
completion. Disarm now, then return false. This
leaves mission state machine in the current NAV_LAND
mission item. After disarming the mission will reset
copter.arming.disarm(AP_Arming::Method::LANDED)
retval = false
}
break

default:
INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control)
retval = true
break
}

return retval
}
"
361,Arducopter\mode_auto.cpp_verify_payload_place,"bool ModeAuto::verify_payload_place()
{
const uint16_t hover_throttle_calibrate_time = 2000
const uint16_t descend_throttle_calibrate_time = 2000
const uint16_t measure_time = 1000
const float hover_throttle_placed_fraction = 0.7
const float descent_throttle_placed_fraction = 0.9
const uint16_t placed_time = 500

const float current_throttle_level = motors->get_throttle()
const uint32_t now = AP_HAL::millis()

if (copter.ap.land_complete || copter.ap.land_complete_maybe) {
switch (nav_payload_place.state) {
case PayloadPlaceStateType_FlyToLocation:
case PayloadPlaceStateType_Calibrating_Hover_Start:
case PayloadPlaceStateType_Calibrating_Hover:
case PayloadPlaceStateType_Descending_Start:
case PayloadPlaceStateType_Descending:
gcs().send_text(MAV_SEVERITY_INFO, ""PayloadPlace: landed"")
nav_payload_place.state = PayloadPlaceStateType_Releasing_Start
break
case PayloadPlaceStateType_Releasing_Start:
case PayloadPlaceStateType_Releasing:
case PayloadPlaceStateType_Released:
case PayloadPlaceStateType_Ascending_Start:
case PayloadPlaceStateType_Ascending:
case PayloadPlaceStateType_Done:
break
}
}

switch (nav_payload_place.state) {
case PayloadPlaceStateType_FlyToLocation:
if (!copter.wp_nav->reached_wp_destination()) {
return false
}
payload_place_start()
return false
case PayloadPlaceStateType_Calibrating_Hover_Start:
debug(""Calibrate start"")
nav_payload_place.hover_start_timestamp = now
nav_payload_place.hover_throttle_level = 1.0
nav_payload_place.state = PayloadPlaceStateType_Calibrating_Hover
FALLTHROUGH
case PayloadPlaceStateType_Calibrating_Hover: {
if (now - nav_payload_place.hover_start_timestamp < hover_throttle_calibrate_time - measure_time) {
return false
}
if (now - nav_payload_place.hover_start_timestamp < hover_throttle_calibrate_time) {
nav_payload_place.hover_throttle_level = MIN(nav_payload_place.hover_throttle_level, current_throttle_level)
return false
}
gcs().send_text(MAV_SEVERITY_INFO, ""PayloadPlace: payload hover throttle: %f"", static_cast<double>(nav_payload_place.hover_throttle_level))
nav_payload_place.state = PayloadPlaceStateType_Descending_Start
}
FALLTHROUGH
case PayloadPlaceStateType_Descending_Start:
nav_payload_place.descend_start_timestamp = now
nav_payload_place.descend_start_altitude = inertial_nav.get_position_z_up_cm()
nav_payload_place.descend_throttle_level = 1.0
nav_payload_place.state = PayloadPlaceStateType_Descending
FALLTHROUGH
case PayloadPlaceStateType_Descending:
debug(""descended: %f cm (%f cm max)"", (nav_payload_place.descend_start_altitude - inertial_nav.get_position_z_up_cm()), nav_payload_place.descend_max)
if (!is_zero(nav_payload_place.descend_max) &&
nav_payload_place.descend_start_altitude - inertial_nav.get_position_z_up_cm()  > nav_payload_place.descend_max) {
nav_payload_place.state = PayloadPlaceStateType_Ascending_Start
gcs().send_text(MAV_SEVERITY_WARNING, ""PayloadPlace: Reached maximum descent"")
return false
}
if ((now - nav_payload_place.descend_start_timestamp > descend_throttle_calibrate_time - measure_time) &&
(now - nav_payload_place.descend_start_timestamp < descend_throttle_calibrate_time)) {
nav_payload_place.descend_throttle_level = MIN(nav_payload_place.descend_throttle_level, current_throttle_level)
}
if (current_throttle_level > hover_throttle_placed_fraction * nav_payload_place.hover_throttle_level &&
(now - nav_payload_place.descend_start_timestamp < descend_throttle_calibrate_time ||
current_throttle_level > descent_throttle_placed_fraction * nav_payload_place.descend_throttle_level)) {
nav_payload_place.place_start_timestamp = now
return false
}
if (now - nav_payload_place.place_start_timestamp < placed_time) {
debug(""Place Timer: %d"", now - nav_payload_place.place_start_timestamp)
return false
}
nav_payload_place.state = PayloadPlaceStateType_Releasing_Start
FALLTHROUGH
case PayloadPlaceStateType_Releasing_Start:
pos_control->init_z_controller_no_descent()
if (g2.gripper.valid()) {
gcs().send_text(MAV_SEVERITY_INFO, ""PayloadPlace: Releasing the gripper"")
g2.gripper.release()
} else {
gcs().send_text(MAV_SEVERITY_INFO, ""PayloadPlace: Gripper not valid"")
nav_payload_place.state = PayloadPlaceStateType_Ascending_Start
return false
}
gcs().send_text(MAV_SEVERITY_INFO, ""Gripper code disabled"")
nav_payload_place.state = PayloadPlaceStateType_Ascending_Start
return false
nav_payload_place.state = PayloadPlaceStateType_Releasing
FALLTHROUGH
case PayloadPlaceStateType_Releasing:
if (g2.gripper.valid() && !g2.gripper.released()) {
return false
}
nav_payload_place.state = PayloadPlaceStateType_Released
FALLTHROUGH
case PayloadPlaceStateType_Released: {
nav_payload_place.state = PayloadPlaceStateType_Ascending_Start
}
FALLTHROUGH
case PayloadPlaceStateType_Ascending_Start: {
auto_takeoff_start(nav_payload_place.descend_start_altitude, false)
nav_payload_place.state = PayloadPlaceStateType_Ascending
}
FALLTHROUGH
case PayloadPlaceStateType_Ascending:
if (!auto_takeoff_complete) {
return false
}
nav_payload_place.state = PayloadPlaceStateType_Done
FALLTHROUGH
case PayloadPlaceStateType_Done:
return true
default:
INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control)
return true
}
return true
}
"
362,Arducopter\mode_auto.cpp_verify_loiter_unlimited,"bool ModeAuto::verify_loiter_unlimited()
{
return false
}
"
363,Arducopter\mode_auto.cpp_verify_loiter_time,"bool ModeAuto::verify_loiter_time(const AP_Mission::Mission_Command& cmd)
{
if (!copter.wp_nav->reached_wp_destination()) {
return false
}

if ( loiter_time == 0 ) {
loiter_time = millis()
}

if (((millis() - loiter_time) / 1000) >= loiter_time_max) {
gcs().send_text(MAV_SEVERITY_INFO, ""Reached command #%i"",cmd.index)
return true
}

return false
}
"
364,Arducopter\mode_auto.cpp_verify_loiter_to_alt,"bool ModeAuto::verify_loiter_to_alt() const
{
if (loiter_to_alt.reached_destination_xy &&
loiter_to_alt.reached_alt) {
return true
}
return false
}
"
365,Arducopter\mode_auto.cpp_verify_RTL,"bool ModeAuto::verify_RTL()
{
return (copter.mode_rtl.state_complete() &&
(copter.mode_rtl.state() == ModeRTL::SubMode::FINAL_DESCENT || copter.mode_rtl.state() == ModeRTL::SubMode::LAND) &&
(motors->get_spool_state() == AP_Motors::SpoolState::GROUND_IDLE))
}
"
366,Arducopter\mode_auto.cpp_verify_wait_delay,"bool ModeAuto::verify_wait_delay()
{
if (millis() - condition_start > (uint32_t)MAX(condition_value,0)) {
condition_value = 0
return true
}
return false
}
"
367,Arducopter\mode_auto.cpp_verify_within_distance,"bool ModeAuto::verify_within_distance()
{
if (wp_distance() < (uint32_t)MAX(condition_value,0)) {
condition_value = 0
return true
}
return false
}
"
368,Arducopter\mode_auto.cpp_verify_yaw,"bool ModeAuto::verify_yaw()
{
auto_yaw.set_mode(AUTO_YAW_FIXED)

return auto_yaw.fixed_yaw_slew_finished() && (fabsf(wrap_180_cd(ahrs.yaw_sensor-auto_yaw.yaw())) <= 200)
}
"
369,Arducopter\mode_auto.cpp_verify_nav_wp,"bool ModeAuto::verify_nav_wp(const AP_Mission::Mission_Command& cmd)
{
if ( !copter.wp_nav->reached_wp_destination() ) {
return false
}

if (loiter_time == 0) {
loiter_time = millis()
if (loiter_time_max > 0) {
AP_Notify::events.waypoint_complete = 1
}
}

if (((millis() - loiter_time) / 1000) >= loiter_time_max) {
if (loiter_time_max == 0) {
AP_Notify::events.waypoint_complete = 1
}
gcs().send_text(MAV_SEVERITY_INFO, ""Reached command #%i"",cmd.index)
return true
}
return false
}
"
370,Arducopter\mode_auto.cpp_verify_circle,"bool ModeAuto::verify_circle(const AP_Mission::Mission_Command& cmd)
{
if (_mode == SubMode::CIRCLE_MOVE_TO_EDGE) {
if (copter.wp_nav->reached_wp_destination()) {
circle_start()
}
return false
}

return fabsf(copter.circle_nav->get_angle_total()/float(M_2PI)) >= LOWBYTE(cmd.p1)
}
"
371,Arducopter\mode_auto.cpp_verify_spline_wp,"bool ModeAuto::verify_spline_wp(const AP_Mission::Mission_Command& cmd)
{
if ( !copter.wp_nav->reached_wp_destination() ) {
return false
}

if (loiter_time == 0) {
loiter_time = millis()
}

if (((millis() - loiter_time) / 1000) >= loiter_time_max) {
gcs().send_text(MAV_SEVERITY_INFO, ""Reached command #%i"",cmd.index)
return true
}
return false
}
"
372,Arducopter\mode_auto.cpp_verify_nav_guided_enable,"bool ModeAuto::verify_nav_guided_enable(const AP_Mission::Mission_Command& cmd)
{
if (cmd.p1 == 0) {
return true
}

return copter.mode_guided.limit_check()
}
"
373,Arducopter\mode_auto.cpp_verify_nav_delay,"bool ModeAuto::verify_nav_delay(const AP_Mission::Mission_Command& cmd)
{
if (millis() - nav_delay_time_start_ms > nav_delay_time_max_ms) {
nav_delay_time_max_ms = 0
return true
}
return false
}
"
374,Arducopter\mode_auto.cpp_verify_nav_script_time,"bool ModeAuto::verify_nav_script_time()
{
if (nav_scripting.done ||
((nav_scripting.timeout_s > 0) &&
(AP_HAL::millis() - nav_scripting.start_ms) > (nav_scripting.timeout_s * 1000))) {
return true
}
return false
}
"
375,Arducopter\mode_auto.cpp_verify_nav_attitude_time,"bool ModeAuto::verify_nav_attitude_time(const AP_Mission::Mission_Command& cmd)
{
return ((AP_HAL::millis() - nav_attitude_time.start_ms) > (cmd.content.nav_attitude_time.time_sec * 1000))
}
"
376,Arducopter\mode_auto.cpp_pause,"bool ModeAuto::pause()
{
if(wp_nav->paused() || _mode != SubMode::WP || wp_nav->reached_wp_destination()) {
return false
}

wp_nav->set_pause()
return true
}
"
377,Arducopter\mode_auto.cpp_resume,"bool ModeAuto::resume()
{
if(!wp_nav->paused()) {
return false
}

wp_nav->set_resume()
return true
}
"
378,Arducopter\mode_autorotate.cpp_init,"bool ModeAutorotate::init(bool ignore_checks)
{
return false

if (!g2.arot.is_enable()) {
gcs().send_text(MAV_SEVERITY_INFO, ""Autorot Mode Not Enabled"")
return false
}

if (motors->get_interlock()) {
gcs().send_text(MAV_SEVERITY_INFO, ""Autorot Mode Change Fail: Interlock Engaged"")
return false
}

g2.arot.init_hs_controller()
g2.arot.init_fwd_spd_controller()

_initial_rpm = g2.arot.get_rpm(true)

gcs().send_text(MAV_SEVERITY_INFO, ""Autorotation initiated"")

_flags.entry_initial = 1
_flags.ss_glide_initial = 1
_flags.flare_initial = 1
_flags.touch_down_initial = 1
_flags.level_initial = 1
_flags.break_initial = 1
_flags.straight_ahead_initial = 1
_flags.bail_out_initial = 1
_msg_flags.bad_rpm = true

phase_switch = Autorotation_Phase::ENTRY

_entry_time_start_ms = millis()

_hs_decay = ((_initial_rpm/g2.arot.get_hs_set_point()) - HEAD_SPEED_TARGET_RATIO) / AUTOROTATE_ENTRY_TIME

return true
}
"
379,Arducopter\mode_autorotate.cpp_run,"void ModeAutorotate::run()
{
if (motors->get_interlock() && !copter.ap.land_complete) {
phase_switch = Autorotation_Phase::BAIL_OUT
} else if (motors->get_interlock() && copter.ap.land_complete) {
set_mode(copter.prev_control_mode, ModeReason::AUTOROTATION_BAILOUT)
}

uint32_t now = millis()

float curr_vel_z = inertial_nav.get_velocity_z_up_cms()


nav_pos_switch = Navigation_Decision::USER_CONTROL_STABILISED

if (phase_switch == Autorotation_Phase::ENTRY){

if ((now - _entry_time_start_ms)/1000.0f > AUTOROTATE_ENTRY_TIME) {
phase_switch = Autorotation_Phase::SS_GLIDE
}

}


switch (phase_switch) {

case Autorotation_Phase::ENTRY:
{
if (_flags.entry_initial == 1) {

gcs().send_text(MAV_SEVERITY_INFO, ""Entry Phase"")

g2.arot.set_col_cutoff_freq(g2.arot.get_col_entry_freq())

_target_head_speed = _initial_rpm/g2.arot.get_hs_set_point()

g2.arot.set_desired_fwd_speed()

_flags.entry_initial = 0

}

if (g2.arot.get_rpm() > HEAD_SPEED_TARGET_RATIO*1.005f  ||  g2.arot.get_rpm() < HEAD_SPEED_TARGET_RATIO*0.995f) {
_target_head_speed -= _hs_decay*G_Dt
} else {
_target_head_speed = HEAD_SPEED_TARGET_RATIO
}

g2.arot.set_target_head_speed(_target_head_speed)

g2.arot.set_dt(G_Dt)
g2.arot.update_forward_speed_controller()

_pitch_target = g2.arot.get_pitch()

_flags.bad_rpm = g2.arot.update_hs_glide_controller(G_Dt)

break
}

case Autorotation_Phase::SS_GLIDE:
{
if (_flags.ss_glide_initial == 1) {

gcs().send_text(MAV_SEVERITY_INFO, ""SS Glide Phase"")

g2.arot.set_col_cutoff_freq(g2.arot.get_col_glide_freq())

g2.arot.set_desired_fwd_speed()

_target_head_speed = HEAD_SPEED_TARGET_RATIO
g2.arot.set_target_head_speed(_target_head_speed)

_flags.ss_glide_initial = 0
}

g2.arot.set_dt(G_Dt)
g2.arot.update_forward_speed_controller()

_pitch_target = g2.arot.get_pitch()

_flags.bad_rpm = g2.arot.update_hs_glide_controller(G_Dt)

break
}

case Autorotation_Phase::FLARE:
case Autorotation_Phase::TOUCH_DOWN:
{
break
}

case Autorotation_Phase::BAIL_OUT:
{
if (_flags.bail_out_initial == 1) {

gcs().send_text(MAV_SEVERITY_INFO, ""Bailing Out of Autorotation"")

_bail_time = MAX(g2.arot.get_bail_time(),BAILOUT_MOTOR_RAMP_TIME+0.1f)

_bail_time_start_ms = now

_desired_v_z = curr_vel_z

if (!pos_control->is_active_z()) {
pos_control->relax_z_controller(g2.arot.get_last_collective())
}

const float pilot_spd_dn = -get_pilot_speed_dn()
const float pilot_spd_up = g.pilot_speed_up

float pilot_des_v_z = get_pilot_desired_climb_rate(channel_throttle->get_control_in())
pilot_des_v_z = constrain_float(pilot_des_v_z, pilot_spd_dn, pilot_spd_up)

_target_climb_rate_adjust = (curr_vel_z - pilot_des_v_z)/(_bail_time - BAILOUT_MOTOR_RAMP_TIME)

_target_pitch_adjust = _pitch_target/_bail_time

pos_control->set_max_speed_accel_z(curr_vel_z, pilot_spd_up, fabsf(_target_climb_rate_adjust))
pos_control->set_correction_speed_accel_z(curr_vel_z, pilot_spd_up, fabsf(_target_climb_rate_adjust))

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

_flags.bail_out_initial = 0
}

if ((now - _bail_time_start_ms)/1000.0f >= BAILOUT_MOTOR_RAMP_TIME) {
_desired_v_z -= _target_climb_rate_adjust*G_Dt
_pitch_target -= _target_pitch_adjust*G_Dt
}
pos_control->set_pos_target_z_from_climb_rate_cm(_desired_v_z)

pos_control->update_z_controller()

if ((now - _bail_time_start_ms)/1000.0f >= _bail_time) {
if (copter.prev_control_mode == Mode::Number::AUTO) {
set_mode(Mode::Number::ALT_HOLD, ModeReason::AUTOROTATION_BAILOUT)
} else {
set_mode(copter.prev_control_mode, ModeReason::AUTOROTATION_BAILOUT)
}
}

break
}
}


switch (nav_pos_switch) {

case Navigation_Decision::USER_CONTROL_STABILISED:
{
float pilot_roll, pilot_pitch
get_pilot_desired_lean_angles(pilot_roll, pilot_pitch, copter.aparm.angle_max, copter.aparm.angle_max)

float pilot_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())

attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(pilot_roll, _pitch_target, pilot_yaw_rate)
break
}

case Navigation_Decision::STRAIGHT_AHEAD:
case Navigation_Decision::INTO_WIND:
case Navigation_Decision::NEAREST_RALLY:
{
break
}
}

if (_flags.bad_rpm) {
warning_message(1)
}

} // End function run()
"
380,Arducopter\mode_autorotate.cpp_warning_message,"void ModeAutorotate::warning_message(uint8_t message_n)
{
switch (message_n) {
case 1:
{
if (_msg_flags.bad_rpm) {
gcs().send_text(MAV_SEVERITY_INFO, ""Warning: Poor RPM Sensor Health"")
gcs().send_text(MAV_SEVERITY_INFO, ""Action: Minimum Collective Applied"")
_msg_flags.bad_rpm = false
}
break
}
}
}
"
381,Arducopter\mode_autotune.cpp_init,"bool AutoTune::init()
{
if (!copter.flightmode->allows_autotune()) {
return false
}

if (copter.ap.throttle_zero) {
return false
}

if (!copter.motors->armed() || !copter.ap.auto_armed || copter.ap.land_complete) {
return false
}

bool position_hold = (copter.flightmode->mode_number() == Mode::Number::LOITER || copter.flightmode->mode_number() == Mode::Number::POSHOLD)

return init_internals(position_hold,
copter.attitude_control,
copter.pos_control,
copter.ahrs_view,
&copter.inertial_nav)
}
"
382,Arducopter\mode_autotune.cpp_run,"void AutoTune::run()
{
copter.update_simple_mode()

if (copter.ap.land_complete) {
float target_climb_rate = get_pilot_desired_climb_rate_cms()

if (target_climb_rate < 0.0f) {
copter.motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE)
} else {
copter.motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)
}
copter.attitude_control->reset_rate_controller_I_terms_smoothly()
copter.attitude_control->reset_yaw_target_and_rate()

float target_roll, target_pitch, target_yaw_rate
get_pilot_desired_rp_yrate_cd(target_roll, target_pitch, target_yaw_rate)

copter.attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate)
copter.pos_control->relax_z_controller(0.0f)
copter.pos_control->update_z_controller()
} else {
AC_AutoTune::run()
}
}
"
383,Arducopter\mode_autotune.cpp_get_pilot_desired_climb_rate_cms,"float AutoTune::get_pilot_desired_climb_rate_cms(void) const
{
float target_climb_rate = copter.get_pilot_desired_climb_rate(copter.channel_throttle->get_control_in())

target_climb_rate = copter.mode_autotune.get_avoidance_adjusted_climbrate(target_climb_rate)

return target_climb_rate
}
"
384,Arducopter\mode_autotune.cpp_get_pilot_desired_rp_yrate_cd,"void AutoTune::get_pilot_desired_rp_yrate_cd(float &des_roll_cd, float &des_pitch_cd, float &yaw_rate_cds)
{
copter.mode_autotune.get_pilot_desired_lean_angles(des_roll_cd, des_pitch_cd, copter.aparm.angle_max,
copter.attitude_control->get_althold_lean_angle_max_cd())
yaw_rate_cds = copter.mode_autotune.get_pilot_desired_yaw_rate(copter.channel_yaw->norm_input_dz())
}
"
385,Arducopter\mode_autotune.cpp_init_z_limits,"void AutoTune::init_z_limits()
{
copter.pos_control->set_max_speed_accel_z(-copter.get_pilot_speed_dn(), copter.g.pilot_speed_up, copter.g.pilot_accel_z)
copter.pos_control->set_correction_speed_accel_z(-copter.get_pilot_speed_dn(), copter.g.pilot_speed_up, copter.g.pilot_accel_z)
}
"
386,Arducopter\mode_autotune.cpp_log_pids,"void AutoTune::log_pids()
{
copter.logger.Write_PID(LOG_PIDR_MSG, copter.attitude_control->get_rate_roll_pid().get_pid_info())
copter.logger.Write_PID(LOG_PIDP_MSG, copter.attitude_control->get_rate_pitch_pid().get_pid_info())
copter.logger.Write_PID(LOG_PIDY_MSG, copter.attitude_control->get_rate_yaw_pid().get_pid_info())
}
"
387,Arducopter\mode_autotune.cpp_position_ok,"bool AutoTune::position_ok()
{
return copter.position_ok()
}
"
388,Arducopter\mode_autotune.cpp_init,"bool ModeAutoTune::init(bool ignore_checks)
{
return autotune.init()
}
"
389,Arducopter\mode_autotune.cpp_run,"void ModeAutoTune::run()
{
autotune.run()
}
"
390,Arducopter\mode_autotune.cpp_save_tuning_gains,"void ModeAutoTune::save_tuning_gains()
{
autotune.save_tuning_gains()
}
"
391,Arducopter\mode_autotune.cpp_exit,"void ModeAutoTune::exit()
{
autotune.stop()
}
"
392,Arducopter\mode_autotune.cpp_reset,"void ModeAutoTune::reset()
{
autotune.reset()
}
"
393,Arducopter\mode_avoid_adsb.cpp_init,"bool ModeAvoidADSB::init(const bool ignore_checks)
{
return ModeGuided::init(ignore_checks)
}
"
394,Arducopter\mode_avoid_adsb.cpp_set_velocity,"bool ModeAvoidADSB::set_velocity(const Vector3f& velocity_neu)
{
if (copter.flightmode->mode_number() != Mode::Number::AVOID_ADSB) {
return false
}

ModeGuided::set_velocity(velocity_neu)
return true
}
"
395,Arducopter\mode_avoid_adsb.cpp_run,"void ModeAvoidADSB::run()
{
ModeGuided::run()
}
"
396,Arducopter\mode_brake.cpp_init,"bool ModeBrake::init(bool ignore_checks)
{
pos_control->set_max_speed_accel_xy(inertial_nav.get_velocity_neu_cms().length(), BRAKE_MODE_DECEL_RATE)
pos_control->set_correction_speed_accel_xy(inertial_nav.get_velocity_neu_cms().length(), BRAKE_MODE_DECEL_RATE)

pos_control->init_xy_controller()

pos_control->set_max_speed_accel_z(BRAKE_MODE_SPEED_Z, BRAKE_MODE_SPEED_Z, BRAKE_MODE_DECEL_RATE)
pos_control->set_correction_speed_accel_z(BRAKE_MODE_SPEED_Z, BRAKE_MODE_SPEED_Z, BRAKE_MODE_DECEL_RATE)

if (!pos_control->is_active_z()) {
pos_control->init_z_controller()
}

_timeout_ms = 0

return true
}
"
397,Arducopter\mode_brake.cpp_run,"void ModeBrake::run()
{
if (is_disarmed_or_landed()) {
make_safe_ground_handling()
pos_control->relax_z_controller(0.0f)
return
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

if (copter.ap.land_complete_maybe) {
pos_control->soften_for_landing_xy()
}

Vector2f vel
Vector2f accel
pos_control->input_vel_accel_xy(vel, accel)
pos_control->update_xy_controller()

attitude_control->input_thrust_vector_rate_heading(pos_control->get_thrust_vector(), 0.0f)

pos_control->set_pos_target_z_from_climb_rate_cm(0.0f)
pos_control->update_z_controller()

if (_timeout_ms != 0 && millis()-_timeout_start >= _timeout_ms) {
if (!copter.set_mode(Mode::Number::LOITER, ModeReason::BRAKE_TIMEOUT)) {
copter.set_mode(Mode::Number::ALT_HOLD, ModeReason::BRAKE_TIMEOUT)
}
}
}
"
398,Arducopter\mode_brake.cpp_timeout_to_loiter_ms,"void ModeBrake::timeout_to_loiter_ms(uint32_t timeout_ms)
{
_timeout_start = millis()
_timeout_ms = timeout_ms
}
"
399,Arducopter\mode_circle.cpp_init,"bool ModeCircle::init(bool ignore_checks)
{
pilot_yaw_override = false
speed_changing = false

pos_control->set_max_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_wp_acceleration())
pos_control->set_correction_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_wp_acceleration())
pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)
pos_control->set_correction_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)

copter.circle_nav->init()

return true
}
"
400,Arducopter\mode_circle.cpp_run,"void ModeCircle::run()
{
pos_control->set_max_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_wp_acceleration())
pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)

float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
if (!is_zero(target_yaw_rate)) {
pilot_yaw_override = true
}

copter.circle_nav->check_param_change()

if (!copter.failsafe.radio && copter.circle_nav->pilot_control_enabled()) {
const float radius_current = copter.circle_nav->get_radius()
const float pitch_stick = channel_pitch->norm_input_dz()
const float nav_speed = copter.wp_nav->get_default_speed_xy()
const float radius_pilot_change = (pitch_stick * nav_speed) * G_Dt
const float radius_new = MAX(radius_current + radius_pilot_change,0)

if (!is_equal(radius_current, radius_new)) {
copter.circle_nav->set_radius_cm(radius_new)
}

if (g.radio_tuning != TUNING_CIRCLE_RATE) {
const float roll_stick = channel_roll->norm_input_dz()

if (is_zero(roll_stick)) {
speed_changing = false
} else {
const float rate = copter.circle_nav->get_rate()
const float rate_current = copter.circle_nav->get_rate_current()
const float rate_pilot_change = (roll_stick * G_Dt)
float rate_new = rate_current
if (is_positive(rate)) {
rate_new = constrain_float(rate_current + rate_pilot_change, 0, 90)

} else if (is_negative(rate)) {
rate_new = constrain_float(rate_current + rate_pilot_change, -90, 0)

} else if (is_zero(rate) && !speed_changing) {
rate_new = rate_pilot_change
}

speed_changing = true
copter.circle_nav->set_rate(rate_new)
}
}
}

float target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->get_control_in())

target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate)

if (is_disarmed_or_landed()) {
make_safe_ground_handling()
return
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

copter.surface_tracking.update_surface_offset()

copter.failsafe_terrain_set_status(copter.circle_nav->update(target_climb_rate))

if (pilot_yaw_override) {
attitude_control->input_thrust_vector_rate_heading(copter.circle_nav->get_thrust_vector(), target_yaw_rate)
} else {
attitude_control->input_thrust_vector_heading(copter.circle_nav->get_thrust_vector(), copter.circle_nav->get_yaw())
}
pos_control->update_z_controller()
}
"
401,Arducopter\mode_circle.cpp_wp_distance,"uint32_t ModeCircle::wp_distance() const
{
return copter.circle_nav->get_distance_to_target()
}
"
402,Arducopter\mode_circle.cpp_wp_bearing,"int32_t ModeCircle::wp_bearing() const
{
return copter.circle_nav->get_bearing_to_target()
}
"
403,Arducopter\mode_drift.cpp_init,"bool ModeDrift::init(bool ignore_checks)
{
return true
}
"
404,Arducopter\mode_drift.cpp_run,"void ModeDrift::run()
{
static float braker = 0.0f
static float roll_input = 0.0f

float target_roll, target_pitch
get_pilot_desired_lean_angles(target_roll, target_pitch, copter.aparm.angle_max, copter.aparm.angle_max)

const Vector3f& vel = inertial_nav.get_velocity_neu_cms()

float roll_vel =  vel.y * ahrs.cos_yaw() - vel.x * ahrs.sin_yaw()
float pitch_vel = vel.y * ahrs.sin_yaw() + vel.x * ahrs.cos_yaw()

float pitch_vel2 = MIN(fabsf(pitch_vel), 2000)
float target_yaw_rate = target_roll * (1.0f - (pitch_vel2 / 5000.0f)) * g2.command_model_acro_y.get_rate() / 45.0

roll_vel = constrain_float(roll_vel, -DRIFT_SPEEDLIMIT, DRIFT_SPEEDLIMIT)
pitch_vel = constrain_float(pitch_vel, -DRIFT_SPEEDLIMIT, DRIFT_SPEEDLIMIT)

roll_input = roll_input * .96f + (float)channel_yaw->get_control_in() * .04f

float roll_vel_error = roll_vel - (roll_input / DRIFT_SPEEDGAIN)

target_roll = roll_vel_error * -DRIFT_SPEEDGAIN
target_roll = constrain_float(target_roll, -4500.0f, 4500.0f)

if (is_zero(target_pitch)) {
braker += .03f
braker = MIN(braker, DRIFT_SPEEDGAIN)
target_pitch = pitch_vel * braker
} else {
braker = 0.0f
}

if (!motors->armed()) {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::SHUT_DOWN)
} else if (copter.ap.throttle_zero) {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE)
} else {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)
}

switch (motors->get_spool_state()) {
case AP_Motors::SpoolState::SHUT_DOWN:
attitude_control->reset_yaw_target_and_rate(false)
attitude_control->reset_rate_controller_I_terms()
break

case AP_Motors::SpoolState::GROUND_IDLE:
attitude_control->reset_yaw_target_and_rate()
attitude_control->reset_rate_controller_I_terms_smoothly()
break

case AP_Motors::SpoolState::THROTTLE_UNLIMITED:
if (!motors->limit.throttle_lower) {
set_land_complete(false)
}
break

case AP_Motors::SpoolState::SPOOLING_UP:
case AP_Motors::SpoolState::SPOOLING_DOWN:
break
}

attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate)

const float assisted_throttle = get_throttle_assist(vel.z, get_pilot_desired_throttle())
attitude_control->set_throttle_out(assisted_throttle, true, g.throttle_filt)
}
"
405,Arducopter\mode_drift.cpp_get_throttle_assist,"float ModeDrift::get_throttle_assist(float velz, float pilot_throttle_scaled)
{
float thr_assist = 0.0f
if (pilot_throttle_scaled > DRIFT_THR_MIN && pilot_throttle_scaled < DRIFT_THR_MAX) {
thr_assist = 1.2f - ((float)fabsf(pilot_throttle_scaled - 0.5f) / 0.24f)
thr_assist = constrain_float(thr_assist, 0.0f, 1.0f) * -DRIFT_THR_ASSIST_GAIN * velz

thr_assist = constrain_float(thr_assist, -DRIFT_THR_ASSIST_MAX, DRIFT_THR_ASSIST_MAX)
}

return constrain_float(pilot_throttle_scaled + thr_assist, 0.0f, 1.0f)
}
"
406,Arducopter\mode_flip.cpp_init,"bool ModeFlip::init(bool ignore_checks)
{
if (!copter.flightmode->allows_flip()) {
return false
}

if (copter.ap.throttle_zero && (copter.flightmode->mode_number() == Mode::Number::ACRO || copter.flightmode->mode_number() == Mode::Number::STABILIZE)) {
return false
}

if (abs(channel_roll->get_control_in()) >= 4000) {
return false
}

if (!motors->armed() || copter.ap.land_complete) {
return false
}

orig_control_mode = copter.flightmode->mode_number()

_state = FlipState::Start
start_time_ms = millis()

roll_dir = pitch_dir = 0

if (channel_pitch->get_control_in() > 300) {
pitch_dir = FLIP_PITCH_BACK
} else if (channel_pitch->get_control_in() < -300) {
pitch_dir = FLIP_PITCH_FORWARD
} else if (channel_roll->get_control_in() >= 0) {
roll_dir = FLIP_ROLL_RIGHT
} else {
roll_dir = FLIP_ROLL_LEFT
}

AP::logger().Write_Event(LogEvent::FLIP_START)

const float angle_max = copter.aparm.angle_max
orig_attitude.x = constrain_float(ahrs.roll_sensor, -angle_max, angle_max)
orig_attitude.y = constrain_float(ahrs.pitch_sensor, -angle_max, angle_max)
orig_attitude.z = ahrs.yaw_sensor

return true
}
"
407,Arducopter\mode_flip.cpp_run,"void ModeFlip::run()
{
if (!motors->armed() || (abs(channel_roll->get_control_in()) >= 4000) || (abs(channel_pitch->get_control_in()) >= 4000) || ((millis() - start_time_ms) > FLIP_TIMEOUT_MS)) {
_state = FlipState::Abandon
}

float throttle_out = get_pilot_desired_throttle()

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

int32_t flip_angle

if (roll_dir != 0) {
flip_angle = ahrs.roll_sensor * roll_dir
} else {
flip_angle = ahrs.pitch_sensor * pitch_dir
}

switch (_state) {

case FlipState::Start:
attitude_control->input_rate_bf_roll_pitch_yaw(FLIP_ROTATION_RATE * roll_dir, FLIP_ROTATION_RATE * pitch_dir, 0.0)

throttle_out += FLIP_THR_INC

if (flip_angle >= 4500) {
if (roll_dir != 0) {
_state = FlipState::Roll
} else {
_state = FlipState::Pitch_A
}
}
break

case FlipState::Roll:
attitude_control->input_rate_bf_roll_pitch_yaw(FLIP_ROTATION_RATE * roll_dir, 0.0, 0.0)
throttle_out = MAX(throttle_out - FLIP_THR_DEC, 0.0f)

if ((flip_angle < 4500) && (flip_angle > -9000)) {
_state = FlipState::Recover
}
break

case FlipState::Pitch_A:
attitude_control->input_rate_bf_roll_pitch_yaw(0.0f, FLIP_ROTATION_RATE * pitch_dir, 0.0)
throttle_out = MAX(throttle_out - FLIP_THR_DEC, 0.0f)

if ((labs(ahrs.roll_sensor) > 9000) && (flip_angle > 4500)) {
_state = FlipState::Pitch_B
}
break

case FlipState::Pitch_B:
attitude_control->input_rate_bf_roll_pitch_yaw(0.0, FLIP_ROTATION_RATE * pitch_dir, 0.0)
throttle_out = MAX(throttle_out - FLIP_THR_DEC, 0.0f)

if ((labs(ahrs.roll_sensor) < 9000) && (flip_angle > -4500)) {
_state = FlipState::Recover
}
break

case FlipState::Recover: {
attitude_control->input_euler_angle_roll_pitch_yaw(orig_attitude.x, orig_attitude.y, orig_attitude.z, false)

throttle_out += FLIP_THR_INC

float recovery_angle
if (roll_dir != 0) {
recovery_angle = fabsf(orig_attitude.x - (float)ahrs.roll_sensor)
} else {
recovery_angle = fabsf(orig_attitude.y - (float)ahrs.pitch_sensor)
}

if (fabsf(recovery_angle) <= FLIP_RECOVERY_ANGLE) {
if (!copter.set_mode(orig_control_mode, ModeReason::FLIP_COMPLETE)) {
copter.set_mode(Mode::Number::STABILIZE, ModeReason::UNKNOWN)
}
AP::logger().Write_Event(LogEvent::FLIP_END)
}
break

}
case FlipState::Abandon:
if (!copter.set_mode(orig_control_mode, ModeReason::FLIP_COMPLETE)) {
copter.set_mode(Mode::Number::STABILIZE, ModeReason::UNKNOWN)
}
AP::logger().Write_Error(LogErrorSubsystem::FLIP, LogErrorCode::FLIP_ABANDONED)
break
}

attitude_control->set_throttle_out(throttle_out, false, g.throttle_filt)
}
"
408,Arducopter\mode_flowhold.cpp_ModeFlowHold,"ModeFlowHold::ModeFlowHold(void) : Mode()
{
AP_Param::setup_object_defaults(this, var_info)
}
"
409,Arducopter\mode_flowhold.cpp_init,"bool ModeFlowHold::init(bool ignore_checks)
{
if (!copter.optflow.enabled() || !copter.optflow.healthy()) {
return false
}

pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)
pos_control->set_correction_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)

if (!copter.pos_control->is_active_z()) {
pos_control->init_z_controller()
}

flow_filter.set_cutoff_frequency(copter.scheduler.get_loop_rate_hz(), flow_filter_hz.get())

quality_filtered = 0
flow_pi_xy.reset_I()
limited = false

flow_pi_xy.set_dt(1.0/copter.scheduler.get_loop_rate_hz())

last_ins_height = copter.inertial_nav.get_position_z_up_cm() * 0.01
height_offset = 0

return true
}
"
410,Arducopter\mode_flowhold.cpp_flowhold_flow_to_angle,"void ModeFlowHold::flowhold_flow_to_angle(Vector2f &bf_angles, bool stick_input)
{
uint32_t now = AP_HAL::millis()

Vector2f raw_flow = copter.optflow.flowRate() - copter.optflow.bodyRate()

raw_flow.x = constrain_float(raw_flow.x, -flow_max, flow_max)
raw_flow.y = constrain_float(raw_flow.y, -flow_max, flow_max)

Vector2f sensor_flow = flow_filter.apply(raw_flow)

float ins_height = copter.inertial_nav.get_position_z_up_cm() * 0.01
float height_estimate = ins_height + height_offset

sensor_flow *= constrain_float(height_estimate, height_min, height_max)

Vector2f input_ef = copter.ahrs.body_to_earth2D(sensor_flow)

flow_pi_xy.set_input(input_ef)

Vector2f ef_output

ef_output = flow_pi_xy.get_p()

if (stick_input) {
last_stick_input_ms = now
braking = true
}
if (!stick_input && braking) {
if (now - last_stick_input_ms > 3000 || sensor_flow.length() < 0.3) {
braking = false
printf(""braking done at %u vel=%f\n"", now - last_stick_input_ms,
(double)sensor_flow.length())
}
}

if (!stick_input && !braking) {
if (limited) {
xy_I = flow_pi_xy.get_i_shrink()
} else {
xy_I = flow_pi_xy.get_pi()
}
}

if (!stick_input && braking) {
for (uint8_t i=0
float &velocity = sensor_flow[i]
float abs_vel_cms = fabsf(velocity)*100
const float brake_gain = (15.0f * brake_rate_dps.get() + 95.0f) * 0.01f
float lean_angle_cd = brake_gain * abs_vel_cms * (1.0f+500.0f/(abs_vel_cms+60.0f))
if (velocity < 0) {
lean_angle_cd = -lean_angle_cd
}
bf_angles[i] = lean_angle_cd
}
ef_output.zero()
}

ef_output += xy_I
ef_output *= copter.aparm.angle_max

bf_angles += copter.ahrs.earth_to_body2D(ef_output)

limited = fabsf(bf_angles.x) > copter.aparm.angle_max || fabsf(bf_angles.y) > copter.aparm.angle_max

bf_angles.x = constrain_float(bf_angles.x, -copter.aparm.angle_max, copter.aparm.angle_max)
bf_angles.y = constrain_float(bf_angles.y, -copter.aparm.angle_max, copter.aparm.angle_max)


if (log_counter++ % 20 == 0) {
AP::logger().WriteStreaming(""FHLD"", ""TimeUS,SFx,SFy,Ax,Ay,Qual,Ix,Iy"", ""Qfffffff"",
AP_HAL::micros64(),
(double)sensor_flow.x, (double)sensor_flow.y,
(double)bf_angles.x, (double)bf_angles.y,
(double)quality_filtered,
(double)xy_I.x, (double)xy_I.y)
}
}
"
411,Arducopter\mode_flowhold.cpp_run,"void ModeFlowHold::run()
{
update_height_estimate()

pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)

update_simple_mode()

if (!is_equal(flow_filter.get_cutoff_freq(), flow_filter_hz.get())) {
flow_filter.set_cutoff_frequency(flow_filter_hz.get())
}

float target_climb_rate = copter.get_pilot_desired_climb_rate(copter.channel_throttle->get_control_in())
target_climb_rate = constrain_float(target_climb_rate, -get_pilot_speed_dn(), copter.g.pilot_speed_up)

float target_yaw_rate = get_pilot_desired_yaw_rate(copter.channel_yaw->norm_input_dz())

AltHoldModeState flowhold_state = get_alt_hold_state(target_climb_rate)

if (copter.optflow.healthy()) {
const float filter_constant = 0.95
quality_filtered = filter_constant * quality_filtered + (1-filter_constant) * copter.optflow.quality()
} else {
quality_filtered = 0
}

switch (flowhold_state) {

case AltHold_MotorStopped:
copter.motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::SHUT_DOWN)
copter.attitude_control->reset_rate_controller_I_terms()
copter.attitude_control->reset_yaw_target_and_rate()
copter.pos_control->relax_z_controller(0.0f)
flow_pi_xy.reset_I()
break

case AltHold_Takeoff:
copter.motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

if (!takeoff.running()) {
takeoff.start(constrain_float(g.pilot_takeoff_alt,0.0f,1000.0f))
}

target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate)

takeoff.do_pilot_takeoff(target_climb_rate)
break

case AltHold_Landed_Ground_Idle:
attitude_control->reset_yaw_target_and_rate()
FALLTHROUGH

case AltHold_Landed_Pre_Takeoff:
attitude_control->reset_rate_controller_I_terms_smoothly()
pos_control->relax_z_controller(0.0f)
break

case AltHold_Flying:
copter.motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate)

copter.surface_tracking.update_surface_offset()

pos_control->set_pos_target_z_from_climb_rate_cm(target_climb_rate)
break
}

Vector2f bf_angles

int16_t roll_in = copter.channel_roll->get_control_in()
int16_t pitch_in = copter.channel_pitch->get_control_in()
float angle_max = copter.aparm.angle_max
get_pilot_desired_lean_angles(bf_angles.x, bf_angles.y, angle_max, attitude_control->get_althold_lean_angle_max_cd())

if (quality_filtered >= flow_min_quality &&
AP_HAL::millis() - copter.arm_time_ms > 3000) {
Vector2f flow_angles

flowhold_flow_to_angle(flow_angles, (roll_in != 0) || (pitch_in != 0))
flow_angles.x = constrain_float(flow_angles.x, -angle_max/2, angle_max/2)
flow_angles.y = constrain_float(flow_angles.y, -angle_max/2, angle_max/2)
bf_angles += flow_angles
}
bf_angles.x = constrain_float(bf_angles.x, -angle_max, angle_max)
bf_angles.y = constrain_float(bf_angles.y, -angle_max, angle_max)

copter.avoid.adjust_roll_pitch(bf_angles.x, bf_angles.y, copter.aparm.angle_max)

copter.attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(bf_angles.x, bf_angles.y, target_yaw_rate)

pos_control->update_z_controller()
}
"
412,Arducopter\mode_flowhold.cpp_update_height_estimate,"void ModeFlowHold::update_height_estimate(void)
{
float ins_height = copter.inertial_nav.get_position_z_up_cm() * 0.01

if (!hal.util->get_soft_armed() ||
copter.motors->get_desired_spool_state() != AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED ||
AP_HAL::millis() - copter.arm_time_ms < 1500) {
height_offset = -ins_height
last_ins_height = ins_height
return
}

Vector3f delta_vel
float delta_vel_dt
if (!copter.ins.get_delta_velocity(delta_vel, delta_vel_dt)) {
return
}

const Matrix3f &rotMat = copter.ahrs.get_rotation_body_to_ned()
delta_vel = rotMat * delta_vel
delta_velocity_ne.x += delta_vel.x
delta_velocity_ne.y += delta_vel.y

if (!copter.optflow.healthy()) {
last_flow_ms = AP_HAL::millis()
delta_velocity_ne.zero()
return
}

if (last_flow_ms == 0) {
last_flow_ms = copter.optflow.last_update()
delta_velocity_ne.zero()
height_offset = 0
return
}

if (copter.optflow.last_update() == last_flow_ms) {
return
}

Vector2f delta_vel_bf = copter.ahrs.earth_to_body2D(delta_velocity_ne)

Vector2f delta_vel_rate(-delta_vel_bf.y, delta_vel_bf.x)

Vector2f flow_rate_rps = copter.optflow.flowRate() - copter.optflow.bodyRate()

uint32_t dt_ms = copter.optflow.last_update() - last_flow_ms
if (dt_ms > 500) {
last_flow_ms = copter.optflow.last_update()
delta_velocity_ne.zero()
last_flow_rate_rps = flow_rate_rps
last_ins_height = ins_height
height_offset = 0
return
}

basic equation is:
height_m = delta_velocity_mps / delta_flowrate_rps

Vector2f delta_flowrate = flow_rate_rps - last_flow_rate_rps
last_flow_rate_rps = flow_rate_rps
last_flow_ms = copter.optflow.last_update()

update height estimate
const float min_velocity_change = 0.04
const float min_flow_change = 0.04
const float height_delta_max = 0.25

for each axis update the height estimate
float delta_height = 0
uint8_t total_weight = 0
float height_estimate = ins_height + height_offset

for (uint8_t i=0
float abs_flow = fabsf(delta_flowrate[i])
if (abs_flow < min_flow_change ||
fabsf(delta_vel_rate[i]) < min_velocity_change) {
continue
}
float height = delta_vel_rate[i] / delta_flowrate[i]
if (height <= 0) {
continue
}
delta_height += (height - height_estimate) * abs_flow
total_weight += abs_flow
}
if (total_weight > 0) {
delta_height /= total_weight
}

if (delta_height < 0) {
delta_height *= 2
}

float new_offset = height_offset + constrain_float(delta_height, -height_delta_max, height_delta_max)

height_offset = 0.8 * height_offset + 0.2 * new_offset

if (ins_height + height_offset < height_min) {
height_offset = height_min - ins_height
}

height_estimate = ins_height + height_offset


AP::logger().WriteStreaming(""FHXY"", ""TimeUS,DFx,DFy,DVx,DVy,Hest,DH,Hofs,InsH,LastInsH,DTms"", ""QfffffffffI"",
AP_HAL::micros64(),
(double)delta_flowrate.x,
(double)delta_flowrate.y,
(double)delta_vel_rate.x,
(double)delta_vel_rate.y,
(double)height_estimate,
(double)delta_height,
(double)height_offset,
(double)ins_height,
(double)last_ins_height,
dt_ms)
gcs().send_named_float(""HEST"", height_estimate)
delta_velocity_ne.zero()
last_ins_height = ins_height
}
"
413,Arducopter\mode_follow.cpp_init,"bool ModeFollow::init(const bool ignore_checks)
{
if (!g2.follow.enabled()) {
gcs().send_text(MAV_SEVERITY_WARNING, ""Set FOLL_ENABLE = 1"")
return false
}
return ModeGuided::init(ignore_checks)
}
"
414,Arducopter\mode_follow.cpp_exit,"void ModeFollow::exit()
{
g2.follow.clear_offsets_if_required()
}
"
415,Arducopter\mode_follow.cpp_run,"void ModeFollow::run()
{
if (is_disarmed_or_landed()) {
make_safe_ground_handling()
return
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)


Vector3f desired_velocity_neu_cms
bool use_yaw = false
float yaw_cd = 0.0f

Vector3f dist_vec
Vector3f dist_vec_offs
Vector3f vel_of_target
if (g2.follow.get_target_dist_and_vel_ned(dist_vec, dist_vec_offs, vel_of_target)) {
const Vector3f dist_vec_offs_neu(dist_vec_offs.x * 100.0f, dist_vec_offs.y * 100.0f, -dist_vec_offs.z * 100.0f)

const float kp = g2.follow.get_pos_p().kP()
desired_velocity_neu_cms.x = (vel_of_target.x * 100.0f) + (dist_vec_offs_neu.x * kp)
desired_velocity_neu_cms.y = (vel_of_target.y * 100.0f) + (dist_vec_offs_neu.y * kp)
desired_velocity_neu_cms.z = (-vel_of_target.z * 100.0f) + (dist_vec_offs_neu.z * kp)

float desired_speed_xy = safe_sqrt(sq(desired_velocity_neu_cms.x) + sq(desired_velocity_neu_cms.y))
if (!is_zero(desired_speed_xy) && (desired_speed_xy > pos_control->get_max_speed_xy_cms())) {
const float scalar_xy = pos_control->get_max_speed_xy_cms() / desired_speed_xy
desired_velocity_neu_cms.x *= scalar_xy
desired_velocity_neu_cms.y *= scalar_xy
desired_speed_xy = pos_control->get_max_speed_xy_cms()
}

desired_velocity_neu_cms.z = constrain_float(desired_velocity_neu_cms.z, -fabsf(pos_control->get_max_speed_down_cms()), pos_control->get_max_speed_up_cms())

Vector3f dir_to_target_neu = dist_vec_offs_neu
const float dir_to_target_neu_len = dir_to_target_neu.length()
if (!is_zero(dir_to_target_neu_len)) {
dir_to_target_neu /= dir_to_target_neu_len
}

Vector2f desired_velocity_xy_cms(desired_velocity_neu_cms.x, desired_velocity_neu_cms.y)

Vector2f dir_to_target_xy(desired_velocity_xy_cms.x, desired_velocity_xy_cms.y)
if (!dir_to_target_xy.is_zero()) {
dir_to_target_xy.normalize()
}

const float dist_to_target_xy = Vector2f(dist_vec_offs_neu.x, dist_vec_offs_neu.y).length()
copter.avoid.limit_velocity_2D(pos_control->get_pos_xy_p().kP().get(), pos_control->get_max_accel_xy_cmss() * 0.5f, desired_velocity_xy_cms, dir_to_target_xy, dist_to_target_xy, copter.G_Dt)
desired_velocity_neu_cms.x = desired_velocity_xy_cms.x
desired_velocity_neu_cms.y = desired_velocity_xy_cms.y

const float des_vel_z_max = copter.avoid.get_max_speed(pos_control->get_pos_z_p().kP().get(), pos_control->get_max_accel_z_cmss() * 0.5f, fabsf(dist_vec_offs_neu.z), copter.G_Dt)
desired_velocity_neu_cms.z = constrain_float(desired_velocity_neu_cms.z, -des_vel_z_max, des_vel_z_max)

copter.avoid.adjust_velocity(desired_velocity_neu_cms, pos_control->get_pos_xy_p().kP().get(), pos_control->get_max_accel_xy_cmss(), pos_control->get_pos_z_p().kP().get(), pos_control->get_max_accel_z_cmss(), G_Dt)

switch (g2.follow.get_yaw_behave()) {
case AP_Follow::YAW_BEHAVE_FACE_LEAD_VEHICLE: {
if (dist_vec.xy().length_squared() > 1.0) {
yaw_cd = get_bearing_cd(Vector2f{}, dist_vec.xy())
use_yaw = true
}
break
}

case AP_Follow::YAW_BEHAVE_SAME_AS_LEAD_VEHICLE: {
float target_hdg = 0.0f
if (g2.follow.get_target_heading_deg(target_hdg)) {
yaw_cd = target_hdg * 100.0f
use_yaw = true
}
break
}

case AP_Follow::YAW_BEHAVE_DIR_OF_FLIGHT: {
if (desired_velocity_neu_cms.xy().length_squared() > (100.0 * 100.0)) {
yaw_cd = get_bearing_cd(Vector2f{}, desired_velocity_neu_cms.xy())
use_yaw = true
}
break
}

case AP_Follow::YAW_BEHAVE_NONE:
default:
break

}
}

uint32_t now = AP_HAL::millis()
bool log_request = false
if ((now - last_log_ms >= 100) || (last_log_ms == 0)) {
log_request = true
last_log_ms = now
}
ModeGuided::set_velocity(desired_velocity_neu_cms, use_yaw, yaw_cd, false, 0.0f, false, log_request)

ModeGuided::run()
}
"
416,Arducopter\mode_follow.cpp_wp_distance,"uint32_t ModeFollow::wp_distance() const
{
return g2.follow.get_distance_to_target() * 100
}
"
417,Arducopter\mode_follow.cpp_wp_bearing,"int32_t ModeFollow::wp_bearing() const
{
return g2.follow.get_bearing_to_target() * 100
}
"
418,Arducopter\mode_follow.cpp_get_wp,"bool ModeFollow::get_wp(Location &loc) const
{
float dist = g2.follow.get_distance_to_target()
float bearing = g2.follow.get_bearing_to_target()
loc = copter.current_loc
loc.offset_bearing(bearing, dist)
return true
}
"
419,Arducopter\mode_guided.cpp_init,"bool ModeGuided::init(bool ignore_checks)
{
velaccel_control_start()
guided_vel_target_cms.zero()
guided_accel_target_cmss.zero()
send_notification = false

_paused = false

return true
}
"
420,Arducopter\mode_guided.cpp_run,"void ModeGuided::run()
{
if (_paused) {
pause_control_run()
return
}

switch (guided_mode) {

case SubMode::TakeOff:
takeoff_run()
break

case SubMode::WP:
wp_control_run()
if (send_notification && wp_nav->reached_wp_destination()) {
send_notification = false
gcs().send_mission_item_reached_message(0)
}
break

case SubMode::Pos:
pos_control_run()
break

case SubMode::Accel:
accel_control_run()
break

case SubMode::VelAccel:
velaccel_control_run()
break

case SubMode::PosVelAccel:
posvelaccel_control_run()
break

case SubMode::Angle:
angle_control_run()
break
}
}
"
421,Arducopter\mode_guided.cpp_allows_arming,"bool ModeGuided::allows_arming(AP_Arming::Method method) const
{
if (method == AP_Arming::Method::MAVLINK) {
return true
}

return (copter.g2.guided_options & (uint32_t)Options::AllowArmingFromTX) != 0
}
"
422,Arducopter\mode_guided.cpp_do_user_takeoff_start,"bool ModeGuided::do_user_takeoff_start(float takeoff_alt_cm)
{
int32_t alt_target_cm
bool alt_target_terrain = false
if (wp_nav->rangefinder_used_and_healthy() &&
wp_nav->get_terrain_source() == AC_WPNav::TerrainSource::TERRAIN_FROM_RANGEFINDER &&
takeoff_alt_cm < copter.rangefinder.max_distance_cm_orient(ROTATION_PITCH_270)) {
if (takeoff_alt_cm <= copter.rangefinder_state.alt_cm) {
return false
}
alt_target_cm = takeoff_alt_cm
alt_target_terrain = true
} else {
Location target_loc = copter.current_loc
target_loc.set_alt_cm(takeoff_alt_cm, Location::AltFrame::ABOVE_HOME)

if (!target_loc.get_alt_cm(Location::AltFrame::ABOVE_ORIGIN, alt_target_cm)) {
return false
}
}

guided_mode = SubMode::TakeOff

auto_yaw.set_mode(AUTO_YAW_HOLD)

pos_control->init_z_controller()

auto_takeoff_start(alt_target_cm, alt_target_terrain)

takeoff_complete = false

return true
}
"
423,Arducopter\mode_guided.cpp_wp_control_start,"void ModeGuided::wp_control_start()
{
guided_mode = SubMode::WP

wp_nav->wp_and_spline_init()

Vector3f stopping_point
wp_nav->get_wp_stopping_point(stopping_point)
if (!wp_nav->set_wp_destination(stopping_point, false)) {
INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control)
}

auto_yaw.set_mode_to_default(false)
}
"
424,Arducopter\mode_guided.cpp_wp_control_run,"void ModeGuided::wp_control_run()
{
float target_yaw_rate = 0
if (!copter.failsafe.radio && use_pilot_yaw()) {
target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
if (!is_zero(target_yaw_rate)) {
auto_yaw.set_mode(AUTO_YAW_HOLD)
}
}

if (is_disarmed_or_landed()) {
make_safe_ground_handling(copter.is_tradheli() && motors->get_interlock())
return
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

copter.failsafe_terrain_set_status(wp_nav->update_wpnav())

pos_control->update_z_controller()

if (auto_yaw.mode() == AUTO_YAW_HOLD) {
attitude_control->input_thrust_vector_rate_heading(wp_nav->get_thrust_vector(), target_yaw_rate)
} else if (auto_yaw.mode() == AUTO_YAW_RATE) {
attitude_control->input_thrust_vector_rate_heading(wp_nav->get_thrust_vector(), auto_yaw.rate_cds())
} else {
attitude_control->input_thrust_vector_heading(wp_nav->get_thrust_vector(), auto_yaw.yaw())
}
}
"
425,Arducopter\mode_guided.cpp_pva_control_start,"void ModeGuided::pva_control_start()
{
pos_control->set_max_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_wp_acceleration())
pos_control->set_correction_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_wp_acceleration())

pos_control->set_max_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z())
pos_control->set_correction_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z())

pos_control->init_z_controller()
pos_control->init_xy_controller()

auto_yaw.set_mode_to_default(false)

guided_pos_terrain_alt = false
}
"
426,Arducopter\mode_guided.cpp_pos_control_start,"void ModeGuided::pos_control_start()
{
guided_mode = SubMode::Pos

pva_control_start()
}
"
427,Arducopter\mode_guided.cpp_accel_control_start,"void ModeGuided::accel_control_start()
{
guided_mode = SubMode::Accel

pva_control_start()
}
"
428,Arducopter\mode_guided.cpp_velaccel_control_start,"void ModeGuided::velaccel_control_start()
{
guided_mode = SubMode::VelAccel

pva_control_start()
}
"
429,Arducopter\mode_guided.cpp_posvelaccel_control_start,"void ModeGuided::posvelaccel_control_start()
{
guided_mode = SubMode::PosVelAccel

pva_control_start()
}
"
430,Arducopter\mode_guided.cpp_is_taking_off,"bool ModeGuided::is_taking_off() const
{
return guided_mode == SubMode::TakeOff && !takeoff_complete
}
"
431,Arducopter\mode_guided.cpp_set_speed_xy,"bool ModeGuided::set_speed_xy(float speed_xy_cms)
{
pos_control->set_max_speed_accel_xy(speed_xy_cms, wp_nav->get_wp_acceleration())
pos_control->set_correction_speed_accel_xy(speed_xy_cms, wp_nav->get_wp_acceleration())
return true
}
"
432,Arducopter\mode_guided.cpp_set_speed_up,"bool ModeGuided::set_speed_up(float speed_up_cms)
{
pos_control->set_max_speed_accel_z(wp_nav->get_default_speed_down(), speed_up_cms, wp_nav->get_accel_z())
pos_control->set_correction_speed_accel_z(wp_nav->get_default_speed_down(), speed_up_cms, wp_nav->get_accel_z())
return true
}
"
433,Arducopter\mode_guided.cpp_set_speed_down,"bool ModeGuided::set_speed_down(float speed_down_cms)
{
pos_control->set_max_speed_accel_z(speed_down_cms, wp_nav->get_default_speed_up(), wp_nav->get_accel_z())
pos_control->set_correction_speed_accel_z(speed_down_cms, wp_nav->get_default_speed_up(), wp_nav->get_accel_z())
return true
}
"
434,Arducopter\mode_guided.cpp_angle_control_start,"void ModeGuided::angle_control_start()
{
guided_mode = SubMode::Angle

pos_control->set_max_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z())
pos_control->set_correction_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z())

if (!pos_control->is_active_z()) {
pos_control->init_z_controller()
}

guided_angle_state.update_time_ms = millis()
guided_angle_state.attitude_quat.initialise()
guided_angle_state.ang_vel.zero()
guided_angle_state.climb_rate_cms = 0.0f
guided_angle_state.yaw_rate_cds = 0.0f
guided_angle_state.use_yaw_rate = false

auto_yaw.set_mode(AUTO_YAW_HOLD)
}
"
435,Arducopter\mode_guided.cpp_set_destination,"bool ModeGuided::set_destination(const Vector3f& destination, bool use_yaw, float yaw_cd, bool use_yaw_rate, float yaw_rate_cds, bool relative_yaw, bool terrain_alt)
{
const Location dest_loc(destination, terrain_alt ? Location::AltFrame::ABOVE_TERRAIN : Location::AltFrame::ABOVE_ORIGIN)
if (!copter.fence.check_destination_within_fence(dest_loc)) {
AP::logger().Write_Error(LogErrorSubsystem::NAVIGATION, LogErrorCode::DEST_OUTSIDE_FENCE)
return false
}

if (use_wpnav_for_position_control()) {
if (guided_mode != SubMode::WP) {
wp_control_start()
}

set_yaw_state(use_yaw, yaw_cd, use_yaw_rate, yaw_rate_cds, relative_yaw)

wp_nav->set_wp_destination(destination, terrain_alt)

copter.Log_Write_Guided_Position_Target(guided_mode, destination, terrain_alt, Vector3f(), Vector3f())
send_notification = true
return true
}

if (guided_mode != SubMode::Pos) {
pos_control_start()
}

if (terrain_alt) {
float origin_terr_offset
if (!wp_nav->get_terrain_offset(origin_terr_offset)) {
init(true)
return false
}
if (!guided_pos_terrain_alt) {
pos_control->set_pos_offset_z_cm(origin_terr_offset)
}
} else {
pos_control->set_pos_offset_z_cm(0.0)
}

set_yaw_state(use_yaw, yaw_cd, use_yaw_rate, yaw_rate_cds, relative_yaw)

guided_pos_target_cm = destination.topostype()
guided_pos_terrain_alt = terrain_alt
guided_vel_target_cms.zero()
guided_accel_target_cmss.zero()
update_time_ms = millis()

copter.Log_Write_Guided_Position_Target(guided_mode, guided_pos_target_cm.tofloat(), guided_pos_terrain_alt, guided_vel_target_cms, guided_accel_target_cmss)

send_notification = true

return true
}
"
436,Arducopter\mode_guided.cpp_get_wp,"bool ModeGuided::get_wp(Location& destination) const
{
switch (guided_mode) {
case SubMode::WP:
return wp_nav->get_oa_wp_destination(destination)
case SubMode::Pos:
destination = Location(guided_pos_target_cm.tofloat(), guided_pos_terrain_alt ? Location::AltFrame::ABOVE_TERRAIN : Location::AltFrame::ABOVE_ORIGIN)
return true
default:
return false
}

return false
}
"
437,Arducopter\mode_guided.cpp_set_destination,"bool ModeGuided::set_destination(const Location& dest_loc, bool use_yaw, float yaw_cd, bool use_yaw_rate, float yaw_rate_cds, bool relative_yaw)
{
if (!copter.fence.check_destination_within_fence(dest_loc)) {
AP::logger().Write_Error(LogErrorSubsystem::NAVIGATION, LogErrorCode::DEST_OUTSIDE_FENCE)
return false
}

if (use_wpnav_for_position_control()) {
if (guided_mode != SubMode::WP) {
wp_control_start()
}

if (!wp_nav->set_wp_destination_loc(dest_loc)) {
AP::logger().Write_Error(LogErrorSubsystem::NAVIGATION, LogErrorCode::FAILED_TO_SET_DESTINATION)
return false
}

set_yaw_state(use_yaw, yaw_cd, use_yaw_rate, yaw_rate_cds, relative_yaw)

copter.Log_Write_Guided_Position_Target(guided_mode, Vector3f(dest_loc.lat, dest_loc.lng, dest_loc.alt), (dest_loc.get_alt_frame() == Location::AltFrame::ABOVE_TERRAIN), Vector3f(), Vector3f())
send_notification = true
return true
}

if (guided_mode != SubMode::Pos) {
pos_control_start()
}

set_yaw_state(use_yaw, yaw_cd, use_yaw_rate, yaw_rate_cds, relative_yaw)

Vector3f pos_target_f
bool terrain_alt
if (!wp_nav->get_vector_NEU(dest_loc, pos_target_f, terrain_alt)) {
return false
}

if (terrain_alt) {
float origin_terr_offset
if (!wp_nav->get_terrain_offset(origin_terr_offset)) {
init(true)
return false
}
if (!guided_pos_terrain_alt) {
pos_control->set_pos_offset_z_cm(origin_terr_offset)
}
} else {
pos_control->set_pos_offset_z_cm(0.0)
}

guided_pos_target_cm = pos_target_f.topostype()
guided_pos_terrain_alt = terrain_alt
guided_vel_target_cms.zero()
guided_accel_target_cmss.zero()
update_time_ms = millis()

copter.Log_Write_Guided_Position_Target(guided_mode, Vector3f(dest_loc.lat, dest_loc.lng, dest_loc.alt), guided_pos_terrain_alt, guided_vel_target_cms, guided_accel_target_cmss)

send_notification = true

return true
}
"
438,Arducopter\mode_guided.cpp_set_accel,"void ModeGuided::set_accel(const Vector3f& acceleration, bool use_yaw, float yaw_cd, bool use_yaw_rate, float yaw_rate_cds, bool relative_yaw, bool log_request)
{
if (guided_mode != SubMode::Accel) {
accel_control_start()
}

set_yaw_state(use_yaw, yaw_cd, use_yaw_rate, yaw_rate_cds, relative_yaw)

guided_pos_target_cm.zero()
guided_pos_terrain_alt = false
guided_vel_target_cms.zero()
guided_accel_target_cmss = acceleration
update_time_ms = millis()

if (log_request) {
copter.Log_Write_Guided_Position_Target(guided_mode, guided_pos_target_cm.tofloat(), guided_pos_terrain_alt, guided_vel_target_cms, guided_accel_target_cmss)
}
}
"
439,Arducopter\mode_guided.cpp_set_velocity,"void ModeGuided::set_velocity(const Vector3f& velocity, bool use_yaw, float yaw_cd, bool use_yaw_rate, float yaw_rate_cds, bool relative_yaw, bool log_request)
{
set_velaccel(velocity, Vector3f(), use_yaw, yaw_cd, use_yaw_rate, yaw_rate_cds, relative_yaw, log_request)
}
"
440,Arducopter\mode_guided.cpp_set_velaccel,"void ModeGuided::set_velaccel(const Vector3f& velocity, const Vector3f& acceleration, bool use_yaw, float yaw_cd, bool use_yaw_rate, float yaw_rate_cds, bool relative_yaw, bool log_request)
{
if (guided_mode != SubMode::VelAccel) {
velaccel_control_start()
}

set_yaw_state(use_yaw, yaw_cd, use_yaw_rate, yaw_rate_cds, relative_yaw)

guided_pos_target_cm.zero()
guided_pos_terrain_alt = false
guided_vel_target_cms = velocity
guided_accel_target_cmss = acceleration
update_time_ms = millis()

if (log_request) {
copter.Log_Write_Guided_Position_Target(guided_mode, guided_pos_target_cm.tofloat(), guided_pos_terrain_alt, guided_vel_target_cms, guided_accel_target_cmss)
}
}
"
441,Arducopter\mode_guided.cpp_set_destination_posvel,"bool ModeGuided::set_destination_posvel(const Vector3f& destination, const Vector3f& velocity, bool use_yaw, float yaw_cd, bool use_yaw_rate, float yaw_rate_cds, bool relative_yaw)
{
return set_destination_posvelaccel(destination, velocity, Vector3f(), use_yaw, yaw_cd, use_yaw_rate, yaw_rate_cds, relative_yaw)
}
"
442,Arducopter\mode_guided.cpp_set_destination_posvelaccel,"bool ModeGuided::set_destination_posvelaccel(const Vector3f& destination, const Vector3f& velocity, const Vector3f& acceleration, bool use_yaw, float yaw_cd, bool use_yaw_rate, float yaw_rate_cds, bool relative_yaw)
{
const Location dest_loc(destination, Location::AltFrame::ABOVE_ORIGIN)
if (!copter.fence.check_destination_within_fence(dest_loc)) {
AP::logger().Write_Error(LogErrorSubsystem::NAVIGATION, LogErrorCode::DEST_OUTSIDE_FENCE)
return false
}

if (guided_mode != SubMode::PosVelAccel) {
posvelaccel_control_start()
}

set_yaw_state(use_yaw, yaw_cd, use_yaw_rate, yaw_rate_cds, relative_yaw)

update_time_ms = millis()
guided_pos_target_cm = destination.topostype()
guided_pos_terrain_alt = false
guided_vel_target_cms = velocity
guided_accel_target_cmss = acceleration

copter.Log_Write_Guided_Position_Target(guided_mode, guided_pos_target_cm.tofloat(), guided_pos_terrain_alt, guided_vel_target_cms, guided_accel_target_cmss)
return true
}
"
443,Arducopter\mode_guided.cpp_set_attitude_target_provides_thrust,"bool ModeGuided::set_attitude_target_provides_thrust() const
{
return ((copter.g2.guided_options.get() & uint32_t(Options::SetAttitudeTarget_ThrustAsThrust)) != 0)
}
"
444,Arducopter\mode_guided.cpp_stabilizing_pos_xy,"bool ModeGuided::stabilizing_pos_xy() const
{
return !((copter.g2.guided_options.get() & uint32_t(Options::DoNotStabilizePositionXY)) != 0)
}
"
445,Arducopter\mode_guided.cpp_stabilizing_vel_xy,"bool ModeGuided::stabilizing_vel_xy() const
{
return !((copter.g2.guided_options.get() & uint32_t(Options::DoNotStabilizeVelocityXY)) != 0)
}
"
446,Arducopter\mode_guided.cpp_use_wpnav_for_position_control,"bool ModeGuided::use_wpnav_for_position_control() const
{
return ((copter.g2.guided_options.get() & uint32_t(Options::WPNavUsedForPosControl)) != 0)
}
"
447,Arducopter\mode_guided.cpp_set_angle,"void ModeGuided::set_angle(const Quaternion &attitude_quat, const Vector3f &ang_vel, float climb_rate_cms_or_thrust, bool use_thrust)
{
if (guided_mode != SubMode::Angle) {
angle_control_start()
}

guided_angle_state.attitude_quat = attitude_quat
guided_angle_state.ang_vel = ang_vel

guided_angle_state.use_thrust = use_thrust
if (use_thrust) {
guided_angle_state.thrust = climb_rate_cms_or_thrust
guided_angle_state.climb_rate_cms = 0.0f
} else {
guided_angle_state.thrust = 0.0f
guided_angle_state.climb_rate_cms = climb_rate_cms_or_thrust
}

guided_angle_state.update_time_ms = millis()

float roll_rad, pitch_rad, yaw_rad
attitude_quat.to_euler(roll_rad, pitch_rad, yaw_rad)

copter.Log_Write_Guided_Attitude_Target(guided_mode, roll_rad, pitch_rad, yaw_rad, ang_vel, guided_angle_state.thrust, guided_angle_state.climb_rate_cms * 0.01)
}
"
448,Arducopter\mode_guided.cpp_takeoff_run,"void ModeGuided::takeoff_run()
{
auto_takeoff_run()
if (auto_takeoff_complete && !takeoff_complete) {
takeoff_complete = true
copter.landinggear.retract_after_takeoff()
}
}
"
449,Arducopter\mode_guided.cpp_pos_control_run,"void ModeGuided::pos_control_run()
{
float target_yaw_rate = 0

if (!copter.failsafe.radio && use_pilot_yaw()) {
target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
if (!is_zero(target_yaw_rate)) {
auto_yaw.set_mode(AUTO_YAW_HOLD)
}
}

if (is_disarmed_or_landed()) {
make_safe_ground_handling(copter.is_tradheli() && motors->get_interlock())
return
}

float terr_offset = 0.0f
if (guided_pos_terrain_alt && !wp_nav->get_terrain_offset(terr_offset)) {
copter.failsafe_terrain_on_event()
return
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

guided_accel_target_cmss.zero()
guided_vel_target_cms.zero()

if (millis() - update_time_ms > get_timeout_ms()) {
if ((auto_yaw.mode() == AUTO_YAW_RATE) || (auto_yaw.mode() == AUTO_YAW_ANGLE_RATE)) {
auto_yaw.set_rate(0.0f)
}
}

float pos_offset_z_buffer = 0.0
if (guided_pos_terrain_alt) {
pos_offset_z_buffer = MIN(copter.wp_nav->get_terrain_margin() * 100.0, 0.5 * fabsF(guided_pos_target_cm.z))
}
pos_control->input_pos_xyz(guided_pos_target_cm, terr_offset, pos_offset_z_buffer)

pos_control->update_xy_controller()
pos_control->update_z_controller()

if (auto_yaw.mode() == AUTO_YAW_HOLD) {
attitude_control->input_thrust_vector_rate_heading(pos_control->get_thrust_vector(), target_yaw_rate)
} else if (auto_yaw.mode() == AUTO_YAW_RATE) {
attitude_control->input_thrust_vector_rate_heading(pos_control->get_thrust_vector(), auto_yaw.rate_cds())
} else {
attitude_control->input_thrust_vector_heading(pos_control->get_thrust_vector(), auto_yaw.yaw(), auto_yaw.rate_cds())
}
}
"
450,Arducopter\mode_guided.cpp_accel_control_run,"void ModeGuided::accel_control_run()
{
float target_yaw_rate = 0
if (!copter.failsafe.radio && use_pilot_yaw()) {
target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
if (!is_zero(target_yaw_rate)) {
auto_yaw.set_mode(AUTO_YAW_HOLD)
}
}

if (is_disarmed_or_landed()) {
make_safe_ground_handling(copter.is_tradheli() && motors->get_interlock())
return
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

uint32_t tnow = millis()
if (tnow - update_time_ms > get_timeout_ms()) {
guided_vel_target_cms.zero()
guided_accel_target_cmss.zero()
if ((auto_yaw.mode() == AUTO_YAW_RATE) || (auto_yaw.mode() == AUTO_YAW_ANGLE_RATE)) {
auto_yaw.set_rate(0.0f)
}
pos_control->input_vel_accel_xy(guided_vel_target_cms.xy(), guided_accel_target_cmss.xy(), false)
pos_control->input_vel_accel_z(guided_vel_target_cms.z, guided_accel_target_cmss.z, false, false)
} else {
pos_control->input_accel_xy(guided_accel_target_cmss)
if (!stabilizing_vel_xy()) {
pos_control->stop_vel_xy_stabilisation()
} else if (!stabilizing_pos_xy()) {
pos_control->stop_pos_xy_stabilisation()
}
pos_control->input_accel_z(guided_accel_target_cmss.z)
}

pos_control->update_xy_controller()
pos_control->update_z_controller()

if (auto_yaw.mode() == AUTO_YAW_HOLD) {
attitude_control->input_thrust_vector_rate_heading(pos_control->get_thrust_vector(), target_yaw_rate)
} else if (auto_yaw.mode() == AUTO_YAW_RATE) {
attitude_control->input_thrust_vector_rate_heading(pos_control->get_thrust_vector(), auto_yaw.rate_cds())
} else {
attitude_control->input_thrust_vector_heading(pos_control->get_thrust_vector(), auto_yaw.yaw(), auto_yaw.rate_cds())
}
}
"
451,Arducopter\mode_guided.cpp_velaccel_control_run,"void ModeGuided::velaccel_control_run()
{
float target_yaw_rate = 0
if (!copter.failsafe.radio && use_pilot_yaw()) {
target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
if (!is_zero(target_yaw_rate)) {
auto_yaw.set_mode(AUTO_YAW_HOLD)
}
}

if (is_disarmed_or_landed()) {
make_safe_ground_handling(copter.is_tradheli() && motors->get_interlock())
return
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

uint32_t tnow = millis()
if (tnow - update_time_ms > get_timeout_ms()) {
guided_vel_target_cms.zero()
guided_accel_target_cmss.zero()
if ((auto_yaw.mode() == AUTO_YAW_RATE) || (auto_yaw.mode() == AUTO_YAW_ANGLE_RATE)) {
auto_yaw.set_rate(0.0f)
}
}

bool do_avoid = false
copter.avoid.adjust_velocity(guided_vel_target_cms, pos_control->get_pos_xy_p().kP(), pos_control->get_max_accel_xy_cmss(), pos_control->get_pos_z_p().kP(), pos_control->get_max_accel_z_cmss(), G_Dt)
do_avoid = copter.avoid.limits_active()


if (!stabilizing_vel_xy() && !do_avoid) {
guided_vel_target_cms.x = pos_control->get_vel_desired_cms().x
guided_vel_target_cms.y = pos_control->get_vel_desired_cms().y
}
pos_control->input_vel_accel_xy(guided_vel_target_cms.xy(), guided_accel_target_cmss.xy(), false)
if (!stabilizing_vel_xy() && !do_avoid) {
pos_control->stop_vel_xy_stabilisation()
} else if (!stabilizing_pos_xy() && !do_avoid) {
pos_control->stop_pos_xy_stabilisation()
}
pos_control->input_vel_accel_z(guided_vel_target_cms.z, guided_accel_target_cmss.z, false, false)

pos_control->update_xy_controller()
pos_control->update_z_controller()

if (auto_yaw.mode() == AUTO_YAW_HOLD) {
attitude_control->input_thrust_vector_rate_heading(pos_control->get_thrust_vector(), target_yaw_rate)
} else if (auto_yaw.mode() == AUTO_YAW_RATE) {
attitude_control->input_thrust_vector_rate_heading(pos_control->get_thrust_vector(), auto_yaw.rate_cds())
} else {
attitude_control->input_thrust_vector_heading(pos_control->get_thrust_vector(), auto_yaw.yaw(), auto_yaw.rate_cds())
}
}
"
452,Arducopter\mode_guided.cpp_pause_control_run,"void ModeGuided::pause_control_run()
{
if (is_disarmed_or_landed()) {
make_safe_ground_handling(copter.is_tradheli() && motors->get_interlock())
return
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

Vector2f vel_xy, accel_xy
pos_control->input_vel_accel_xy(vel_xy, accel_xy, false)

float vel_z = 0.0
pos_control->input_vel_accel_z(vel_z, 0.0, false, false)

pos_control->update_xy_controller()
pos_control->update_z_controller()

attitude_control->input_thrust_vector_rate_heading(pos_control->get_thrust_vector(), 0.0)
}
"
453,Arducopter\mode_guided.cpp_posvelaccel_control_run,"void ModeGuided::posvelaccel_control_run()
{
float target_yaw_rate = 0

if (!copter.failsafe.radio && use_pilot_yaw()) {
target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
if (!is_zero(target_yaw_rate)) {
auto_yaw.set_mode(AUTO_YAW_HOLD)
}
}

if (is_disarmed_or_landed()) {
make_safe_ground_handling(copter.is_tradheli() && motors->get_interlock())
return
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

uint32_t tnow = millis()
if (tnow - update_time_ms > get_timeout_ms()) {
guided_vel_target_cms.zero()
guided_accel_target_cmss.zero()
if ((auto_yaw.mode() == AUTO_YAW_RATE) || (auto_yaw.mode() == AUTO_YAW_ANGLE_RATE)) {
auto_yaw.set_rate(0.0f)
}
}

if (!stabilizing_vel_xy()) {
guided_pos_target_cm.x = pos_control->get_pos_target_cm().x
guided_pos_target_cm.y = pos_control->get_pos_target_cm().y
guided_vel_target_cms.x = pos_control->get_vel_desired_cms().x
guided_vel_target_cms.y = pos_control->get_vel_desired_cms().y
} else if (!stabilizing_pos_xy()) {
guided_pos_target_cm.x = pos_control->get_pos_target_cm().x
guided_pos_target_cm.y = pos_control->get_pos_target_cm().y
}
pos_control->input_pos_vel_accel_xy(guided_pos_target_cm.xy(), guided_vel_target_cms.xy(), guided_accel_target_cmss.xy(), false)
if (!stabilizing_vel_xy()) {
pos_control->stop_vel_xy_stabilisation()
} else if (!stabilizing_pos_xy()) {
pos_control->stop_pos_xy_stabilisation()
}

if (guided_pos_terrain_alt) {
INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control)
}

float pz = guided_pos_target_cm.z
pos_control->input_pos_vel_accel_z(pz, guided_vel_target_cms.z, guided_accel_target_cmss.z, false)
guided_pos_target_cm.z = pz

pos_control->update_xy_controller()
pos_control->update_z_controller()

if (auto_yaw.mode() == AUTO_YAW_HOLD) {
attitude_control->input_thrust_vector_rate_heading(pos_control->get_thrust_vector(), target_yaw_rate)
} else if (auto_yaw.mode() == AUTO_YAW_RATE) {
attitude_control->input_thrust_vector_rate_heading(pos_control->get_thrust_vector(), auto_yaw.rate_cds())
} else {
attitude_control->input_thrust_vector_heading(pos_control->get_thrust_vector(), auto_yaw.yaw(), auto_yaw.rate_cds())
}
}
"
454,Arducopter\mode_guided.cpp_angle_control_run,"void ModeGuided::angle_control_run()
{
float climb_rate_cms = 0.0f
if (!guided_angle_state.use_thrust) {
climb_rate_cms = constrain_float(guided_angle_state.climb_rate_cms, -wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up())

climb_rate_cms = get_avoidance_adjusted_climbrate(climb_rate_cms)
}

uint32_t tnow = millis()
if (tnow - guided_angle_state.update_time_ms > get_timeout_ms()) {
guided_angle_state.attitude_quat.initialise()
guided_angle_state.ang_vel.zero()
climb_rate_cms = 0.0f
if (guided_angle_state.use_thrust) {
pos_control->init_z_controller()
guided_angle_state.use_thrust = false
}
}

const bool positive_thrust_or_climbrate = is_positive(guided_angle_state.use_thrust ? guided_angle_state.thrust : climb_rate_cms)
if (motors->armed() && positive_thrust_or_climbrate) {
copter.set_auto_armed(true)
}

if (!motors->armed() || !copter.ap.auto_armed || (copter.ap.land_complete && !positive_thrust_or_climbrate)) {
make_safe_ground_handling(copter.is_tradheli() && motors->get_interlock())
return
}

if (copter.ap.land_complete && (guided_angle_state.climb_rate_cms > 0.0f)) {
zero_throttle_and_relax_ac()
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)
if (motors->get_spool_state() == AP_Motors::SpoolState::THROTTLE_UNLIMITED) {
set_land_complete(false)
pos_control->init_z_controller()
}
return
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

if (guided_angle_state.attitude_quat.is_zero()) {
attitude_control->input_rate_bf_roll_pitch_yaw(ToDeg(guided_angle_state.ang_vel.x) * 100.0f, ToDeg(guided_angle_state.ang_vel.y) * 100.0f, ToDeg(guided_angle_state.ang_vel.z) * 100.0f)
} else {
attitude_control->input_quaternion(guided_angle_state.attitude_quat, guided_angle_state.ang_vel)
}

if (guided_angle_state.use_thrust) {
attitude_control->set_throttle_out(guided_angle_state.thrust, true, copter.g.throttle_filt)
} else {
pos_control->set_pos_target_z_from_climb_rate_cm(climb_rate_cms)
pos_control->update_z_controller()
}
}
"
455,Arducopter\mode_guided.cpp_set_yaw_state,"void ModeGuided::set_yaw_state(bool use_yaw, float yaw_cd, bool use_yaw_rate, float yaw_rate_cds, bool relative_angle)
{
if (use_yaw && relative_angle) {
auto_yaw.set_fixed_yaw(yaw_cd * 0.01f, 0.0f, 0, relative_angle)
} else if (use_yaw && use_yaw_rate) {
auto_yaw.set_yaw_angle_rate(yaw_cd * 0.01f, yaw_rate_cds * 0.01f)
} else if (use_yaw && !use_yaw_rate) {
auto_yaw.set_yaw_angle_rate(yaw_cd * 0.01f, 0.0f)
} else if (use_yaw_rate) {
auto_yaw.set_rate(yaw_rate_cds)
} else {
auto_yaw.set_mode_to_default(false)
}
}
"
456,Arducopter\mode_guided.cpp_use_pilot_yaw,"bool ModeGuided::use_pilot_yaw(void) const
{
return (copter.g2.guided_options.get() & uint32_t(Options::IgnorePilotYaw)) == 0
}
"
457,Arducopter\mode_guided.cpp_limit_clear,"void ModeGuided::limit_clear()
{
guided_limit.timeout_ms = 0
guided_limit.alt_min_cm = 0.0f
guided_limit.alt_max_cm = 0.0f
guided_limit.horiz_max_cm = 0.0f
}
"
458,Arducopter\mode_guided.cpp_limit_set,"void ModeGuided::limit_set(uint32_t timeout_ms, float alt_min_cm, float alt_max_cm, float horiz_max_cm)
{
guided_limit.timeout_ms = timeout_ms
guided_limit.alt_min_cm = alt_min_cm
guided_limit.alt_max_cm = alt_max_cm
guided_limit.horiz_max_cm = horiz_max_cm
}
"
459,Arducopter\mode_guided.cpp_limit_init_time_and_pos,"void ModeGuided::limit_init_time_and_pos()
{
guided_limit.start_time = AP_HAL::millis()

guided_limit.start_pos = inertial_nav.get_position_neu_cm()
}
"
460,Arducopter\mode_guided.cpp_limit_check,"bool ModeGuided::limit_check()
{
if ((guided_limit.timeout_ms > 0) && (millis() - guided_limit.start_time >= guided_limit.timeout_ms)) {
return true
}

const Vector3f& curr_pos = inertial_nav.get_position_neu_cm()

if (!is_zero(guided_limit.alt_min_cm) && (curr_pos.z < guided_limit.alt_min_cm)) {
return true
}

if (!is_zero(guided_limit.alt_max_cm) && (curr_pos.z > guided_limit.alt_max_cm)) {
return true
}

if (guided_limit.horiz_max_cm > 0.0f) {
const float horiz_move = get_horizontal_distance_cm(guided_limit.start_pos.xy(), curr_pos.xy())
if (horiz_move > guided_limit.horiz_max_cm) {
return true
}
}

return false
}
"
461,Arducopter\mode_guided.cpp_get_target_pos,"const Vector3p &ModeGuided::get_target_pos() const
{
return guided_pos_target_cm
}
"
462,Arducopter\mode_guided.cpp_get_target_vel,"const Vector3f& ModeGuided::get_target_vel() const
{
return guided_vel_target_cms
}
"
463,Arducopter\mode_guided.cpp_get_target_accel,"const Vector3f& ModeGuided::get_target_accel() const
{
return guided_accel_target_cmss
}
"
464,Arducopter\mode_guided.cpp_wp_distance,"uint32_t ModeGuided::wp_distance() const
{
switch(guided_mode) {
case SubMode::WP:
return wp_nav->get_wp_distance_to_destination()
case SubMode::Pos:
return get_horizontal_distance_cm(inertial_nav.get_position_xy_cm(), guided_pos_target_cm.tofloat().xy())
case SubMode::PosVelAccel:
return pos_control->get_pos_error_xy_cm()
break
default:
return 0
}
}
"
465,Arducopter\mode_guided.cpp_wp_bearing,"int32_t ModeGuided::wp_bearing() const
{
switch(guided_mode) {
case SubMode::WP:
return wp_nav->get_wp_bearing_to_destination()
case SubMode::Pos:
return get_bearing_cd(inertial_nav.get_position_xy_cm(), guided_pos_target_cm.tofloat().xy())
case SubMode::PosVelAccel:
return pos_control->get_bearing_to_target_cd()
break
case SubMode::TakeOff:
case SubMode::Accel:
case SubMode::VelAccel:
case SubMode::Angle:
return 0
}
return 0.0
}
"
466,Arducopter\mode_guided.cpp_crosstrack_error,"float ModeGuided::crosstrack_error() const
{
switch (guided_mode) {
case SubMode::WP:
return wp_nav->crosstrack_error()
case SubMode::Pos:
case SubMode::TakeOff:
case SubMode::Accel:
case SubMode::VelAccel:
case SubMode::PosVelAccel:
return pos_control->crosstrack_error()
case SubMode::Angle:
return 0
}
return 0
}
"
467,Arducopter\mode_guided.cpp_get_timeout_ms,"uint32_t ModeGuided::get_timeout_ms() const
{
return MAX(copter.g2.guided_timeout, 0.1) * 1000
}
"
468,Arducopter\mode_guided.cpp_pause,"bool ModeGuided::pause()
{
_paused = true
return true
}
"
469,Arducopter\mode_guided.cpp_resume,"bool ModeGuided::resume()
{
_paused = false
return true
}
"
470,Arducopter\mode_guided_nogps.cpp_init,"bool ModeGuidedNoGPS::init(bool ignore_checks)
{
ModeGuided::angle_control_start()
return true
}
"
471,Arducopter\mode_guided_nogps.cpp_run,"void ModeGuidedNoGPS::run()
{
ModeGuided::angle_control_run()
}
"
472,Arducopter\mode_land.cpp_init,"bool ModeLand::init(bool ignore_checks)
{
control_position = copter.position_ok()

pos_control->set_max_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_wp_acceleration())
pos_control->set_correction_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_wp_acceleration())

if (control_position && !pos_control->is_active_xy()) {
pos_control->init_xy_controller()
}

pos_control->set_max_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z())
pos_control->set_correction_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z())

if (!pos_control->is_active_z()) {
pos_control->init_z_controller()
}

land_start_time = millis()
land_pause = false

copter.ap.land_repo_active = false

copter.ap.prec_land_active = false

auto_yaw.set_mode(AUTO_YAW_HOLD)

copter.landinggear.deploy_for_landing()

copter.fence.auto_disable_fence_for_landing()

copter.precland_statemachine.init()

return true
}
"
473,Arducopter\mode_land.cpp_run,"void ModeLand::run()
{
if (control_position) {
gps_run()
} else {
nogps_run()
}
}
"
474,Arducopter\mode_land.cpp_gps_run,"void ModeLand::gps_run()
{
if (copter.ap.land_complete && motors->get_spool_state() == AP_Motors::SpoolState::GROUND_IDLE) {
copter.arming.disarm(AP_Arming::Method::LANDED)
}

if (is_disarmed_or_landed()) {
make_safe_ground_handling()
} else {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

if (land_pause && millis()-land_start_time >= LAND_WITH_DELAY_MS) {
land_pause = false
}

land_run_normal_or_precland(land_pause)
}
}
"
475,Arducopter\mode_land.cpp_nogps_run,"void ModeLand::nogps_run()
{
float target_roll = 0.0f, target_pitch = 0.0f
float target_yaw_rate = 0

if (!copter.failsafe.radio) {
if ((g.throttle_behavior & THR_BEHAVE_HIGH_THROTTLE_CANCELS_LAND) != 0 && copter.rc_throttle_control_in_filter.get() > LAND_CANCEL_TRIGGER_THR){
AP::logger().Write_Event(LogEvent::LAND_CANCELLED_BY_PILOT)
copter.set_mode(Mode::Number::ALT_HOLD, ModeReason::THROTTLE_LAND_ESCAPE)
}

if (g.land_repositioning) {
update_simple_mode()

get_pilot_desired_lean_angles(target_roll, target_pitch, copter.aparm.angle_max, attitude_control->get_althold_lean_angle_max_cd())
}

target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
if (!is_zero(target_yaw_rate)) {
auto_yaw.set_mode(AUTO_YAW_HOLD)
}
}

if (copter.ap.land_complete && motors->get_spool_state() == AP_Motors::SpoolState::GROUND_IDLE) {
copter.arming.disarm(AP_Arming::Method::LANDED)
}

if (is_disarmed_or_landed()) {
make_safe_ground_handling()
} else {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

if (land_pause && millis()-land_start_time >= LAND_WITH_DELAY_MS) {
land_pause = false
}

land_run_vertical_control(land_pause)
}

attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate)
}
"
476,Arducopter\mode_land.cpp_do_not_use_GPS,"void ModeLand::do_not_use_GPS()
{
control_position = false
}
"
477,Arducopter\mode_land.cpp_set_mode_land_with_pause,"void Copter::set_mode_land_with_pause(ModeReason reason)
{
set_mode(Mode::Number::LAND, reason)
mode_land.set_land_pause(true)

AP_Notify::events.failsafe_mode_change = 1
}
"
478,Arducopter\mode_land.cpp_landing_with_GPS,"bool Copter::landing_with_GPS()
{
return (flightmode->mode_number() == Mode::Number::LAND &&
mode_land.controlling_position())
}
"
479,Arducopter\mode_loiter.cpp_init,"bool ModeLoiter::init(bool ignore_checks)
{
if (!copter.failsafe.radio) {
float target_roll, target_pitch
update_simple_mode()

get_pilot_desired_lean_angles(target_roll, target_pitch, loiter_nav->get_angle_max_cd(), attitude_control->get_althold_lean_angle_max_cd())

loiter_nav->set_pilot_desired_acceleration(target_roll, target_pitch)
} else {
loiter_nav->clear_pilot_desired_acceleration()
}
loiter_nav->init_target()

if (!pos_control->is_active_z()) {
pos_control->init_z_controller()
}

pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)
pos_control->set_correction_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)

_precision_loiter_active = false

return true
}
"
480,Arducopter\mode_loiter.cpp_do_precision_loiter,"bool ModeLoiter::do_precision_loiter()
{
if (!_precision_loiter_enabled) {
return false
}
if (copter.ap.land_complete_maybe) {
return false
}
if (loiter_nav->get_pilot_desired_acceleration().length() > 50.0f) {
return false
}
if (!copter.precland.target_acquired()) {
return false
}
return true
}
"
481,Arducopter\mode_loiter.cpp_precision_loiter_xy,"void ModeLoiter::precision_loiter_xy()
{
loiter_nav->clear_pilot_desired_acceleration()
Vector2f target_pos, target_vel
if (!copter.precland.get_target_position_cm(target_pos)) {
target_pos = inertial_nav.get_position_xy_cm()
}
copter.precland.get_target_velocity_cms(inertial_nav.get_velocity_xy_cms(), target_vel)

Vector2f zero
Vector2p landing_pos = target_pos.topostype()
pos_control->input_pos_vel_accel_xy(landing_pos, target_vel, zero)
pos_control->update_xy_controller()
}
"
482,Arducopter\mode_loiter.cpp_run,"void ModeLoiter::run()
{
float target_roll, target_pitch
float target_yaw_rate = 0.0f
float target_climb_rate = 0.0f

pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)

if (!copter.failsafe.radio) {
update_simple_mode()

get_pilot_desired_lean_angles(target_roll, target_pitch, loiter_nav->get_angle_max_cd(), attitude_control->get_althold_lean_angle_max_cd())

loiter_nav->set_pilot_desired_acceleration(target_roll, target_pitch)

target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())

target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->get_control_in())
target_climb_rate = constrain_float(target_climb_rate, -get_pilot_speed_dn(), g.pilot_speed_up)
} else {
loiter_nav->clear_pilot_desired_acceleration()
}

if (copter.ap.land_complete_maybe) {
loiter_nav->soften_for_landing()
}

AltHoldModeState loiter_state = get_alt_hold_state(target_climb_rate)

switch (loiter_state) {

case AltHold_MotorStopped:
attitude_control->reset_rate_controller_I_terms()
attitude_control->reset_yaw_target_and_rate()
pos_control->relax_z_controller(0.0f)
loiter_nav->init_target()
attitude_control->input_thrust_vector_rate_heading(loiter_nav->get_thrust_vector(), target_yaw_rate, false)
break

case AltHold_Landed_Ground_Idle:
attitude_control->reset_yaw_target_and_rate()
FALLTHROUGH

case AltHold_Landed_Pre_Takeoff:
attitude_control->reset_rate_controller_I_terms_smoothly()
loiter_nav->init_target()
attitude_control->input_thrust_vector_rate_heading(loiter_nav->get_thrust_vector(), target_yaw_rate, false)
pos_control->relax_z_controller(0.0f)
break

case AltHold_Takeoff:
if (!takeoff.running()) {
takeoff.start(constrain_float(g.pilot_takeoff_alt,0.0f,1000.0f))
}

target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate)

takeoff.do_pilot_takeoff(target_climb_rate)

loiter_nav->update()

attitude_control->input_thrust_vector_rate_heading(loiter_nav->get_thrust_vector(), target_yaw_rate, false)
break

case AltHold_Flying:
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

bool precision_loiter_old_state = _precision_loiter_active
if (do_precision_loiter()) {
precision_loiter_xy()
_precision_loiter_active = true
} else {
_precision_loiter_active = false
}
if (precision_loiter_old_state && !_precision_loiter_active) {
loiter_nav->init_target()
}
if (!_precision_loiter_active) {
loiter_nav->update()
}
loiter_nav->update()

attitude_control->input_thrust_vector_rate_heading(loiter_nav->get_thrust_vector(), target_yaw_rate, false)

target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate)

copter.surface_tracking.update_surface_offset()

pos_control->set_pos_target_z_from_climb_rate_cm(target_climb_rate)
break
}

pos_control->update_z_controller()
}
"
483,Arducopter\mode_loiter.cpp_wp_distance,"uint32_t ModeLoiter::wp_distance() const
{
return loiter_nav->get_distance_to_target()
}
"
484,Arducopter\mode_loiter.cpp_wp_bearing,"int32_t ModeLoiter::wp_bearing() const
{
return loiter_nav->get_bearing_to_target()
}
"
485,Arducopter\mode_poshold.cpp_init,"bool ModePosHold::init(bool ignore_checks)
{
pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)
pos_control->set_correction_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)

if (!pos_control->is_active_z()) {
pos_control->init_z_controller()
}

pilot_roll = 0.0f
pilot_pitch = 0.0f

brake.gain = (15.0f * (float)g.poshold_brake_rate + 95.0f) * 0.01f

if (copter.ap.land_complete) {
roll_mode = RPMode::LOITER
pitch_mode = RPMode::LOITER
} else {
roll_mode = RPMode::PILOT_OVERRIDE
pitch_mode = RPMode::PILOT_OVERRIDE
}

loiter_nav->clear_pilot_desired_acceleration()
loiter_nav->init_target()

init_wind_comp_estimate()

return true
}
"
486,Arducopter\mode_poshold.cpp_run,"void ModePosHold::run()
{
float controller_to_pilot_roll_mix
float controller_to_pilot_pitch_mix
const Vector3f& vel = inertial_nav.get_velocity_neu_cms()

pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)
loiter_nav->clear_pilot_desired_acceleration()

update_simple_mode()

float target_roll, target_pitch
get_pilot_desired_lean_angles(target_roll, target_pitch, copter.aparm.angle_max, attitude_control->get_althold_lean_angle_max_cd())

float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())

float target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->get_control_in())
target_climb_rate = constrain_float(target_climb_rate, -get_pilot_speed_dn(), g.pilot_speed_up)

if (copter.ap.land_complete_maybe) {
loiter_nav->soften_for_landing()
}

AltHoldModeState poshold_state = get_alt_hold_state(target_climb_rate)

switch (poshold_state) {

case AltHold_MotorStopped:
attitude_control->reset_rate_controller_I_terms()
attitude_control->reset_yaw_target_and_rate(false)
pos_control->relax_z_controller(0.0f)
loiter_nav->clear_pilot_desired_acceleration()
loiter_nav->init_target()

roll_mode = RPMode::PILOT_OVERRIDE
pitch_mode = RPMode::PILOT_OVERRIDE

init_wind_comp_estimate()
break

case AltHold_Landed_Ground_Idle:
loiter_nav->clear_pilot_desired_acceleration()
loiter_nav->init_target()
attitude_control->reset_yaw_target_and_rate()
init_wind_comp_estimate()
FALLTHROUGH

case AltHold_Landed_Pre_Takeoff:
attitude_control->reset_rate_controller_I_terms_smoothly()
pos_control->relax_z_controller(0.0f)

roll_mode = RPMode::PILOT_OVERRIDE
pitch_mode = RPMode::PILOT_OVERRIDE
break

case AltHold_Takeoff:
if (!takeoff.running()) {
takeoff.start(constrain_float(g.pilot_takeoff_alt,0.0f,1000.0f))
}

target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate)

takeoff.do_pilot_takeoff(target_climb_rate)

loiter_nav->clear_pilot_desired_acceleration()
loiter_nav->init_target()

roll_mode = RPMode::PILOT_OVERRIDE
pitch_mode = RPMode::PILOT_OVERRIDE
break

case AltHold_Flying:
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate)

copter.surface_tracking.update_surface_offset()

pos_control->set_pos_target_z_from_climb_rate_cm(target_climb_rate)
break
}

float vel_fw = vel.x*ahrs.cos_yaw() + vel.y*ahrs.sin_yaw()
float vel_right = -vel.x*ahrs.sin_yaw() + vel.y*ahrs.cos_yaw()

if (roll_mode != RPMode::LOITER || pitch_mode != RPMode::LOITER) {
get_wind_comp_lean_angles(wind_comp_roll, wind_comp_pitch)
}

switch (roll_mode) {

case RPMode::PILOT_OVERRIDE:
update_pilot_lean_angle(pilot_roll, target_roll)

if (is_zero(target_roll) && (fabsf(pilot_roll) < 2 * g.poshold_brake_rate)) {
roll_mode = RPMode::BRAKE
brake.roll = 0.0f
brake.angle_max_roll = 0.0f
brake.timeout_roll = POSHOLD_BRAKE_TIME_ESTIMATE_MAX
brake.time_updated_roll = false
}

roll = pilot_roll + wind_comp_roll
break

case RPMode::BRAKE:
case RPMode::BRAKE_READY_TO_LOITER:
update_brake_angle_from_velocity(brake.roll, vel_right)

if (!brake.time_updated_roll) {
if (fabsf(brake.roll) >= brake.angle_max_roll) {
brake.angle_max_roll = fabsf(brake.roll)
} else {
brake.timeout_roll = 1+(uint16_t)(LOOP_RATE_FACTOR*15L*(int32_t)(fabsf(brake.roll))/(10L*(int32_t)g.poshold_brake_rate))
brake.time_updated_roll = true
}
}

if ((fabsf(vel_right) <= POSHOLD_SPEED_0) && (brake.timeout_roll > 50*LOOP_RATE_FACTOR)) {
brake.timeout_roll = 50*LOOP_RATE_FACTOR
}

if (brake.timeout_roll > 0) {
brake.timeout_roll--
} else {
roll_mode = RPMode::BRAKE_READY_TO_LOITER
}

roll = brake.roll + wind_comp_roll

if (!is_zero(target_roll)) {
roll_controller_to_pilot_override()
}
break

case RPMode::BRAKE_TO_LOITER:
case RPMode::LOITER:
break

case RPMode::CONTROLLER_TO_PILOT_OVERRIDE:
update_pilot_lean_angle(pilot_roll, target_roll)

if (controller_to_pilot_timer_roll > 0) {
controller_to_pilot_timer_roll--
} else {
roll_mode = RPMode::PILOT_OVERRIDE
}

controller_to_pilot_roll_mix = (float)controller_to_pilot_timer_roll / (float)POSHOLD_CONTROLLER_TO_PILOT_MIX_TIMER

roll = mix_controls(controller_to_pilot_roll_mix, controller_final_roll, pilot_roll + wind_comp_roll)
break
}

switch (pitch_mode) {

case RPMode::PILOT_OVERRIDE:
update_pilot_lean_angle(pilot_pitch, target_pitch)

if (is_zero(target_pitch) && (fabsf(pilot_pitch) < 2 * g.poshold_brake_rate)) {
pitch_mode = RPMode::BRAKE
brake.pitch = 0.0f
brake.angle_max_pitch = 0.0f
brake.timeout_pitch = POSHOLD_BRAKE_TIME_ESTIMATE_MAX
brake.time_updated_pitch = false
}

pitch = pilot_pitch + wind_comp_pitch
break

case RPMode::BRAKE:
case RPMode::BRAKE_READY_TO_LOITER:
update_brake_angle_from_velocity(brake.pitch, -vel_fw)

if (!brake.time_updated_pitch) {
if (fabsf(brake.pitch) >= brake.angle_max_pitch) {
brake.angle_max_pitch = fabsf(brake.pitch)
} else {
brake.timeout_pitch = 1+(uint16_t)(LOOP_RATE_FACTOR*15L*(int32_t)(fabsf(brake.pitch))/(10L*(int32_t)g.poshold_brake_rate))
brake.time_updated_pitch = true
}
}

if ((fabsf(vel_fw) <= POSHOLD_SPEED_0) && (brake.timeout_pitch > 50*LOOP_RATE_FACTOR)) {
brake.timeout_pitch = 50*LOOP_RATE_FACTOR
}

if (brake.timeout_pitch > 0) {
brake.timeout_pitch--
} else {
pitch_mode = RPMode::BRAKE_READY_TO_LOITER
}

pitch = brake.pitch + wind_comp_pitch

if (!is_zero(target_pitch)) {
pitch_controller_to_pilot_override()
}
break

case RPMode::BRAKE_TO_LOITER:
case RPMode::LOITER:
break

case RPMode::CONTROLLER_TO_PILOT_OVERRIDE:
update_pilot_lean_angle(pilot_pitch, target_pitch)

if (controller_to_pilot_timer_pitch > 0) {
controller_to_pilot_timer_pitch--
} else {
pitch_mode = RPMode::PILOT_OVERRIDE
}

controller_to_pilot_pitch_mix = (float)controller_to_pilot_timer_pitch / (float)POSHOLD_CONTROLLER_TO_PILOT_MIX_TIMER

pitch = mix_controls(controller_to_pilot_pitch_mix, controller_final_pitch, pilot_pitch + wind_comp_pitch)
break
}


if (roll_mode == RPMode::BRAKE_READY_TO_LOITER && pitch_mode == RPMode::BRAKE_READY_TO_LOITER) {
roll_mode = RPMode::BRAKE_TO_LOITER
pitch_mode = RPMode::BRAKE_TO_LOITER
brake.to_loiter_timer = POSHOLD_BRAKE_TO_LOITER_TIMER
loiter_nav->init_target(inertial_nav.get_position_xy_cm())
wind_comp_start_timer = POSHOLD_WIND_COMP_START_TIMER
}

if (roll_mode == RPMode::BRAKE_TO_LOITER || roll_mode == RPMode::LOITER) {

pitch_mode = roll_mode

switch (roll_mode) {
case RPMode::BRAKE_TO_LOITER: {
if (brake.to_loiter_timer > 0) {
brake.to_loiter_timer--
} else {
roll_mode = RPMode::LOITER
pitch_mode = RPMode::LOITER
}

const float brake_to_loiter_mix = (float)brake.to_loiter_timer / (float)POSHOLD_BRAKE_TO_LOITER_TIMER

update_brake_angle_from_velocity(brake.roll, vel_right)
update_brake_angle_from_velocity(brake.pitch, -vel_fw)

loiter_nav->update(false)

roll = mix_controls(brake_to_loiter_mix, brake.roll + wind_comp_roll, loiter_nav->get_roll())
pitch = mix_controls(brake_to_loiter_mix, brake.pitch + wind_comp_pitch, loiter_nav->get_pitch())

if (!is_zero(target_roll) || !is_zero(target_pitch)) {
if (!is_zero(target_roll)) {
roll_controller_to_pilot_override()
pitch_mode = RPMode::BRAKE_READY_TO_LOITER
}
if (!is_zero(target_pitch)) {
pitch_controller_to_pilot_override()
if (is_zero(target_roll)) {
roll_mode = RPMode::BRAKE_READY_TO_LOITER
}
}
}
break
}
case RPMode::LOITER:
loiter_nav->update(false)

roll = loiter_nav->get_roll()
pitch = loiter_nav->get_pitch()

update_wind_comp_estimate()

if (!is_zero(target_roll) || !is_zero(target_pitch)) {
if (!is_zero(target_roll)) {
roll_controller_to_pilot_override()
pitch_mode = RPMode::BRAKE_READY_TO_LOITER
brake.pitch = 0.0f
}
if (!is_zero(target_pitch)) {
pitch_controller_to_pilot_override()
if (is_zero(target_roll)) {
roll_mode = RPMode::BRAKE_READY_TO_LOITER
brake.roll = 0.0f
}
}
}
break

default:
break
}
}

float angle_max = copter.aparm.angle_max
roll = constrain_float(roll, -angle_max, angle_max)
pitch = constrain_float(pitch, -angle_max, angle_max)

attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(roll, pitch, target_yaw_rate)

pos_control->update_z_controller()
}
"
487,Arducopter\mode_poshold.cpp_update_pilot_lean_angle,"void ModePosHold::update_pilot_lean_angle(float &lean_angle_filtered, float &lean_angle_raw)
{
if ((lean_angle_filtered > 0 && lean_angle_raw < 0) || (lean_angle_filtered < 0 && lean_angle_raw > 0) || (fabsf(lean_angle_raw) > POSHOLD_STICK_RELEASE_SMOOTH_ANGLE)) {
lean_angle_filtered = lean_angle_raw
} else {
if (lean_angle_filtered > 0) {
lean_angle_filtered -= MAX(lean_angle_filtered * POSHOLD_SMOOTH_RATE_FACTOR, MAX(1.0f, g.poshold_brake_rate/(float)LOOP_RATE_FACTOR))
lean_angle_filtered = MAX(lean_angle_filtered, lean_angle_raw)
}else{
lean_angle_filtered += MAX(-lean_angle_filtered * POSHOLD_SMOOTH_RATE_FACTOR, MAX(1.0f, g.poshold_brake_rate/(float)LOOP_RATE_FACTOR))
lean_angle_filtered = MIN(lean_angle_filtered, lean_angle_raw)
}
}
}
"
488,Arducopter\mode_poshold.cpp_mix_controls,"float ModePosHold::mix_controls(float mix_ratio, float first_control, float second_control)
{
mix_ratio = constrain_float(mix_ratio, 0.0f, 1.0f)
return mix_ratio * first_control + (1.0f - mix_ratio) * second_control
}
"
489,Arducopter\mode_poshold.cpp_update_brake_angle_from_velocity,"void ModePosHold::update_brake_angle_from_velocity(float &brake_angle, float velocity)
{
float lean_angle
float brake_rate = g.poshold_brake_rate

brake_rate /= (float)LOOP_RATE_FACTOR
if (brake_rate <= 1.0f) {
brake_rate = 1.0f
}

if (velocity >= 0) {
lean_angle = -brake.gain * velocity * (1.0f + 500.0f / (velocity + 60.0f))
} else {
lean_angle = -brake.gain * velocity * (1.0f + 500.0f / (-velocity + 60.0f))
}

brake_angle = constrain_float(lean_angle, brake_angle - brake_rate, brake_angle + brake_rate)

brake_angle = constrain_float(brake_angle, -(float)g.poshold_brake_angle_max, (float)g.poshold_brake_angle_max)
}
"
490,Arducopter\mode_poshold.cpp_init_wind_comp_estimate,"void ModePosHold::init_wind_comp_estimate()
{
wind_comp_ef.zero()
wind_comp_timer = 0
wind_comp_roll = 0.0f
wind_comp_pitch = 0.0f
}
"
491,Arducopter\mode_poshold.cpp_update_wind_comp_estimate,"void ModePosHold::update_wind_comp_estimate()
{
if (wind_comp_start_timer > 0) {
wind_comp_start_timer--
return
}

if (inertial_nav.get_speed_xy_cms() > POSHOLD_WIND_COMP_ESTIMATE_SPEED_MAX) {
return
}

const Vector3f& accel_target = pos_control->get_accel_target_cmss()

if (is_zero(wind_comp_ef.x)) {
wind_comp_ef.x = accel_target.x
} else {
wind_comp_ef.x = (1.0f-TC_WIND_COMP)*wind_comp_ef.x + TC_WIND_COMP*accel_target.x
}
if (is_zero(wind_comp_ef.y)) {
wind_comp_ef.y = accel_target.y
} else {
wind_comp_ef.y = (1.0f-TC_WIND_COMP)*wind_comp_ef.y + TC_WIND_COMP*accel_target.y
}

const float accel_lim_cmss = tanf(radians(POSHOLD_WIND_COMP_LEAN_PCT_MAX * copter.aparm.angle_max * 0.01f)) * 981.0f
const float wind_comp_ef_len = wind_comp_ef.length()
if (!is_zero(accel_lim_cmss) && (wind_comp_ef_len > accel_lim_cmss)) {
wind_comp_ef *= accel_lim_cmss / wind_comp_ef_len
}
}
"
492,Arducopter\mode_poshold.cpp_get_wind_comp_lean_angles,"void ModePosHold::get_wind_comp_lean_angles(float &roll_angle, float &pitch_angle)
{
wind_comp_timer++
if (wind_comp_timer < POSHOLD_WIND_COMP_TIMER_10HZ) {
return
}
wind_comp_timer = 0

roll_angle = atanf((-wind_comp_ef.x*ahrs.sin_yaw() + wind_comp_ef.y*ahrs.cos_yaw())/(GRAVITY_MSS*100))*(18000.0f/M_PI)
pitch_angle = atanf(-(wind_comp_ef.x*ahrs.cos_yaw() + wind_comp_ef.y*ahrs.sin_yaw())/(GRAVITY_MSS*100))*(18000.0f/M_PI)
}
"
493,Arducopter\mode_poshold.cpp_roll_controller_to_pilot_override,"void ModePosHold::roll_controller_to_pilot_override()
{
roll_mode = RPMode::CONTROLLER_TO_PILOT_OVERRIDE
controller_to_pilot_timer_roll = POSHOLD_CONTROLLER_TO_PILOT_MIX_TIMER
pilot_roll = 0.0f
controller_final_roll = roll
}
"
494,Arducopter\mode_poshold.cpp_pitch_controller_to_pilot_override,"void ModePosHold::pitch_controller_to_pilot_override()
{
pitch_mode = RPMode::CONTROLLER_TO_PILOT_OVERRIDE
controller_to_pilot_timer_pitch = POSHOLD_CONTROLLER_TO_PILOT_MIX_TIMER
pilot_pitch = 0.0f
controller_final_pitch = pitch
}
"
495,Arducopter\mode_rtl.cpp_init,"bool ModeRTL::init(bool ignore_checks)
{
if (!ignore_checks) {
if (!AP::ahrs().home_is_set()) {
return false
}
}
wp_nav->wp_and_spline_init(g.rtl_speed_cms)
_state = SubMode::STARTING
_state_complete = true
terrain_following_allowed = !copter.failsafe.terrain
copter.ap.land_repo_active = false

copter.ap.prec_land_active = false

copter.precland_statemachine.init()

return true
}
"
496,Arducopter\mode_rtl.cpp_restart_without_terrain,"void ModeRTL::restart_without_terrain()
{
AP::logger().Write_Error(LogErrorSubsystem::NAVIGATION, LogErrorCode::RESTARTED_RTL)
terrain_following_allowed = false
_state = SubMode::STARTING
_state_complete = true
gcs().send_text(MAV_SEVERITY_CRITICAL,""Restarting RTL - Terrain data missing"")
}
"
497,Arducopter\mode_rtl.cpp_get_alt_type,"ModeRTL::RTLAltType ModeRTL::get_alt_type() const
{
if (g.rtl_alt_type < 0 || g.rtl_alt_type > (int)RTLAltType::RTL_ALTTYPE_TERRAIN) {
return RTLAltType::RTL_ALTTYPE_RELATIVE
}
return (RTLAltType)g.rtl_alt_type.get()
}
"
498,Arducopter\mode_rtl.cpp_run,"void ModeRTL::run(bool disarm_on_land)
{
if (!motors->armed()) {
return
}

if (_state_complete) {
switch (_state) {
case SubMode::STARTING:
build_path()
climb_start()
break
case SubMode::INITIAL_CLIMB:
return_start()
break
case SubMode::RETURN_HOME:
loiterathome_start()
break
case SubMode::LOITER_AT_HOME:
if (rtl_path.land || copter.failsafe.radio) {
land_start()
} else {
descent_start()
}
break
case SubMode::FINAL_DESCENT:
break
case SubMode::LAND:
break
}
}

switch (_state) {

case SubMode::STARTING:
_state = SubMode::INITIAL_CLIMB
FALLTHROUGH

case SubMode::INITIAL_CLIMB:
climb_return_run()
break

case SubMode::RETURN_HOME:
climb_return_run()
break

case SubMode::LOITER_AT_HOME:
loiterathome_run()
break

case SubMode::FINAL_DESCENT:
descent_run()
break

case SubMode::LAND:
land_run(disarm_on_land)
break
}
}
"
499,Arducopter\mode_rtl.cpp_climb_start,"void ModeRTL::climb_start()
{
_state = SubMode::INITIAL_CLIMB
_state_complete = false

if (!wp_nav->set_wp_destination_loc(rtl_path.climb_target) || !wp_nav->set_wp_destination_next_loc(rtl_path.return_target)) {
gcs().send_text(MAV_SEVERITY_CRITICAL,""RTL: unexpected error setting climb target"")
AP::logger().Write_Error(LogErrorSubsystem::NAVIGATION, LogErrorCode::FAILED_TO_SET_DESTINATION)
copter.set_mode(Mode::Number::LAND, ModeReason::TERRAIN_FAILSAFE)
return
}

auto_yaw.set_mode(AUTO_YAW_HOLD)
}
"
500,Arducopter\mode_rtl.cpp_return_start,"void ModeRTL::return_start()
{
_state = SubMode::RETURN_HOME
_state_complete = false

if (!wp_nav->set_wp_destination_loc(rtl_path.return_target)) {
restart_without_terrain()
}

auto_yaw.set_mode_to_default(true)
}
"
501,Arducopter\mode_rtl.cpp_climb_return_run,"void ModeRTL::climb_return_run()
{
if (is_disarmed_or_landed()) {
make_safe_ground_handling()
return
}

float target_yaw_rate = 0
if (!copter.failsafe.radio && use_pilot_yaw()) {
target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
if (!is_zero(target_yaw_rate)) {
auto_yaw.set_mode(AUTO_YAW_HOLD)
}
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

copter.failsafe_terrain_set_status(wp_nav->update_wpnav())

pos_control->update_z_controller()

if (auto_yaw.mode() == AUTO_YAW_HOLD) {
attitude_control->input_thrust_vector_rate_heading(wp_nav->get_thrust_vector(), target_yaw_rate)
} else {
attitude_control->input_thrust_vector_heading(wp_nav->get_thrust_vector(), auto_yaw.yaw())
}

_state_complete = wp_nav->reached_wp_destination()
}
"
502,Arducopter\mode_rtl.cpp_loiterathome_start,"void ModeRTL::loiterathome_start()
{
_state = SubMode::LOITER_AT_HOME
_state_complete = false
_loiter_start_time = millis()

if (auto_yaw.default_mode(true) != AUTO_YAW_HOLD) {
auto_yaw.set_mode(AUTO_YAW_RESETTOARMEDYAW)
} else {
auto_yaw.set_mode(AUTO_YAW_HOLD)
}
}
"
503,Arducopter\mode_rtl.cpp_loiterathome_run,"void ModeRTL::loiterathome_run()
{
if (is_disarmed_or_landed()) {
make_safe_ground_handling()
return
}

float target_yaw_rate = 0
if (!copter.failsafe.radio && use_pilot_yaw()) {
target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
if (!is_zero(target_yaw_rate)) {
auto_yaw.set_mode(AUTO_YAW_HOLD)
}
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

copter.failsafe_terrain_set_status(wp_nav->update_wpnav())

pos_control->update_z_controller()

if (auto_yaw.mode() == AUTO_YAW_HOLD) {
attitude_control->input_thrust_vector_rate_heading(wp_nav->get_thrust_vector(), target_yaw_rate)
} else {
attitude_control->input_thrust_vector_heading(wp_nav->get_thrust_vector(), auto_yaw.yaw())
}

if ((millis() - _loiter_start_time) >= (uint32_t)g.rtl_loiter_time.get()) {
if (auto_yaw.mode() == AUTO_YAW_RESETTOARMEDYAW) {
if (abs(wrap_180_cd(ahrs.yaw_sensor-copter.initial_armed_bearing)) <= 200) {
_state_complete = true
}
} else {
_state_complete = true
}
}
}
"
504,Arducopter\mode_rtl.cpp_descent_start,"void ModeRTL::descent_start()
{
_state = SubMode::FINAL_DESCENT
_state_complete = false

pos_control->init_z_controller_stopping_point()

auto_yaw.set_mode(AUTO_YAW_HOLD)

copter.landinggear.deploy_for_landing()

copter.fence.auto_disable_fence_for_landing()
}
"
505,Arducopter\mode_rtl.cpp_descent_run,"void ModeRTL::descent_run()
{
Vector2f vel_correction
float target_yaw_rate = 0.0f

if (is_disarmed_or_landed()) {
make_safe_ground_handling()
return
}

if (!copter.failsafe.radio) {
if ((g.throttle_behavior & THR_BEHAVE_HIGH_THROTTLE_CANCELS_LAND) != 0 && copter.rc_throttle_control_in_filter.get() > LAND_CANCEL_TRIGGER_THR){
AP::logger().Write_Event(LogEvent::LAND_CANCELLED_BY_PILOT)
if (!copter.set_mode(Mode::Number::LOITER, ModeReason::THROTTLE_LAND_ESCAPE)) {
copter.set_mode(Mode::Number::ALT_HOLD, ModeReason::THROTTLE_LAND_ESCAPE)
}
}

if (g.land_repositioning) {
update_simple_mode()

vel_correction = get_pilot_desired_velocity(wp_nav->get_wp_acceleration() * 0.5)

if (!vel_correction.is_zero()) {
if (!copter.ap.land_repo_active) {
AP::logger().Write_Event(LogEvent::LAND_REPO_ACTIVE)
}
copter.ap.land_repo_active = true
}
}

if (g.land_repositioning || use_pilot_yaw()) {
target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
}
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

Vector2f accel
pos_control->input_vel_accel_xy(vel_correction, accel)
pos_control->update_xy_controller()

pos_control->set_alt_target_with_slew(rtl_path.descent_target.alt)
pos_control->update_z_controller()

attitude_control->input_thrust_vector_rate_heading(pos_control->get_thrust_vector(), target_yaw_rate)

_state_complete = labs(rtl_path.descent_target.alt - copter.current_loc.alt) < 20
}
"
506,Arducopter\mode_rtl.cpp_land_start,"void ModeRTL::land_start()
{
_state = SubMode::LAND
_state_complete = false

pos_control->set_max_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_wp_acceleration())
pos_control->set_correction_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_wp_acceleration())

if (!pos_control->is_active_xy()) {
pos_control->init_xy_controller()
}

if (!pos_control->is_active_z()) {
pos_control->init_z_controller()
}

auto_yaw.set_mode(AUTO_YAW_HOLD)

copter.landinggear.deploy_for_landing()

copter.fence.auto_disable_fence_for_landing()
}
"
507,Arducopter\mode_rtl.cpp_is_landing,"bool ModeRTL::is_landing() const
{
return _state == SubMode::LAND
}
"
508,Arducopter\mode_rtl.cpp_land_run,"void ModeRTL::land_run(bool disarm_on_land)
{
_state_complete = copter.ap.land_complete

if (disarm_on_land && copter.ap.land_complete && motors->get_spool_state() == AP_Motors::SpoolState::GROUND_IDLE) {
copter.arming.disarm(AP_Arming::Method::LANDED)
}

if (is_disarmed_or_landed()) {
make_safe_ground_handling()
return
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

land_run_normal_or_precland()
}
"
509,Arducopter\mode_rtl.cpp_build_path,"void ModeRTL::build_path()
{
Vector3p stopping_point
pos_control->get_stopping_point_xy_cm(stopping_point.xy())
pos_control->get_stopping_point_z_cm(stopping_point.z)
rtl_path.origin_point = Location(stopping_point.tofloat(), Location::AltFrame::ABOVE_ORIGIN)
rtl_path.origin_point.change_alt_frame(Location::AltFrame::ABOVE_HOME)

compute_return_target()

rtl_path.climb_target = Location(rtl_path.origin_point.lat, rtl_path.origin_point.lng, rtl_path.return_target.alt, rtl_path.return_target.get_alt_frame())

rtl_path.descent_target = Location(rtl_path.return_target.lat, rtl_path.return_target.lng, g.rtl_alt_final, Location::AltFrame::ABOVE_HOME)

rtl_path.land = g.rtl_alt_final <= 0
}
"
510,Arducopter\mode_rtl.cpp_compute_return_target,"void ModeRTL::compute_return_target()
{
rtl_path.return_target = copter.rally.calc_best_rally_or_home_location(copter.current_loc, ahrs.get_home().alt)
rtl_path.return_target = ahrs.get_home()

int32_t curr_alt = copter.current_loc.alt

ReturnTargetAltType alt_type = ReturnTargetAltType::RELATIVE
if (terrain_following_allowed && (get_alt_type() == RTLAltType::RTL_ALTTYPE_TERRAIN)) {
switch (wp_nav->get_terrain_source()) {
case AC_WPNav::TerrainSource::TERRAIN_UNAVAILABLE:
alt_type = ReturnTargetAltType::RELATIVE
AP::logger().Write_Error(LogErrorSubsystem::NAVIGATION, LogErrorCode::RTL_MISSING_RNGFND)
gcs().send_text(MAV_SEVERITY_CRITICAL, ""RTL: no terrain data, using alt-above-home"")
break
case AC_WPNav::TerrainSource::TERRAIN_FROM_RANGEFINDER:
alt_type = ReturnTargetAltType::RANGEFINDER
break
case AC_WPNav::TerrainSource::TERRAIN_FROM_TERRAINDATABASE:
alt_type = ReturnTargetAltType::TERRAINDATABASE
break
}
}

if (alt_type == ReturnTargetAltType::RANGEFINDER) {
if (copter.get_rangefinder_height_interpolated_cm(curr_alt)) {
rtl_path.return_target.set_alt_cm(MAX(curr_alt + MAX(0, g.rtl_climb_min), MAX(g.rtl_altitude, RTL_ALT_MIN)), Location::AltFrame::ABOVE_TERRAIN)
} else {
alt_type = ReturnTargetAltType::RELATIVE
gcs().send_text(MAV_SEVERITY_CRITICAL, ""RTL: rangefinder unhealthy, using alt-above-home"")
AP::logger().Write_Error(LogErrorSubsystem::NAVIGATION, LogErrorCode::RTL_MISSING_RNGFND)
}
}

if (alt_type == ReturnTargetAltType::TERRAINDATABASE) {
int32_t curr_terr_alt
if (copter.current_loc.get_alt_cm(Location::AltFrame::ABOVE_TERRAIN, curr_terr_alt) &&
rtl_path.return_target.change_alt_frame(Location::AltFrame::ABOVE_TERRAIN)) {
curr_alt = curr_terr_alt
} else {
alt_type = ReturnTargetAltType::RELATIVE
AP::logger().Write_Error(LogErrorSubsystem::TERRAIN, LogErrorCode::MISSING_TERRAIN_DATA)
gcs().send_text(MAV_SEVERITY_CRITICAL, ""RTL: no terrain data, using alt-above-home"")
}
}

if (alt_type == ReturnTargetAltType::RELATIVE) {
if (!rtl_path.return_target.change_alt_frame(Location::AltFrame::ABOVE_HOME)) {
rtl_path.return_target.set_alt_cm(0, Location::AltFrame::ABOVE_HOME)
gcs().send_text(MAV_SEVERITY_WARNING, ""RTL: unexpected error calculating target alt"")
}
}

int32_t target_alt = MAX(rtl_path.return_target.alt, 0)

target_alt = MAX(target_alt, curr_alt + MAX(0, g.rtl_climb_min))
target_alt = MAX(target_alt, MAX(g.rtl_altitude, RTL_ALT_MIN))

float rtl_return_dist_cm = rtl_path.return_target.get_distance(rtl_path.origin_point) * 100.0f
if (g.rtl_cone_slope >= RTL_MIN_CONE_SLOPE) {
target_alt = MAX(curr_alt, MIN(target_alt, MAX(rtl_return_dist_cm*g.rtl_cone_slope, curr_alt+RTL_ABS_MIN_CLIMB)))
}

rtl_path.return_target.set_alt_cm(target_alt, (alt_type == ReturnTargetAltType::RELATIVE) ? Location::AltFrame::ABOVE_HOME : Location::AltFrame::ABOVE_TERRAIN)

if ((copter.fence.get_enabled_fences() & AC_FENCE_TYPE_ALT_MAX) != 0) {
if (rtl_path.return_target.get_alt_cm(Location::AltFrame::ABOVE_HOME, target_alt)) {
float fence_alt = copter.fence.get_safe_alt_max()*100.0f
if (target_alt > fence_alt) {
rtl_path.return_target.alt -= (target_alt - fence_alt)
}
}
}

rtl_path.return_target.alt = MAX(rtl_path.return_target.alt, curr_alt)
}
"
511,Arducopter\mode_rtl.cpp_get_wp,"bool ModeRTL::get_wp(Location& destination) const
{
switch (_state) {
case SubMode::STARTING:
case SubMode::INITIAL_CLIMB:
case SubMode::RETURN_HOME:
case SubMode::LOITER_AT_HOME:
case SubMode::FINAL_DESCENT:
return wp_nav->get_oa_wp_destination(destination)
case SubMode::LAND:
return false
}

return false
}
"
512,Arducopter\mode_rtl.cpp_wp_distance,"uint32_t ModeRTL::wp_distance() const
{
return wp_nav->get_wp_distance_to_destination()
}
"
513,Arducopter\mode_rtl.cpp_wp_bearing,"int32_t ModeRTL::wp_bearing() const
{
return wp_nav->get_wp_bearing_to_destination()
}
"
514,Arducopter\mode_rtl.cpp_use_pilot_yaw,"bool ModeRTL::use_pilot_yaw(void) const
{
return (copter.g2.rtl_options.get() & uint32_t(Options::IgnorePilotYaw)) == 0
}
"
515,Arducopter\mode_smart_rtl.cpp_init,"bool ModeSmartRTL::init(bool ignore_checks)
{
if (g2.smart_rtl.is_active()) {
wp_nav->wp_and_spline_init()

Vector3p stopping_point
pos_control->get_stopping_point_xy_cm(stopping_point.xy())
pos_control->get_stopping_point_z_cm(stopping_point.z)
wp_nav->set_wp_destination(stopping_point.tofloat())

auto_yaw.set_mode_to_default(true)

smart_rtl_state = SubMode::WAIT_FOR_PATH_CLEANUP
return true
}

return false
}
"
516,Arducopter\mode_smart_rtl.cpp_exit,"void ModeSmartRTL::exit()
{
g2.smart_rtl.cancel_request_for_thorough_cleanup()
}
"
517,Arducopter\mode_smart_rtl.cpp_run,"void ModeSmartRTL::run()
{
switch (smart_rtl_state) {
case SubMode::WAIT_FOR_PATH_CLEANUP:
wait_cleanup_run()
break
case SubMode::PATH_FOLLOW:
path_follow_run()
break
case SubMode::PRELAND_POSITION:
pre_land_position_run()
break
case SubMode::DESCEND:
descent_run()
break
case SubMode::LAND:
land_run(true)
break
}
}
"
518,Arducopter\mode_smart_rtl.cpp_is_landing,"bool ModeSmartRTL::is_landing() const
{
return smart_rtl_state == SubMode::LAND
}
"
519,Arducopter\mode_smart_rtl.cpp_wait_cleanup_run,"void ModeSmartRTL::wait_cleanup_run()
{
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)
wp_nav->update_wpnav()
pos_control->update_z_controller()
attitude_control->input_thrust_vector_heading(wp_nav->get_thrust_vector(), auto_yaw.yaw())

if (g2.smart_rtl.request_thorough_cleanup()) {
path_follow_last_pop_fail_ms = 0
smart_rtl_state = SubMode::PATH_FOLLOW
}
}
"
520,Arducopter\mode_smart_rtl.cpp_path_follow_run,"void ModeSmartRTL::path_follow_run()
{
float target_yaw_rate = 0.0f
if (!copter.failsafe.radio && use_pilot_yaw()) {
target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
if (!is_zero(target_yaw_rate)) {
auto_yaw.set_mode(AUTO_YAW_HOLD)
}
}

if (wp_nav->reached_wp_destination()) {
Vector3f dest_NED
if (g2.smart_rtl.pop_point(dest_NED)) {
path_follow_last_pop_fail_ms = 0
if (g2.smart_rtl.get_num_points() == 0) {
dest_NED.z -= 2.0f
smart_rtl_state = SubMode::PRELAND_POSITION
wp_nav->set_wp_destination_NED(dest_NED)
} else {
Vector3f next_dest_NED
if (g2.smart_rtl.peek_point(next_dest_NED)) {
wp_nav->set_wp_destination_NED(dest_NED)
if (g2.smart_rtl.get_num_points() == 1) {
next_dest_NED.z -= 2.0f
}
wp_nav->set_wp_destination_next_NED(next_dest_NED)
} else {
wp_nav->set_wp_destination_NED(dest_NED)
INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control)
}
}
} else if (g2.smart_rtl.get_num_points() == 0) {
INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control)
smart_rtl_state = SubMode::PRELAND_POSITION
} else if (path_follow_last_pop_fail_ms == 0) {
path_follow_last_pop_fail_ms = AP_HAL::millis()
} else if (AP_HAL::millis() - path_follow_last_pop_fail_ms > 10000) {
INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control)
smart_rtl_state = SubMode::PRELAND_POSITION
}
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)
wp_nav->update_wpnav()
pos_control->update_z_controller()

if (auto_yaw.mode() == AUTO_YAW_HOLD) {
attitude_control->input_thrust_vector_rate_heading(wp_nav->get_thrust_vector(), target_yaw_rate)
} else {
attitude_control->input_thrust_vector_heading(wp_nav->get_thrust_vector(), auto_yaw.yaw())
}
}
"
521,Arducopter\mode_smart_rtl.cpp_pre_land_position_run,"void ModeSmartRTL::pre_land_position_run()
{
if (wp_nav->reached_wp_destination()) {
if (g.rtl_alt_final <= 0 || copter.failsafe.radio) {
land_start()
smart_rtl_state = SubMode::LAND
} else {
set_descent_target_alt(copter.g.rtl_alt_final)
descent_start()
smart_rtl_state = SubMode::DESCEND
}
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)
wp_nav->update_wpnav()
pos_control->update_z_controller()
attitude_control->input_thrust_vector_heading(wp_nav->get_thrust_vector(), auto_yaw.yaw())
}
"
522,Arducopter\mode_smart_rtl.cpp_save_position,"void ModeSmartRTL::save_position()
{
const bool should_save_position = motors->armed() && (copter.flightmode->mode_number() != Mode::Number::SMART_RTL)

copter.g2.smart_rtl.update(copter.position_ok(), should_save_position)
}
"
523,Arducopter\mode_smart_rtl.cpp_get_wp,"bool ModeSmartRTL::get_wp(Location& destination) const
{
switch (smart_rtl_state) {
case SubMode::WAIT_FOR_PATH_CLEANUP:
case SubMode::PATH_FOLLOW:
case SubMode::PRELAND_POSITION:
case SubMode::DESCEND:
return wp_nav->get_wp_destination_loc(destination)
case SubMode::LAND:
return false
}

return false
}
"
524,Arducopter\mode_smart_rtl.cpp_wp_distance,"uint32_t ModeSmartRTL::wp_distance() const
{
return wp_nav->get_wp_distance_to_destination()
}
"
525,Arducopter\mode_smart_rtl.cpp_wp_bearing,"int32_t ModeSmartRTL::wp_bearing() const
{
return wp_nav->get_wp_bearing_to_destination()
}
"
526,Arducopter\mode_smart_rtl.cpp_use_pilot_yaw,"bool ModeSmartRTL::use_pilot_yaw() const
{
return g2.smart_rtl.use_pilot_yaw()
}
"
527,Arducopter\mode_sport.cpp_init,"bool ModeSport::init(bool ignore_checks)
{
pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)
pos_control->set_correction_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)

if (!pos_control->is_active_z()) {
pos_control->init_z_controller()
}

return true
}
"
528,Arducopter\mode_sport.cpp_run,"void ModeSport::run()
{
pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)

update_simple_mode()


float target_roll_rate = channel_roll->get_control_in() * g2.command_model_acro_rp.get_rate() * 100.0 / ROLL_PITCH_YAW_INPUT_MAX
float target_pitch_rate = channel_pitch->get_control_in() * g2.command_model_acro_rp.get_rate() * 100.0 / ROLL_PITCH_YAW_INPUT_MAX

const Vector3f att_target = attitude_control->get_att_target_euler_cd()

int32_t roll_angle = wrap_180_cd(att_target.x)
target_roll_rate -= constrain_int32(roll_angle, -ACRO_LEVEL_MAX_ANGLE, ACRO_LEVEL_MAX_ANGLE) * g.acro_balance_roll

int32_t pitch_angle = wrap_180_cd(att_target.y)
target_pitch_rate -= constrain_int32(pitch_angle, -ACRO_LEVEL_MAX_ANGLE, ACRO_LEVEL_MAX_ANGLE) * g.acro_balance_pitch

const float angle_max = copter.aparm.angle_max
if (roll_angle > angle_max){
target_roll_rate +=  sqrt_controller(angle_max - roll_angle, g2.command_model_acro_rp.get_rate() * 100.0 / ACRO_LEVEL_MAX_OVERSHOOT, attitude_control->get_accel_roll_max_cdss(), G_Dt)
}else if (roll_angle < -angle_max) {
target_roll_rate +=  sqrt_controller(-angle_max - roll_angle, g2.command_model_acro_rp.get_rate() * 100.0 / ACRO_LEVEL_MAX_OVERSHOOT, attitude_control->get_accel_roll_max_cdss(), G_Dt)
}

if (pitch_angle > angle_max){
target_pitch_rate +=  sqrt_controller(angle_max - pitch_angle, g2.command_model_acro_rp.get_rate() * 100.0 / ACRO_LEVEL_MAX_OVERSHOOT, attitude_control->get_accel_pitch_max_cdss(), G_Dt)
}else if (pitch_angle < -angle_max) {
target_pitch_rate +=  sqrt_controller(-angle_max - pitch_angle, g2.command_model_acro_rp.get_rate() * 100.0 / ACRO_LEVEL_MAX_OVERSHOOT, attitude_control->get_accel_pitch_max_cdss(), G_Dt)
}

float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())

float target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->get_control_in())
target_climb_rate = constrain_float(target_climb_rate, -get_pilot_speed_dn(), g.pilot_speed_up)

AltHoldModeState sport_state = get_alt_hold_state(target_climb_rate)

switch (sport_state) {

case AltHold_MotorStopped:
attitude_control->reset_rate_controller_I_terms()
attitude_control->reset_yaw_target_and_rate(false)
pos_control->relax_z_controller(0.0f)
break

case AltHold_Landed_Ground_Idle:
attitude_control->reset_yaw_target_and_rate()
FALLTHROUGH

case AltHold_Landed_Pre_Takeoff:
attitude_control->reset_rate_controller_I_terms_smoothly()
pos_control->relax_z_controller(0.0f)
break

case AltHold_Takeoff:
if (!takeoff.running()) {
takeoff.start(constrain_float(g.pilot_takeoff_alt,0.0f,1000.0f))
}

target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate)

takeoff.do_pilot_takeoff(target_climb_rate)
break

case AltHold_Flying:
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate)

copter.surface_tracking.update_surface_offset()

pos_control->set_pos_target_z_from_climb_rate_cm(target_climb_rate)
break
}

attitude_control->input_euler_rate_roll_pitch_yaw(target_roll_rate, target_pitch_rate, target_yaw_rate)

pos_control->update_z_controller()
}
"
529,Arducopter\mode_stabilize.cpp_run,"void ModeStabilize::run()
{
update_simple_mode()

float target_roll, target_pitch
get_pilot_desired_lean_angles(target_roll, target_pitch, copter.aparm.angle_max, copter.aparm.angle_max)

float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())

if (!motors->armed()) {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::SHUT_DOWN)
} else if (copter.ap.throttle_zero
|| (copter.air_mode == AirMode::AIRMODE_ENABLED && motors->get_spool_state() == AP_Motors::SpoolState::SHUT_DOWN)) {

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE)
} else {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)
}

float pilot_desired_throttle = get_pilot_desired_throttle()

switch (motors->get_spool_state()) {
case AP_Motors::SpoolState::SHUT_DOWN:
attitude_control->reset_yaw_target_and_rate()
attitude_control->reset_rate_controller_I_terms()
pilot_desired_throttle = 0.0f
break

case AP_Motors::SpoolState::GROUND_IDLE:
attitude_control->reset_yaw_target_and_rate()
attitude_control->reset_rate_controller_I_terms_smoothly()
pilot_desired_throttle = 0.0f
break

case AP_Motors::SpoolState::THROTTLE_UNLIMITED:
if (!motors->limit.throttle_lower) {
set_land_complete(false)
}
break

case AP_Motors::SpoolState::SPOOLING_UP:
case AP_Motors::SpoolState::SPOOLING_DOWN:
break
}

attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate)

attitude_control->set_throttle_out(pilot_desired_throttle, true, g.throttle_filt)
}
"
530,Arducopter\mode_stabilize_heli.cpp_init,"bool ModeStabilize_Heli::init(bool ignore_checks)
{

copter.input_manager.set_use_stab_col(true)

return true
}
"
531,Arducopter\mode_stabilize_heli.cpp_run,"void ModeStabilize_Heli::run()
{
float target_roll, target_pitch
float pilot_throttle_scaled

update_simple_mode()

get_pilot_desired_lean_angles(target_roll, target_pitch, copter.aparm.angle_max, copter.aparm.angle_max)

float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())

pilot_throttle_scaled = copter.input_manager.get_pilot_desired_collective(channel_throttle->get_control_in())


if (!motors->armed()) {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::SHUT_DOWN)
} else {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)
}

switch (motors->get_spool_state()) {
case AP_Motors::SpoolState::SHUT_DOWN:
attitude_control->reset_yaw_target_and_rate(false)
attitude_control->reset_rate_controller_I_terms()
break
case AP_Motors::SpoolState::GROUND_IDLE:
if ((motors->init_targets_on_arming() && motors->using_leaky_integrator()) || (copter.ap.land_complete && !motors->using_leaky_integrator())) {
attitude_control->reset_yaw_target_and_rate(false)
attitude_control->reset_rate_controller_I_terms_smoothly()
}
break
case AP_Motors::SpoolState::THROTTLE_UNLIMITED:
if (copter.ap.land_complete && !motors->using_leaky_integrator()) {
attitude_control->reset_rate_controller_I_terms_smoothly()
}
break
case AP_Motors::SpoolState::SPOOLING_UP:
case AP_Motors::SpoolState::SPOOLING_DOWN:
break
}

attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate)

attitude_control->set_throttle_out(pilot_throttle_scaled, false, g.throttle_filt)
}
"
532,Arducopter\mode_systemid.cpp_ModeSystemId,"ModeSystemId::ModeSystemId(void) : Mode()
{
AP_Param::setup_object_defaults(this, var_info)
}
"
533,Arducopter\mode_systemid.cpp_init,"bool ModeSystemId::init(bool ignore_checks)
{
if (axis == 0) {
gcs().send_text(MAV_SEVERITY_WARNING, ""No axis selected, SID_AXIS = 0"")
return false
}

if (motors->armed() && copter.ap.land_complete && !copter.flightmode->has_manual_throttle()) {
return false
}

copter.input_manager.set_use_stab_col(true)

att_bf_feedforward = attitude_control->get_bf_feedforward()
waveform_time = 0.0f
time_const_freq = 2.0f / frequency_start
systemid_state = SystemIDModeState::SYSTEMID_STATE_TESTING
log_subsample = 0

chirp_input.init(time_record, frequency_start, frequency_stop, time_fade_in, time_fade_out, time_const_freq)

gcs().send_text(MAV_SEVERITY_INFO, ""SystemID Starting: axis=%d"", (unsigned)axis)

copter.Log_Write_SysID_Setup(axis, waveform_magnitude, frequency_start, frequency_stop, time_fade_in, time_const_freq, time_record, time_fade_out)

return true
}
"
534,Arducopter\mode_systemid.cpp_exit,"void ModeSystemId::exit()
{
attitude_control->bf_feedforward(att_bf_feedforward)
}
"
535,Arducopter\mode_systemid.cpp_run,"void ModeSystemId::run()
{
update_simple_mode()

float target_roll, target_pitch
get_pilot_desired_lean_angles(target_roll, target_pitch, copter.aparm.angle_max, copter.aparm.angle_max)

float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())

if (!motors->armed()) {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::SHUT_DOWN)
} else if (copter.ap.throttle_zero && !copter.is_tradheli()) {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE)
} else {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)
}

switch (motors->get_spool_state()) {
case AP_Motors::SpoolState::SHUT_DOWN:
attitude_control->reset_yaw_target_and_rate()
attitude_control->reset_rate_controller_I_terms()
break

case AP_Motors::SpoolState::GROUND_IDLE:
if (motors->init_targets_on_arming()) {
attitude_control->reset_yaw_target_and_rate()
attitude_control->reset_rate_controller_I_terms_smoothly()
}
break

case AP_Motors::SpoolState::THROTTLE_UNLIMITED:
if (!motors->limit.throttle_lower) {
set_land_complete(false)
}
break

case AP_Motors::SpoolState::SPOOLING_UP:
case AP_Motors::SpoolState::SPOOLING_DOWN:
break
}

float pilot_throttle_scaled = copter.input_manager.get_pilot_desired_collective(channel_throttle->get_control_in())
float pilot_throttle_scaled = get_pilot_desired_throttle()

if ((systemid_state == SystemIDModeState::SYSTEMID_STATE_TESTING) &&
(!is_positive(frequency_start) || !is_positive(frequency_stop) || is_negative(time_fade_in) || !is_positive(time_record) || is_negative(time_fade_out) || (time_record <= time_const_freq))) {
systemid_state = SystemIDModeState::SYSTEMID_STATE_STOPPED
gcs().send_text(MAV_SEVERITY_INFO, ""SystemID Parameter Error"")
}

waveform_time += G_Dt
waveform_sample = chirp_input.update(waveform_time - SYSTEM_ID_DELAY, waveform_magnitude)
waveform_freq_rads = chirp_input.get_frequency_rads()

switch (systemid_state) {
case SystemIDModeState::SYSTEMID_STATE_STOPPED:
attitude_control->bf_feedforward(att_bf_feedforward)
break
case SystemIDModeState::SYSTEMID_STATE_TESTING:

if (copter.ap.land_complete) {
systemid_state = SystemIDModeState::SYSTEMID_STATE_STOPPED
gcs().send_text(MAV_SEVERITY_INFO, ""SystemID Stopped: Landed"")
break
}
if (attitude_control->lean_angle_deg()*100 > attitude_control->lean_angle_max_cd()) {
systemid_state = SystemIDModeState::SYSTEMID_STATE_STOPPED
gcs().send_text(MAV_SEVERITY_INFO, ""SystemID Stopped: lean=%f max=%f"", (double)attitude_control->lean_angle_deg(), (double)attitude_control->lean_angle_max_cd())
break
}
if (waveform_time > SYSTEM_ID_DELAY + time_fade_in + time_const_freq + time_record + time_fade_out) {
systemid_state = SystemIDModeState::SYSTEMID_STATE_STOPPED
gcs().send_text(MAV_SEVERITY_INFO, ""SystemID Finished"")
break
}

switch ((AxisType)axis.get()) {
case AxisType::NONE:
systemid_state = SystemIDModeState::SYSTEMID_STATE_STOPPED
gcs().send_text(MAV_SEVERITY_INFO, ""SystemID Stopped: axis = 0"")
break
case AxisType::INPUT_ROLL:
target_roll += waveform_sample*100.0f
break
case AxisType::INPUT_PITCH:
target_pitch += waveform_sample*100.0f
break
case AxisType::INPUT_YAW:
target_yaw_rate += waveform_sample*100.0f
break
case AxisType::RECOVER_ROLL:
target_roll += waveform_sample*100.0f
attitude_control->bf_feedforward(false)
break
case AxisType::RECOVER_PITCH:
target_pitch += waveform_sample*100.0f
attitude_control->bf_feedforward(false)
break
case AxisType::RECOVER_YAW:
target_yaw_rate += waveform_sample*100.0f
attitude_control->bf_feedforward(false)
break
case AxisType::RATE_ROLL:
attitude_control->rate_bf_roll_sysid(radians(waveform_sample))
break
case AxisType::RATE_PITCH:
attitude_control->rate_bf_pitch_sysid(radians(waveform_sample))
break
case AxisType::RATE_YAW:
attitude_control->rate_bf_yaw_sysid(radians(waveform_sample))
break
case AxisType::MIX_ROLL:
attitude_control->actuator_roll_sysid(waveform_sample)
break
case AxisType::MIX_PITCH:
attitude_control->actuator_pitch_sysid(waveform_sample)
break
case AxisType::MIX_YAW:
attitude_control->actuator_yaw_sysid(waveform_sample)
break
case AxisType::MIX_THROTTLE:
pilot_throttle_scaled += waveform_sample
break
}
break
}

attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate)

if (copter.is_tradheli()) {
attitude_control->set_throttle_out(pilot_throttle_scaled, false, g.throttle_filt)
} else {
attitude_control->set_throttle_out(pilot_throttle_scaled, true, g.throttle_filt)
}

if (log_subsample <= 0) {
log_data()
if (copter.should_log(MASK_LOG_ATTITUDE_FAST) && copter.should_log(MASK_LOG_ATTITUDE_MED)) {
log_subsample = 1
} else if (copter.should_log(MASK_LOG_ATTITUDE_FAST)) {
log_subsample = 2
} else if (copter.should_log(MASK_LOG_ATTITUDE_MED)) {
log_subsample = 4
} else {
log_subsample = 8
}
}
log_subsample -= 1
}
"
536,Arducopter\mode_systemid.cpp_log_data,"void ModeSystemId::log_data() const
{
Vector3f delta_angle
float delta_angle_dt
copter.ins.get_delta_angle(delta_angle, delta_angle_dt)

Vector3f delta_velocity
float delta_velocity_dt
copter.ins.get_delta_velocity(delta_velocity, delta_velocity_dt)

if (is_positive(delta_angle_dt) && is_positive(delta_velocity_dt)) {
copter.Log_Write_SysID_Data(waveform_time, waveform_sample, waveform_freq_rads / (2 * M_PI), degrees(delta_angle.x / delta_angle_dt), degrees(delta_angle.y / delta_angle_dt), degrees(delta_angle.z / delta_angle_dt), delta_velocity.x / delta_velocity_dt, delta_velocity.y / delta_velocity_dt, delta_velocity.z / delta_velocity_dt)
}

copter.Log_Write_Attitude()
}
"
537,Arducopter\mode_throw.cpp_init,"bool ModeThrow::init(bool ignore_checks)
{
return false

if (motors->armed()) {
return false
}

stage = Throw_Disarmed
nextmode_attempted = false

pos_control->set_max_speed_accel_xy(wp_nav->get_default_speed_xy(), BRAKE_MODE_DECEL_RATE)
pos_control->set_correction_speed_accel_xy(wp_nav->get_default_speed_xy(), BRAKE_MODE_DECEL_RATE)

pos_control->set_max_speed_accel_z(BRAKE_MODE_SPEED_Z, BRAKE_MODE_SPEED_Z, BRAKE_MODE_DECEL_RATE)
pos_control->set_correction_speed_accel_z(BRAKE_MODE_SPEED_Z, BRAKE_MODE_SPEED_Z, BRAKE_MODE_DECEL_RATE)

return true
}
"
538,Arducopter\mode_throw.cpp_run,"void ModeThrow::run()
{
Throw_Disarmed - motors are off
Throw_Detecting -  motors are on and we are waiting for the throw
Throw_Uprighting - the throw has been detected and the copter is being uprighted
Throw_HgtStabilise - the copter is kept level and  height is stabilised about the target height
Throw_PosHold - the copter is kept at a constant position and height

if (!motors->armed()) {
stage = Throw_Disarmed

} else if (stage == Throw_Disarmed && motors->armed()) {
gcs().send_text(MAV_SEVERITY_INFO,""waiting for throw"")
stage = Throw_Detecting

} else if (stage == Throw_Detecting && throw_detected()){
gcs().send_text(MAV_SEVERITY_INFO,""throw detected - spooling motors"")
copter.set_land_complete(false)
stage = Throw_Wait_Throttle_Unlimited

AP_Notify::flags.waiting_for_throw = false

} else if (stage == Throw_Wait_Throttle_Unlimited &&
motors->get_spool_state() == AP_Motors::SpoolState::THROTTLE_UNLIMITED) {
gcs().send_text(MAV_SEVERITY_INFO,""throttle is unlimited - uprighting"")
stage = Throw_Uprighting
} else if (stage == Throw_Uprighting && throw_attitude_good()) {
gcs().send_text(MAV_SEVERITY_INFO,""uprighted - controlling height"")
stage = Throw_HgtStabilise

pos_control->init_z_controller_no_descent()

if (g2.throw_type == ThrowType::Drop) {
pos_control->set_pos_target_z_cm(inertial_nav.get_position_z_up_cm() - 100)
} else {
pos_control->set_pos_target_z_cm(inertial_nav.get_position_z_up_cm() + 300)
}

copter.set_auto_armed(true)

} else if (stage == Throw_HgtStabilise && throw_height_good()) {
gcs().send_text(MAV_SEVERITY_INFO,""height achieved - controlling position"")
stage = Throw_PosHold

pos_control->init_xy_controller()

copter.set_auto_armed(true)
} else if (stage == Throw_PosHold && throw_position_good()) {
if (!nextmode_attempted) {
switch ((Mode::Number)g2.throw_nextmode.get()) {
case Mode::Number::AUTO:
case Mode::Number::GUIDED:
case Mode::Number::RTL:
case Mode::Number::LAND:
case Mode::Number::BRAKE:
case Mode::Number::LOITER:
set_mode((Mode::Number)g2.throw_nextmode.get(), ModeReason::THROW_COMPLETE)
break
default:
break
}
nextmode_attempted = true
}
}

switch (stage) {

case Throw_Disarmed:

if (g.throw_motor_start == PreThrowMotorState::RUNNING) {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE)
} else {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::SHUT_DOWN)
}

attitude_control->reset_yaw_target_and_rate()
attitude_control->reset_rate_controller_I_terms()
attitude_control->set_throttle_out(0,true,g.throttle_filt)
break

case Throw_Detecting:

if (g.throw_motor_start == PreThrowMotorState::RUNNING) {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE)
} else {
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::SHUT_DOWN)
}

attitude_control->reset_yaw_target_and_rate()
attitude_control->reset_rate_controller_I_terms()
attitude_control->set_throttle_out(0,true,g.throttle_filt)

AP_Notify::flags.waiting_for_throw = true

break

case Throw_Wait_Throttle_Unlimited:

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

break

case Throw_Uprighting:

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0.0f, 0.0f, 0.0f)

attitude_control->set_throttle_out(0.5f, false, g.throttle_filt)

break

case Throw_HgtStabilise:

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0.0f, 0.0f, 0.0f)

pos_control->set_pos_target_z_from_climb_rate_cm(0.0f)
pos_control->update_z_controller()

break

case Throw_PosHold:

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

Vector2f vel
Vector2f accel
pos_control->input_vel_accel_xy(vel, accel)
pos_control->update_xy_controller()

attitude_control->input_thrust_vector_rate_heading(pos_control->get_thrust_vector(), 0.0f)

pos_control->set_pos_target_z_from_climb_rate_cm(0.0f)
pos_control->update_z_controller()

break
}

uint32_t now = AP_HAL::millis()
if ((stage != prev_stage) || (now - last_log_ms) > 100) {
prev_stage = stage
last_log_ms = now
const float velocity = inertial_nav.get_velocity_neu_cms().length()
const float velocity_z = inertial_nav.get_velocity_z_up_cms()
const float accel = copter.ins.get_accel().length()
const float ef_accel_z = ahrs.get_accel_ef().z
const bool throw_detect = (stage > Throw_Detecting) || throw_detected()
const bool attitude_ok = (stage > Throw_Uprighting) || throw_attitude_good()
const bool height_ok = (stage > Throw_HgtStabilise) || throw_height_good()
const bool pos_ok = (stage > Throw_PosHold) || throw_position_good()


AP::logger().WriteStreaming(
""THRO"",
""TimeUS,Stage,Vel,VelZ,Acc,AccEfZ,Throw,AttOk,HgtOk,PosOk"",
""s-nnoo----"",
""F-0000----"",
""QBffffbbbb"",
AP_HAL::micros64(),
(uint8_t)stage,
(double)velocity,
(double)velocity_z,
(double)accel,
(double)ef_accel_z,
throw_detect,
attitude_ok,
height_ok,
pos_ok)
}
}
"
539,Arducopter\mode_throw.cpp_throw_detected,"bool ModeThrow::throw_detected()
{
nav_filter_status filt_status = inertial_nav.get_filter_status()
if (!filt_status.flags.attitude || !filt_status.flags.horiz_pos_abs || !filt_status.flags.vert_pos) {
return false
}

bool high_speed = inertial_nav.get_velocity_neu_cms().length_squared() > (THROW_HIGH_SPEED * THROW_HIGH_SPEED)

bool changing_height
if (g2.throw_type == ThrowType::Drop) {
changing_height = inertial_nav.get_velocity_z_up_cms() < -THROW_VERTICAL_SPEED
} else {
changing_height = inertial_nav.get_velocity_z_up_cms() > THROW_VERTICAL_SPEED
}

bool free_falling = ahrs.get_accel_ef().z > -0.25 * GRAVITY_MSS

bool no_throw_action = copter.ins.get_accel().length() < 1.0f * GRAVITY_MSS

bool possible_throw_detected = (free_falling || high_speed) && changing_height && no_throw_action

if (possible_throw_detected && ((AP_HAL::millis() - free_fall_start_ms) > 500)) {
free_fall_start_ms = AP_HAL::millis()
free_fall_start_velz = inertial_nav.get_velocity_z_up_cms()
}

bool throw_condition_confirmed = ((AP_HAL::millis() - free_fall_start_ms < 500) && ((inertial_nav.get_velocity_z_up_cms() - free_fall_start_velz) < -250.0f))

return throw_condition_confirmed
}
"
540,Arducopter\mode_throw.cpp_throw_attitude_good,"bool ModeThrow::throw_attitude_good() const
{
const Matrix3f &rotMat = ahrs.get_rotation_body_to_ned()
return (rotMat.c.z > 0.866f)
}
"
541,Arducopter\mode_throw.cpp_throw_height_good,"bool ModeThrow::throw_height_good() const
{
return (pos_control->get_pos_error_z_cm() < 50.0f)
}
"
542,Arducopter\mode_throw.cpp_throw_position_good,"bool ModeThrow::throw_position_good() const
{
return (pos_control->get_pos_error_xy_cm() < 50.0f)
}
"
543,Arducopter\mode_turtle.cpp_init,"bool ModeTurtle::init(bool ignore_checks)
{
if (motors->armed() || SRV_Channels::get_dshot_esc_type() == 0) {
return false
}

if (!copter.mavlink_motor_control_check(*gcs().chan(0), true, ""Turtle Mode"")) {
return false
}

if (!is_zero(channel_pitch->norm_input_dz())
|| !is_zero(channel_roll->norm_input_dz())
|| !is_zero(channel_yaw->norm_input_dz())) {
return false
}
hal.rcout->disable_channel_mask_updates()
change_motor_direction(true)

g.failsafe_throttle.set(FS_THR_DISABLED)
g.failsafe_gcs.set(FS_GCS_DISABLED)
g.fs_ekf_action.set(0)

motors->armed(true)
hal.util->set_soft_armed(true)

return true
}
"
544,Arducopter\mode_turtle.cpp_allows_arming,"bool ModeTurtle::allows_arming(AP_Arming::Method method) const
{
return true
}
"
545,Arducopter\mode_turtle.cpp_exit,"void ModeTurtle::exit()
{
motors->armed(false)
hal.util->set_soft_armed(false)

change_motor_direction(false)
hal.rcout->enable_channel_mask_updates()

g.failsafe_throttle.load()
g.failsafe_gcs.load()
g.fs_ekf_action.load()
}
"
546,Arducopter\mode_turtle.cpp_change_motor_direction,"void ModeTurtle::change_motor_direction(bool reverse)
{
AP_HAL::RCOutput::BLHeliDshotCommand direction = reverse ? AP_HAL::RCOutput::DSHOT_REVERSE : AP_HAL::RCOutput::DSHOT_NORMAL
AP_HAL::RCOutput::BLHeliDshotCommand inverse_direction = reverse ? AP_HAL::RCOutput::DSHOT_NORMAL : AP_HAL::RCOutput::DSHOT_REVERSE

if (!hal.rcout->get_reversed_mask()) {
hal.rcout->send_dshot_command(direction, AP_HAL::RCOutput::ALL_CHANNELS, 0, 10, true)
} else {
for (uint8_t i = 0
if (!motors->is_motor_enabled(i)) {
continue
}

if ((hal.rcout->get_reversed_mask() & (1U << i)) == 0) {
hal.rcout->send_dshot_command(direction, i, 0, 10, true)
} else {
hal.rcout->send_dshot_command(inverse_direction, i, 0, 10, true)
}
}
}
}
"
547,Arducopter\mode_turtle.cpp_run,"void ModeTurtle::run()
{
const float flip_power_factor = 1.0f - CRASH_FLIP_EXPO * 0.01f
const bool norc = copter.failsafe.radio || !copter.ap.rc_receiver_present
const float stick_deflection_pitch = norc ? 0.0f : channel_pitch->norm_input_dz()
const float stick_deflection_roll = norc ? 0.0f : channel_roll->norm_input_dz()
const float stick_deflection_yaw = norc ? 0.0f : channel_yaw->norm_input_dz()

const float stick_deflection_pitch_abs = fabsf(stick_deflection_pitch)
const float stick_deflection_roll_abs = fabsf(stick_deflection_roll)
const float stick_deflection_yaw_abs = fabsf(stick_deflection_yaw)

const float stick_deflection_pitch_expo = flip_power_factor * stick_deflection_pitch_abs + power3(stick_deflection_pitch_abs) * (1 - flip_power_factor)
const float stick_deflection_roll_expo = flip_power_factor * stick_deflection_roll_abs + power3(stick_deflection_roll_abs) * (1 - flip_power_factor)
const float stick_deflection_yaw_expo = flip_power_factor * stick_deflection_yaw_abs + power3(stick_deflection_yaw_abs) * (1 - flip_power_factor)

float sign_pitch = stick_deflection_pitch < 0 ? -1 : 1
float sign_roll = stick_deflection_roll < 0 ? 1 : -1

float stick_deflection_length = sqrtf(sq(stick_deflection_pitch_abs) + sq(stick_deflection_roll_abs))
float stick_deflection_expo_length = sqrtf(sq(stick_deflection_pitch_expo) + sq(stick_deflection_roll_expo))

if (stick_deflection_yaw_abs > MAX(stick_deflection_pitch_abs, stick_deflection_roll_abs)) {
stick_deflection_length = stick_deflection_yaw_abs
stick_deflection_expo_length = stick_deflection_yaw_expo
sign_roll = 0
sign_pitch = 0
}

const float cos_phi = (stick_deflection_length > 0) ? (stick_deflection_pitch_abs + stick_deflection_roll_abs) / (sqrtf(2.0f) * stick_deflection_length) : 0
const float cos_threshold = sqrtf(3.0f) / 2.0f

if (cos_phi < cos_threshold) {
if (stick_deflection_roll_abs > stick_deflection_pitch_abs) {
sign_pitch = 0
} else {
sign_roll = 0
}
}

const float crash_flip_stick_min_expo = flip_power_factor * CRASH_FLIP_STICK_MINF + power3(CRASH_FLIP_STICK_MINF) * (1 - flip_power_factor)
const float flip_stick_range = 1.0f - crash_flip_stick_min_expo
const float flip_power = MAX(0.0f, stick_deflection_expo_length - crash_flip_stick_min_expo) / flip_stick_range


Vector2f input{sign_roll, sign_pitch}
motors_input = input.normalized() * 0.5
motors_output = !is_zero(flip_power) ? motors->thrust_to_actuator(flip_power) : 0.0f
}
"
548,Arducopter\mode_turtle.cpp_output_to_motors,"void ModeTurtle::output_to_motors()
{
const bool allow_output = motors->armed() && motors->get_interlock()

for (uint8_t i = 0
if (!motors->is_motor_enabled(i)) {
continue
}

const Vector2f output{motors->get_roll_factor(i), motors->get_pitch_factor(i)}
if (!allow_output || (motors_input - output).length() > 0.5) {
motors->rc_write(i, motors->get_pwm_output_min())
continue
}

int16_t pwm = motors->get_pwm_output_min() + (motors->get_pwm_output_max() - motors->get_pwm_output_min()) * motors_output

motors->rc_write(i, pwm)
}
}
"
549,Arducopter\mode_zigzag.cpp_ModeZigZag,"ModeZigZag::ModeZigZag(void) : Mode()
{
AP_Param::setup_object_defaults(this, var_info)
}
"
550,Arducopter\mode_zigzag.cpp_init,"bool ModeZigZag::init(bool ignore_checks)
{
if (!copter.failsafe.radio) {
update_simple_mode()

float target_roll, target_pitch
get_pilot_desired_lean_angles(target_roll, target_pitch, loiter_nav->get_angle_max_cd(), attitude_control->get_althold_lean_angle_max_cd())

loiter_nav->set_pilot_desired_acceleration(target_roll, target_pitch)
} else {
loiter_nav->clear_pilot_desired_acceleration()
}
loiter_nav->init_target()

pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)
pos_control->set_correction_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)

if (!pos_control->is_active_z()) {
pos_control->init_z_controller()
}

stage = STORING_POINTS
dest_A.zero()
dest_B.zero()

init_auto()

return true
}
"
551,Arducopter\mode_zigzag.cpp_exit,"void ModeZigZag::exit()
{
spray(false)
}
"
552,Arducopter\mode_zigzag.cpp_run,"void ModeZigZag::run()
{
pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z)

zigzag_direction = (Direction)constrain_int16(_direction, 0, 3)
line_num = constrain_int16(_line_num, ZIGZAG_LINE_INFINITY, 32767)

if (stage == AUTO) {
if (is_disarmed_or_landed() || !motors->get_interlock()) {
return_to_manual_control(false)
} else if (reached_destination()) {
AP_Notify::events.waypoint_complete = 1
if (is_auto) {
if (line_num == ZIGZAG_LINE_INFINITY || line_count < line_num) {
if (auto_stage == AutoState::SIDEWAYS) {
save_or_move_to_destination((ab_dest_stored == Destination::A) ? Destination::B : Destination::A)
} else {
spray(false)
move_to_side()
}
} else {
init_auto()
return_to_manual_control(true)
}
} else {
return_to_manual_control(true)
}
} else {
auto_control()
}
}

if (stage == STORING_POINTS || stage == MANUAL_REGAIN) {
manual_control()
}
}
"
553,Arducopter\mode_zigzag.cpp_save_or_move_to_destination,"void ModeZigZag::save_or_move_to_destination(Destination ab_dest)
{
const Vector2f curr_pos {inertial_nav.get_position_xy_cm()}

switch (stage) {

case STORING_POINTS:
if (ab_dest == Destination::A) {
dest_A = curr_pos
gcs().send_text(MAV_SEVERITY_INFO, ""ZigZag: point A stored"")
AP::logger().Write_Event(LogEvent::ZIGZAG_STORE_A)
} else {
dest_B = curr_pos
gcs().send_text(MAV_SEVERITY_INFO, ""ZigZag: point B stored"")
AP::logger().Write_Event(LogEvent::ZIGZAG_STORE_B)
}
if (!dest_A.is_zero() && !dest_B.is_zero() && !is_zero((dest_B - dest_A).length_squared())) {
stage = MANUAL_REGAIN
spray(false)
} else if (!dest_A.is_zero() || !dest_B.is_zero()) {
spray(true)
}
break

case AUTO:
case MANUAL_REGAIN:
Vector3f next_dest
bool terr_alt
if (calculate_next_dest(ab_dest, stage == AUTO, next_dest, terr_alt)) {
wp_nav->wp_and_spline_init()
if (wp_nav->set_wp_destination(next_dest, terr_alt)) {
stage = AUTO
auto_stage = AutoState::AB_MOVING
ab_dest_stored = ab_dest
spray(true)
reach_wp_time_ms = 0
if (is_auto == false || line_num == ZIGZAG_LINE_INFINITY) {
gcs().send_text(MAV_SEVERITY_INFO, ""ZigZag: moving to %s"", (ab_dest == Destination::A) ? ""A"" : ""B"")
} else {
line_count++
gcs().send_text(MAV_SEVERITY_INFO, ""ZigZag: moving to %s (line %d/%d)"", (ab_dest == Destination::A) ? ""A"" : ""B"", line_count, line_num)
}
}
}
break
}
}
"
554,Arducopter\mode_zigzag.cpp_move_to_side,"void ModeZigZag::move_to_side()
{
if (!dest_A.is_zero() && !dest_B.is_zero() && !is_zero((dest_B - dest_A).length_squared())) {
Vector3f next_dest
bool terr_alt
if (calculate_side_dest(next_dest, terr_alt)) {
wp_nav->wp_and_spline_init()
if (wp_nav->set_wp_destination(next_dest, terr_alt)) {
stage = AUTO
auto_stage = AutoState::SIDEWAYS
current_dest = next_dest
current_terr_alt = terr_alt
reach_wp_time_ms = 0
char const *dir[] = {""forward"", ""right"", ""backward"", ""left""}
gcs().send_text(MAV_SEVERITY_INFO, ""ZigZag: moving to %s"", dir[(uint8_t)zigzag_direction])
}
}
}
}
"
555,Arducopter\mode_zigzag.cpp_return_to_manual_control,"void ModeZigZag::return_to_manual_control(bool maintain_target)
{
if (stage == AUTO) {
stage = MANUAL_REGAIN
spray(false)
loiter_nav->clear_pilot_desired_acceleration()
if (maintain_target) {
const Vector3f& wp_dest = wp_nav->get_wp_destination()
loiter_nav->init_target(wp_dest.xy())
if (wp_nav->origin_and_destination_are_terrain_alt()) {
copter.surface_tracking.set_target_alt_cm(wp_dest.z)
}
} else {
loiter_nav->init_target()
}
is_auto = false
gcs().send_text(MAV_SEVERITY_INFO, ""ZigZag: manual control"")
}
}
"
556,Arducopter\mode_zigzag.cpp_auto_control,"void ModeZigZag::auto_control()
{
float target_yaw_rate = 0
if (!copter.failsafe.radio) {
target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

const bool wpnav_ok = wp_nav->update_wpnav()

pos_control->update_z_controller()

attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate)

if (!wpnav_ok) {
return_to_manual_control(false)
}
}
"
557,Arducopter\mode_zigzag.cpp_manual_control,"void ModeZigZag::manual_control()
{
float target_yaw_rate = 0.0f
float target_climb_rate = 0.0f

if (!copter.failsafe.radio) {
float target_roll, target_pitch
update_simple_mode()

get_pilot_desired_lean_angles(target_roll, target_pitch, loiter_nav->get_angle_max_cd(), attitude_control->get_althold_lean_angle_max_cd())

loiter_nav->set_pilot_desired_acceleration(target_roll, target_pitch)
target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())

target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->get_control_in())
target_climb_rate = constrain_float(target_climb_rate, -get_pilot_speed_dn(), g.pilot_speed_up)
} else {
loiter_nav->clear_pilot_desired_acceleration()
}

if (copter.ap.land_complete_maybe) {
loiter_nav->soften_for_landing()
}

AltHoldModeState althold_state = get_alt_hold_state(target_climb_rate)

switch (althold_state) {

case AltHold_MotorStopped:
attitude_control->reset_rate_controller_I_terms()
attitude_control->reset_yaw_target_and_rate()
pos_control->relax_z_controller(0.0f)
loiter_nav->init_target()
attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(loiter_nav->get_roll(), loiter_nav->get_pitch(), target_yaw_rate)
break

case AltHold_Takeoff:
if (!takeoff.running()) {
takeoff.start(constrain_float(g.pilot_takeoff_alt,0.0f,1000.0f))
}

target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate)

loiter_nav->update()

attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(loiter_nav->get_roll(), loiter_nav->get_pitch(), target_yaw_rate)

takeoff.do_pilot_takeoff(target_climb_rate)
break

case AltHold_Landed_Ground_Idle:
attitude_control->reset_yaw_target_and_rate()
FALLTHROUGH

case AltHold_Landed_Pre_Takeoff:
attitude_control->reset_rate_controller_I_terms_smoothly()
loiter_nav->init_target()
attitude_control->input_thrust_vector_rate_heading(loiter_nav->get_thrust_vector(), target_yaw_rate)
pos_control->relax_z_controller(0.0f)
break

case AltHold_Flying:
motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

loiter_nav->update()

attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(loiter_nav->get_roll(), loiter_nav->get_pitch(), target_yaw_rate)

target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate)

copter.surface_tracking.update_surface_offset()

pos_control->set_pos_target_z_from_climb_rate_cm(target_climb_rate)
break
}

pos_control->update_z_controller()
}
"
558,Arducopter\mode_zigzag.cpp_reached_destination,"bool ModeZigZag::reached_destination()
{
if (!wp_nav->reached_wp_destination()) {
return false
}

if (wp_nav->get_wp_distance_to_destination() > ZIGZAG_WP_RADIUS_CM) {
return false
}

uint32_t now = AP_HAL::millis()
if (reach_wp_time_ms == 0) {
reach_wp_time_ms = now
}
return ((now - reach_wp_time_ms) >= (uint16_t)constrain_int16(_wp_delay, 0, 127) * 1000)
}
"
559,Arducopter\mode_zigzag.cpp_calculate_next_dest,"bool ModeZigZag::calculate_next_dest(Destination ab_dest, bool use_wpnav_alt, Vector3f& next_dest, bool& terrain_alt) const
{
Vector2f start_pos = (ab_dest == Destination::A) ? dest_A : dest_B

Vector2f AB_diff = dest_B - dest_A

if (is_zero(AB_diff.length_squared())) {
return false
}

const Vector2f curr_pos2d {inertial_nav.get_position_xy_cm()}
Vector2f veh_to_start_pos = curr_pos2d - start_pos

float scalar = 1.0f
if (veh_to_start_pos.length_squared() > AB_diff.length_squared()) {
scalar = veh_to_start_pos.length() / AB_diff.length()
}

Vector2f perp1 = start_pos + Vector2f(-AB_diff[1] * scalar, AB_diff[0] * scalar)
Vector2f perp2 = start_pos + Vector2f(AB_diff[1] * scalar, -AB_diff[0] * scalar)

const Vector2f closest2d = Vector2f::closest_point(curr_pos2d, perp1, perp2)
next_dest.x = closest2d.x
next_dest.y = closest2d.y

if (use_wpnav_alt) {
terrain_alt = wp_nav->origin_and_destination_are_terrain_alt()
next_dest.z = wp_nav->get_wp_destination().z
} else {
terrain_alt = copter.rangefinder_alt_ok() && wp_nav->rangefinder_used_and_healthy()
if (terrain_alt) {
if (!copter.surface_tracking.get_target_alt_cm(next_dest.z)) {
next_dest.z = copter.rangefinder_state.alt_cm_filt.get()
}
} else {
next_dest.z = pos_control->is_active_z() ? pos_control->get_pos_target_z_cm() : inertial_nav.get_position_z_up_cm()
}
}

return true
}
"
560,Arducopter\mode_zigzag.cpp_calculate_side_dest,"bool ModeZigZag::calculate_side_dest(Vector3f& next_dest, bool& terrain_alt) const
{
Vector2f AB_diff = dest_B - dest_A

Vector2f AB_side
if (zigzag_direction == Direction::RIGHT || zigzag_direction == Direction::LEFT) {
float yaw_ab_sign = (-ahrs.sin_yaw() * AB_diff[1]) + (ahrs.cos_yaw() * -AB_diff[0])
if (is_positive(yaw_ab_sign * (zigzag_direction == Direction::RIGHT ? 1 : -1))) {
AB_side = Vector2f(AB_diff[1], -AB_diff[0])
} else {
AB_side = Vector2f(-AB_diff[1], AB_diff[0])
}
} else {
float yaw_ab_sign = (ahrs.cos_yaw() * AB_diff[1]) + (ahrs.sin_yaw() * -AB_diff[0])
if (is_positive(yaw_ab_sign * (zigzag_direction == Direction::FORWARD ? 1 : -1))) {
AB_side = Vector2f(AB_diff[1], -AB_diff[0])
} else {
AB_side = Vector2f(-AB_diff[1], AB_diff[0])
}
}

if (is_zero(AB_side.length_squared())) {
return false
}

float scalar = constrain_float(_side_dist, 0.1f, 100.0f) * 100 / safe_sqrt(AB_side.length_squared())

const Vector2f curr_pos2d {inertial_nav.get_position_xy_cm()}
next_dest.x = curr_pos2d.x + (AB_side.x * scalar)
next_dest.y = curr_pos2d.y + (AB_side.y * scalar)

terrain_alt = copter.rangefinder_alt_ok() && wp_nav->rangefinder_used_and_healthy()
if (terrain_alt) {
if (!copter.surface_tracking.get_target_alt_cm(next_dest.z)) {
next_dest.z = copter.rangefinder_state.alt_cm_filt.get()
}
} else {
next_dest.z = pos_control->is_active_z() ? pos_control->get_pos_target_z_cm() : inertial_nav.get_position_z_up_cm()
}

return true
}
"
561,Arducopter\mode_zigzag.cpp_run_auto,"void ModeZigZag::run_auto()
{
if (!_auto_enabled) {
return
}

if (stage != MANUAL_REGAIN) {
return
}

is_auto = true
if (is_suspended && line_count <= line_num) {
if (auto_stage == AutoState::AB_MOVING) {
line_count--
save_or_move_to_destination(ab_dest_stored)
} else if (auto_stage == AutoState::SIDEWAYS) {
wp_nav->wp_and_spline_init()
if (wp_nav->set_wp_destination(current_dest, current_terr_alt)) {
stage = AUTO
reach_wp_time_ms = 0
char const *dir[] = {""forward"", ""right"", ""backward"", ""left""}
gcs().send_text(MAV_SEVERITY_INFO, ""ZigZag: moving to %s"", dir[(uint8_t)zigzag_direction])
}
}
} else {
move_to_side()
}
}
"
562,Arducopter\mode_zigzag.cpp_suspend_auto,"void ModeZigZag::suspend_auto()
{
if (!_auto_enabled) {
return
}

if (auto_stage != AutoState::MANUAL) {
is_suspended = true
return_to_manual_control(true)
}
}
"
563,Arducopter\mode_zigzag.cpp_init_auto,"void ModeZigZag::init_auto()
{
is_auto = false
auto_stage = AutoState::MANUAL
line_count = 0
is_suspended = false
}
"
564,Arducopter\mode_zigzag.cpp_spray,"void ModeZigZag::spray(bool b)
{
if (_spray_enabled) {
copter.sprayer.run(b)
}
}
"
565,Arducopter\motors.cpp_arm_motors_check,"void Copter::arm_motors_check()
{
static int16_t arming_counter

AP_Arming::RudderArming arming_rudder = arming.get_rudder_arming_type()
if (arming_rudder == AP_Arming::RudderArming::IS_DISABLED) {
return
}

if (g2.toy_mode.enabled()) {
return
}

if (channel_throttle->get_control_in() > 0) {
arming_counter = 0
return
}

int16_t yaw_in = channel_yaw->get_control_in()

if (yaw_in > 4000) {

if (arming_counter <= AUTO_TRIM_DELAY) {
arming_counter++
}

if (arming_counter == ARM_DELAY && !motors->armed()) {
if (!arming.arm(AP_Arming::Method::RUDDER)) {
arming_counter = 0
}
}

if (arming_counter == AUTO_TRIM_DELAY && motors->armed() && flightmode->mode_number() == Mode::Number::STABILIZE) {
gcs().send_text(MAV_SEVERITY_INFO, ""AutoTrim start"")
auto_trim_counter = 250
auto_trim_started = false
auto_disarm_begin = millis()
}

} else if ((yaw_in < -4000) && (arming_rudder == AP_Arming::RudderArming::ARMDISARM)) {
if (!flightmode->has_manual_throttle() && !ap.land_complete) {
arming_counter = 0
return
}

if (arming_counter <= DISARM_DELAY) {
arming_counter++
}

if (arming_counter == DISARM_DELAY && motors->armed()) {
arming.disarm(AP_Arming::Method::RUDDER)
}

} else {
arming_counter = 0
}
}
"
566,Arducopter\motors.cpp_auto_disarm_check,"void Copter::auto_disarm_check()
{
uint32_t tnow_ms = millis()
uint32_t disarm_delay_ms = 1000*constrain_int16(g.disarm_delay, 0, 127)

if (!motors->armed() || disarm_delay_ms == 0 || flightmode->mode_number() == Mode::Number::THROW) {
auto_disarm_begin = tnow_ms
return
}

if (motors->get_spool_state() > AP_Motors::SpoolState::GROUND_IDLE) {
auto_disarm_begin = tnow_ms
return
}

if ((ap.using_interlock && !motors->get_interlock()) || SRV_Channels::get_emergency_stop()) {
disarm_delay_ms /= 2
} else {
bool sprung_throttle_stick = (g.throttle_behavior & THR_BEHAVE_FEEDBACK_FROM_MID_STICK) != 0
bool thr_low
if (flightmode->has_manual_throttle() || !sprung_throttle_stick) {
thr_low = ap.throttle_zero
} else {
float deadband_top = get_throttle_mid() + g.throttle_deadzone
thr_low = channel_throttle->get_control_in() <= deadband_top
}

if (!thr_low || !ap.land_complete) {
auto_disarm_begin = tnow_ms
}
}

if ((tnow_ms-auto_disarm_begin) >= disarm_delay_ms) {
arming.disarm(AP_Arming::Method::DISARMDELAY)
auto_disarm_begin = tnow_ms
}
}
"
567,Arducopter\motors.cpp_motors_output,"void Copter::motors_output()
{
if (g2.afs.should_crash_vehicle()) {
g2.afs.terminate_vehicle()
if (!g2.afs.terminating_vehicle_via_landing()) {
return
}
}

if (ap.in_arming_delay && (!motors->armed() || millis()-arm_time_ms > ARMING_DELAY_SEC*1.0e3f || flightmode->mode_number() == Mode::Number::THROW)) {
ap.in_arming_delay = false
}

SRV_Channels::calc_pwm()

SRV_Channels::cork()

SRV_Channels::output_ch_all()

bool interlock = motors->armed() && !ap.in_arming_delay && (!ap.using_interlock || ap.motor_interlock_switch) && !SRV_Channels::get_emergency_stop()
if (!motors->get_interlock() && interlock) {
motors->set_interlock(true)
AP::logger().Write_Event(LogEvent::MOTORS_INTERLOCK_ENABLED)
} else if (motors->get_interlock() && !interlock) {
motors->set_interlock(false)
AP::logger().Write_Event(LogEvent::MOTORS_INTERLOCK_DISABLED)
}

if (ap.motor_test) {
motor_test_output()
} else {
flightmode->output_to_motors()
}

SRV_Channels::push()
}
"
568,Arducopter\motors.cpp_lost_vehicle_check,"void Copter::lost_vehicle_check()
{
static uint8_t soundalarm_counter

if (rc().find_channel_for_option(RC_Channel::AUX_FUNC::LOST_VEHICLE_SOUND)) {
return
}

if (ap.throttle_zero && !motors->armed() && (channel_roll->get_control_in() > 4000) && (channel_pitch->get_control_in() > 4000)) {
if (soundalarm_counter >= LOST_VEHICLE_DELAY) {
if (AP_Notify::flags.vehicle_lost == false) {
AP_Notify::flags.vehicle_lost = true
gcs().send_text(MAV_SEVERITY_NOTICE,""Locate Copter alarm"")
}
} else {
soundalarm_counter++
}
} else {
soundalarm_counter = 0
if (AP_Notify::flags.vehicle_lost == true) {
AP_Notify::flags.vehicle_lost = false
}
}
}
"
569,Arducopter\motor_test.cpp_motor_test_output,"void Copter::motor_test_output()
{
if (!ap.motor_test) {
return
}

EXPECT_DELAY_MS(2000)

uint32_t now = AP_HAL::millis()
if ((now - motor_test_start_ms) >= motor_test_timeout_ms) {
if (motor_test_count > 1) {
if (now - motor_test_start_ms < motor_test_timeout_ms*1.5) {
motors->output_min()
} else {
motor_test_seq++
motor_test_count--
motor_test_start_ms = now
if (!motors->armed()) {
motors->armed(true)
hal.util->set_soft_armed(true)
}
}
return
}
motor_test_stop()
} else {
int16_t pwm = 0

switch (motor_test_throttle_type) {

case MOTOR_TEST_COMPASS_CAL:
compass.set_voltage(battery.voltage())
compass.per_motor_calibration_update()
FALLTHROUGH

case MOTOR_TEST_THROTTLE_PERCENT:
if (motor_test_throttle_value <= 100) {
int16_t pwm_min = motors->get_pwm_output_min()
int16_t pwm_max = motors->get_pwm_output_max()
pwm = (int16_t) (pwm_min + (pwm_max - pwm_min) * motor_test_throttle_value * 1e-2f)
}
break

case MOTOR_TEST_THROTTLE_PWM:
pwm = (int16_t)motor_test_throttle_value
break

case MOTOR_TEST_THROTTLE_PILOT:
pwm = channel_throttle->get_radio_in()
break

default:
motor_test_stop()
return
}

if (pwm >= RC_Channel::RC_MIN_LIMIT_PWM && pwm <= RC_Channel::RC_MAX_LIMIT_PWM) {
motors->output_test_seq(motor_test_seq, pwm)
} else {
motor_test_stop()
}
}
}
"
570,Arducopter\motor_test.cpp_mavlink_motor_control_check,"bool Copter::mavlink_motor_control_check(const GCS_MAVLINK &gcs_chan, bool check_rc, const char* mode)
{
if (!ap.initialised) {
gcs_chan.send_text(MAV_SEVERITY_CRITICAL,""%s: Board initialising"", mode)
return false
}

if (check_rc && !arming.rc_calibration_checks(true)) {
gcs_chan.send_text(MAV_SEVERITY_CRITICAL,""%s: RC not calibrated"", mode)
return false
}

if (!ap.land_complete) {
gcs_chan.send_text(MAV_SEVERITY_CRITICAL,""%s: vehicle not landed"", mode)
return false
}

if (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {
gcs_chan.send_text(MAV_SEVERITY_CRITICAL,""%s: Safety switch"", mode)
return false
}

if (SRV_Channels::get_emergency_stop()) {
gcs_chan.send_text(MAV_SEVERITY_CRITICAL,""%s: Motor Emergency Stopped"", mode)
return false
}

return true
}
"
571,Arducopter\motor_test.cpp_mavlink_motor_test_start,"MAV_RESULT Copter::mavlink_motor_test_start(const GCS_MAVLINK &gcs_chan, uint8_t motor_seq, uint8_t throttle_type, float throttle_value,
float timeout_sec, uint8_t motor_count)
{
if (motor_count == 0) {
motor_count = 1
}
if (!ap.motor_test) {
The RC calibrated check can be skipped if direct pwm is
supplied
if (!mavlink_motor_control_check(gcs_chan, throttle_type != 1, ""Motor Test"")) {
return MAV_RESULT_FAILED
} else {
gcs().send_text(MAV_SEVERITY_INFO, ""starting motor test"")
ap.motor_test = true

EXPECT_DELAY_MS(3000)
if (!motors->armed()) {
enable_motor_output()
motors->armed(true)
hal.util->set_soft_armed(true)
}

g.failsafe_throttle.set(FS_THR_DISABLED)
g.failsafe_gcs.set(FS_GCS_DISABLED)
g.fs_ekf_action.set(0)

AP_Notify::flags.esc_calibration = true
}
}

motor_test_start_ms = AP_HAL::millis()
motor_test_timeout_ms = MIN(timeout_sec, MOTOR_TEST_TIMEOUT_SEC) * 1000

motor_test_seq = motor_seq
motor_test_count = motor_count
motor_test_throttle_type = throttle_type
motor_test_throttle_value = throttle_value

if (motor_test_throttle_type == MOTOR_TEST_COMPASS_CAL) {
compass.per_motor_calibration_start()
}

return MAV_RESULT_ACCEPTED
}
"
572,Arducopter\motor_test.cpp_motor_test_stop,"void Copter::motor_test_stop()
{
if (!ap.motor_test) {
return
}

gcs().send_text(MAV_SEVERITY_INFO, ""finished motor test"")

ap.motor_test = false

motors->armed(false)
hal.util->set_soft_armed(false)

motor_test_start_ms = 0
motor_test_timeout_ms = 0

g.failsafe_throttle.load()
g.failsafe_gcs.load()
g.fs_ekf_action.load()

if (motor_test_throttle_type == MOTOR_TEST_COMPASS_CAL) {
compass.per_motor_calibration_end()
}

AP_Notify::flags.esc_calibration = false
}
"
573,Arducopter\navigation.cpp_run_nav_updates,"void Copter::run_nav_updates(void)
{
update_super_simple_bearing(false)
}
"
574,Arducopter\navigation.cpp_home_distance,"uint32_t Copter::home_distance()
{
if (position_ok()) {
_home_distance = current_loc.get_distance(ahrs.get_home()) * 100
}
return _home_distance
}
"
575,Arducopter\navigation.cpp_home_bearing,"int32_t Copter::home_bearing()
{
if (position_ok()) {
_home_bearing = current_loc.get_bearing_to(ahrs.get_home())
}
return _home_bearing
}
"
576,Arducopter\Parameters.cpp_ParametersG2,"ParametersG2::ParametersG2(void)
: temp_calibration() // this doesn't actually need constructing, but removing it here is problematic syntax-wise
, beacon()
, proximity()
,afs()
,smart_rtl()
,mode_flowhold_ptr(&copter.mode_flowhold)
,follow()
,user_parameters()
,autotune_ptr(&copter.mode_autotune.autotune)
,mode_systemid_ptr(&copter.mode_systemid)
,arot()
,button_ptr(&copter.button)
,mode_zigzag_ptr(&copter.mode_zigzag)

,command_model_acro_rp(ACRO_RP_RATE_DEFAULT, ACRO_RP_EXPO_DEFAULT, 0.0f)

,command_model_acro_y(ACRO_Y_RATE_DEFAULT, ACRO_Y_EXPO_DEFAULT, 0.0f)

,command_model_pilot(PILOT_Y_RATE_DEFAULT, PILOT_Y_EXPO_DEFAULT, 0.0f)
{
AP_Param::setup_object_defaults(this, var_info)
}
"
577,Arducopter\Parameters.cpp_load_parameters,"void Copter::load_parameters(void)
{
if (!AP_Param::check_var_info()) {
DEV_PRINTF(""Bad var table\n"")
AP_HAL::panic(""Bad var table"")
}

hal.util->set_soft_armed(false)

if (!g.format_version.load() ||
g.format_version != Parameters::k_format_version) {

DEV_PRINTF(""Firmware change: erasing EEPROM...\n"")
StorageManager::erase()
AP_Param::erase_all()

g.format_version.set_and_save(Parameters::k_format_version)
DEV_PRINTF(""done.\n"")
}
g.format_version.set_default(Parameters::k_format_version)

uint32_t before = micros()
AP_Param::load_all()
AP_Param::convert_old_parameters(&conversion_table[0], ARRAY_SIZE(conversion_table))

convert_lgr_parameters()

convert_fs_options_params()

g.rtl_altitude.convert_parameter_width(AP_PARAM_INT16)

AP_Param::convert_class(g.k_param_fence_old, &fence, fence.var_info, 0, 0, true)

hal.console->printf(""load_all took %uus\n"", (unsigned)(micros() - before))

AP_Param::set_frame_type_flags(AP_PARAM_FRAME_COPTER)

}
"
578,Arducopter\Parameters.cpp_convert_pid_parameters,"void Copter::convert_pid_parameters(void)
{
const AP_Param::ConversionInfo pid_conversion_info[] = {
{ Parameters::k_param_pid_rate_roll, 0, AP_PARAM_FLOAT, ""ATC_RAT_RLL_P"" },
{ Parameters::k_param_pid_rate_roll, 1, AP_PARAM_FLOAT, ""ATC_RAT_RLL_I"" },
{ Parameters::k_param_pid_rate_roll, 2, AP_PARAM_FLOAT, ""ATC_RAT_RLL_D"" },
{ Parameters::k_param_pid_rate_pitch, 0, AP_PARAM_FLOAT, ""ATC_RAT_PIT_P"" },
{ Parameters::k_param_pid_rate_pitch, 1, AP_PARAM_FLOAT, ""ATC_RAT_PIT_I"" },
{ Parameters::k_param_pid_rate_pitch, 2, AP_PARAM_FLOAT, ""ATC_RAT_PIT_D"" },
{ Parameters::k_param_pid_rate_yaw, 0, AP_PARAM_FLOAT, ""ATC_RAT_YAW_P"" },
{ Parameters::k_param_pid_rate_yaw, 1, AP_PARAM_FLOAT, ""ATC_RAT_YAW_I"" },
{ Parameters::k_param_pid_rate_yaw, 2, AP_PARAM_FLOAT, ""ATC_RAT_YAW_D"" },
{ Parameters::k_param_pid_rate_roll,  4, AP_PARAM_FLOAT, ""ATC_RAT_RLL_VFF"" },
{ Parameters::k_param_pid_rate_pitch, 4, AP_PARAM_FLOAT, ""ATC_RAT_PIT_VFF"" },
{ Parameters::k_param_pid_rate_yaw  , 4, AP_PARAM_FLOAT, ""ATC_RAT_YAW_VFF"" },
}
const AP_Param::ConversionInfo imax_conversion_info[] = {
{ Parameters::k_param_pid_rate_roll,  5, AP_PARAM_FLOAT, ""ATC_RAT_RLL_IMAX"" },
{ Parameters::k_param_pid_rate_pitch, 5, AP_PARAM_FLOAT, ""ATC_RAT_PIT_IMAX"" },
{ Parameters::k_param_pid_rate_yaw,   5, AP_PARAM_FLOAT, ""ATC_RAT_YAW_IMAX"" },
{ Parameters::k_param_pid_rate_roll,  7, AP_PARAM_FLOAT, ""ATC_RAT_RLL_ILMI"" },
{ Parameters::k_param_pid_rate_pitch, 7, AP_PARAM_FLOAT, ""ATC_RAT_PIT_ILMI"" },
{ Parameters::k_param_pid_rate_yaw,   7, AP_PARAM_FLOAT, ""ATC_RAT_YAW_ILMI"" },
}
const AP_Param::ConversionInfo angle_and_filt_conversion_info[] = {
{ Parameters::k_param_p_stabilize_roll, 0, AP_PARAM_FLOAT, ""ATC_ANG_RLL_P"" },
{ Parameters::k_param_p_stabilize_pitch, 0, AP_PARAM_FLOAT, ""ATC_ANG_PIT_P"" },
{ Parameters::k_param_p_stabilize_yaw, 0, AP_PARAM_FLOAT, ""ATC_ANG_YAW_P"" },
{ Parameters::k_param_pid_rate_roll, 6, AP_PARAM_FLOAT, ""ATC_RAT_RLL_FILT"" },
{ Parameters::k_param_pid_rate_pitch, 6, AP_PARAM_FLOAT, ""ATC_RAT_PIT_FILT"" },
{ Parameters::k_param_pid_rate_yaw, 6, AP_PARAM_FLOAT, ""ATC_RAT_YAW_FILT"" },
{ Parameters::k_param_pi_vel_xy, 0, AP_PARAM_FLOAT, ""PSC_VELXY_P"" },
{ Parameters::k_param_pi_vel_xy, 1, AP_PARAM_FLOAT, ""PSC_VELXY_I"" },
{ Parameters::k_param_pi_vel_xy, 2, AP_PARAM_FLOAT, ""PSC_VELXY_IMAX"" },
{ Parameters::k_param_pi_vel_xy, 3, AP_PARAM_FLOAT, ""PSC_VELXY_FLTE"" },
{ Parameters::k_param_p_vel_z, 0, AP_PARAM_FLOAT, ""PSC_VELZ_P"" },
{ Parameters::k_param_pid_accel_z, 0, AP_PARAM_FLOAT, ""PSC_ACCZ_P"" },
{ Parameters::k_param_pid_accel_z, 1, AP_PARAM_FLOAT, ""PSC_ACCZ_I"" },
{ Parameters::k_param_pid_accel_z, 2, AP_PARAM_FLOAT, ""PSC_ACCZ_D"" },
{ Parameters::k_param_pid_accel_z, 5, AP_PARAM_FLOAT, ""PSC_ACCZ_IMAX"" },
{ Parameters::k_param_pid_accel_z, 6, AP_PARAM_FLOAT, ""PSC_ACCZ_FLTE"" },
{ Parameters::k_param_p_alt_hold, 0, AP_PARAM_FLOAT, ""PSC_POSZ_P"" },
{ Parameters::k_param_p_pos_xy, 0, AP_PARAM_FLOAT, ""PSC_POSXY_P"" },
}
const AP_Param::ConversionInfo throttle_conversion_info[] = {
{ Parameters::k_param_throttle_min, 0, AP_PARAM_FLOAT, ""MOT_SPIN_MIN"" },
{ Parameters::k_param_throttle_mid, 0, AP_PARAM_FLOAT, ""MOT_THST_HOVER"" }
}
const AP_Param::ConversionInfo loiter_conversion_info[] = {
{ Parameters::k_param_wp_nav, 4, AP_PARAM_FLOAT, ""LOIT_SPEED"" },
{ Parameters::k_param_wp_nav, 7, AP_PARAM_FLOAT, ""LOIT_BRK_JERK"" },
{ Parameters::k_param_wp_nav, 8, AP_PARAM_FLOAT, ""LOIT_ACC_MAX"" },
{ Parameters::k_param_wp_nav, 9, AP_PARAM_FLOAT, ""LOIT_BRK_ACCEL"" }
}

float pid_scaler = 1.27f

if (g.frame_type == AP_Motors::MOTOR_FRAME_TYPE_X || g.frame_type == AP_Motors::MOTOR_FRAME_TYPE_V || g.frame_type == AP_Motors::MOTOR_FRAME_TYPE_H) {
pid_scaler = 0.9f
}

for (const auto &info : pid_conversion_info) {
AP_Param::convert_old_parameter(&info, pid_scaler)
}
for (const auto &info : imax_conversion_info) {
AP_Param::convert_old_parameter(&info, 1.0f/4500.0f)
}
for (const auto &info : angle_and_filt_conversion_info) {
AP_Param::convert_old_parameter(&info, 1.0f)
}
for (const auto &info : throttle_conversion_info) {
AP_Param::convert_old_parameter(&info, 0.001f)
}
const AP_Param::ConversionInfo rc_feel_rp_conversion_info = { Parameters::k_param_rc_feel_rp, 0, AP_PARAM_INT8, ""ATC_INPUT_TC"" }
AP_Int8 rc_feel_rp_old
if (AP_Param::find_old_parameter(&rc_feel_rp_conversion_info, &rc_feel_rp_old)) {
AP_Param::set_default_by_name(rc_feel_rp_conversion_info.new_name, (1.0f / (2.0f + rc_feel_rp_old.get() * 0.1f)))
}
for (const auto &info : loiter_conversion_info) {
AP_Param::convert_old_parameter(&info, 1.0f)
}

static const struct AP_Param::defaults_table_struct heli_defaults_table[] = {
{ ""LOIT_ACC_MAX"", 500.0f },
{ ""LOIT_BRK_ACCEL"", 125.0f },
{ ""LOIT_BRK_DELAY"", 1.0f },
{ ""LOIT_BRK_JERK"", 250.0f },
{ ""LOIT_SPEED"", 3000.0f },
{ ""PHLD_BRAKE_ANGLE"", 800.0f },
{ ""PHLD_BRAKE_RATE"", 4.0f },
{ ""PSC_ACCZ_P"", 0.28f },
{ ""PSC_VELXY_D"", 0.0f },
{ ""PSC_VELXY_I"", 0.5f },
{ ""PSC_VELXY_P"", 1.0f },
{ ""RC8_OPTION"", 32 },
{ ""RC_OPTIONS"", 0 },
{ ""ATC_RAT_RLL_ILMI"", 0.05},
{ ""ATC_RAT_PIT_ILMI"", 0.05},
}
AP_Param::set_defaults_from_table(heli_defaults_table, ARRAY_SIZE(heli_defaults_table))

const AP_Param::ConversionInfo ff_and_filt_conversion_info[] = {
{ Parameters::k_param_attitude_control, 386, AP_PARAM_FLOAT, ""ATC_RAT_RLL_FLTE"" },
{ Parameters::k_param_attitude_control, 387, AP_PARAM_FLOAT, ""ATC_RAT_PIT_FLTE"" },
{ Parameters::k_param_attitude_control, 388, AP_PARAM_FLOAT, ""ATC_RAT_YAW_FLTE"" },
{ Parameters::k_param_attitude_control, 385, AP_PARAM_FLOAT, ""ATC_RAT_RLL_FLTD"" },
{ Parameters::k_param_attitude_control, 385, AP_PARAM_FLOAT, ""ATC_RAT_RLL_FLTT"" },
{ Parameters::k_param_attitude_control, 386, AP_PARAM_FLOAT, ""ATC_RAT_PIT_FLTD"" },
{ Parameters::k_param_attitude_control, 386, AP_PARAM_FLOAT, ""ATC_RAT_PIT_FLTT"" },
{ Parameters::k_param_attitude_control, 387, AP_PARAM_FLOAT, ""ATC_RAT_YAW_FLTE"" },
{ Parameters::k_param_attitude_control, 449, AP_PARAM_FLOAT, ""ATC_RAT_RLL_FF"" },
{ Parameters::k_param_attitude_control, 450, AP_PARAM_FLOAT, ""ATC_RAT_PIT_FF"" },
{ Parameters::k_param_attitude_control, 451, AP_PARAM_FLOAT, ""ATC_RAT_YAW_FF"" },
{ Parameters::k_param_pos_control, 388, AP_PARAM_FLOAT, ""PSC_ACCZ_FLTE"" },
}
uint8_t filt_table_size = ARRAY_SIZE(ff_and_filt_conversion_info)
for (uint8_t i=0
AP_Param::convert_old_parameters(&ff_and_filt_conversion_info[i], 1.0f)
}

if (!ins.harmonic_notches[1].params.enabled()) {
const AP_Param::ConversionInfo notchfilt_conversion_info[] {
{ Parameters::k_param_ins, 101, AP_PARAM_INT8,  ""INS_HNTC2_ENABLE"" },
{ Parameters::k_param_ins, 293, AP_PARAM_FLOAT, ""INS_HNTC2_ATT"" },
{ Parameters::k_param_ins, 357, AP_PARAM_FLOAT, ""INS_HNTC2_FREQ"" },
{ Parameters::k_param_ins, 421, AP_PARAM_FLOAT, ""INS_HNTC2_BW"" },
}
uint8_t notchfilt_table_size = ARRAY_SIZE(notchfilt_conversion_info)
for (uint8_t i=0
AP_Param::convert_old_parameters(&notchfilt_conversion_info[i], 1.0f)
}
AP_Param::set_default_by_name(""INS_HNTC2_MODE"", 0)
AP_Param::set_default_by_name(""INS_HNTC2_HMNCS"", 1)
}

const AP_Param::ConversionInfo acro_rpy_conversion_info[] = {
{ Parameters::k_param_acro_rp_p, 0, AP_PARAM_FLOAT, ""ACRO_RP_RATE"" },
{ Parameters::k_param_acro_yaw_p,  0, AP_PARAM_FLOAT, ""ACRO_Y_RATE"" }
}
for (const auto &info : acro_rpy_conversion_info) {
AP_Param::convert_old_parameter(&info, 45.0)
}

const AP_Param::ConversionInfo cmd_mdl_conversion_info[] = {
{ Parameters::k_param_g2, 47, AP_PARAM_FLOAT, ""ACRO_RP_RATE"" },
{ Parameters::k_param_acro_rp_expo,  0, AP_PARAM_FLOAT, ""ACRO_RP_EXPO"" },
{ Parameters::k_param_g2,  48, AP_PARAM_FLOAT, ""ACRO_Y_RATE"" },
{ Parameters::k_param_g2,  9, AP_PARAM_FLOAT, ""ACRO_Y_EXPO"" },
{ Parameters::k_param_g2,  49, AP_PARAM_FLOAT, ""PILOT_Y_RATE"" },
{ Parameters::k_param_g2,  50, AP_PARAM_FLOAT, ""PILOT_Y_EXPO"" },
}
for (const auto &info : cmd_mdl_conversion_info) {
AP_Param::convert_old_parameter(&info, 1.0)
}

SRV_Channels::upgrade_parameters()
}
"
579,Arducopter\Parameters.cpp_convert_prx_parameters,"void Copter::convert_prx_parameters()
{
const AP_Param::ConversionInfo prx_conversion_info[] = {
{ Parameters::k_param_g2, 72, AP_PARAM_INT8, ""PRX1_TYPE"" },
{ Parameters::k_param_g2, 136, AP_PARAM_INT8, ""PRX1_ORIENT"" },
{ Parameters::k_param_g2, 200, AP_PARAM_INT16, ""PRX1_YAW_CORR"" },
{ Parameters::k_param_g2, 264, AP_PARAM_INT16, ""PRX1_IGN_ANG1"" },
{ Parameters::k_param_g2, 328, AP_PARAM_INT8, ""PRX1_IGN_WID1"" },
{ Parameters::k_param_g2, 392, AP_PARAM_INT16, ""PRX1_IGN_ANG2"" },
{ Parameters::k_param_g2, 456, AP_PARAM_INT8, ""PRX1_IGN_WID2"" },
{ Parameters::k_param_g2, 520, AP_PARAM_INT16, ""PRX1_IGN_ANG3"" },
{ Parameters::k_param_g2, 584, AP_PARAM_INT8, ""PRX1_IGN_WID3"" },
{ Parameters::k_param_g2, 648, AP_PARAM_INT16, ""PRX1_IGN_ANG4"" },
{ Parameters::k_param_g2, 712, AP_PARAM_INT8, ""PRX1_IGN_WID4"" },
{ Parameters::k_param_g2, 1224, AP_PARAM_FLOAT, ""PRX1_MIN"" },
{ Parameters::k_param_g2, 1288, AP_PARAM_FLOAT, ""PRX1_MAX"" },
}
for (const auto &info : prx_conversion_info) {
AP_Param::convert_old_parameter(&info, 1.0)
}
}
"
580,Arducopter\Parameters.cpp_convert_lgr_parameters,"void Copter::convert_lgr_parameters(void)
{

uint8_t chan
if (!SRV_Channels::find_channel(SRV_Channel::k_landing_gear_control, chan)) {
return
}
chan += 1

char pname[17]
AP_Int16 *servo_min, *servo_max, *servo_trim
AP_Int16 *servo_reversed

enum ap_var_type ptype
snprintf(pname, sizeof(pname), ""SERVO%u_MIN"", chan)
servo_min = (AP_Int16 *)AP_Param::find(pname, &ptype)

snprintf(pname, sizeof(pname), ""SERVO%u_MAX"", chan)
servo_max = (AP_Int16 *)AP_Param::find(pname, &ptype)

snprintf(pname, sizeof(pname), ""SERVO%u_TRIM"", chan)
servo_trim = (AP_Int16 *)AP_Param::find(pname, &ptype)

snprintf(pname, sizeof(pname), ""SERVO%u_REVERSED"", chan & 0x3F)
servo_reversed = (AP_Int16 *)AP_Param::find(pname, &ptype)

if (!servo_min || !servo_max || !servo_trim || !servo_reversed) {
return
}
if (servo_min->configured() ||
servo_max->configured() ||
servo_trim->configured() ||
servo_reversed->configured()) {
return
}

AP_Int16 old_pwm
uint16_t old_retract=0, old_deploy=0
const AP_Param::ConversionInfo cinfo_ret { Parameters::k_param_landinggear, 0, AP_PARAM_INT16, nullptr }
const AP_Param::ConversionInfo cinfo_dep { Parameters::k_param_landinggear, 1, AP_PARAM_INT16, nullptr }
if (AP_Param::find_old_parameter(&cinfo_ret, &old_pwm)) {
old_retract = (uint16_t)old_pwm.get()
}
if (AP_Param::find_old_parameter(&cinfo_dep, &old_pwm)) {
old_deploy = (uint16_t)old_pwm.get()
}

if (old_retract == 0 && old_deploy == 0) {
return
}

if (old_retract == 0) {
old_retract = 1250
}
if (old_deploy == 0) {
old_deploy = 1750
}

if (old_retract <= old_deploy) {
servo_max->set_and_save(old_deploy)
servo_min->set_and_save(old_retract)
servo_trim->set_and_save(old_retract)
servo_reversed->set_and_save_ifchanged(0)
} else {
servo_max->set_and_save(old_retract)
servo_min->set_and_save(old_deploy)
servo_trim->set_and_save(old_deploy)
servo_reversed->set_and_save_ifchanged(1)
}
}
"
581,Arducopter\Parameters.cpp_convert_tradheli_parameters,"void Copter::convert_tradheli_parameters(void) const
{
if (g2.frame_class.get() == AP_Motors::MOTOR_FRAME_HELI) {
const AP_Param::ConversionInfo singleheli_conversion_info[] = {
{ Parameters::k_param_motors, 1, AP_PARAM_INT16, ""H_SW_H3_SV1_POS"" },
{ Parameters::k_param_motors, 2, AP_PARAM_INT16, ""H_SW_H3_SV2_POS"" },
{ Parameters::k_param_motors, 3, AP_PARAM_INT16, ""H_SW_H3_SV3_POS"" },
{ Parameters::k_param_motors, 7, AP_PARAM_INT16, ""H_SW_H3_PHANG"" },
{ Parameters::k_param_motors, 19, AP_PARAM_INT8, ""H_SW_COL_DIR"" },
}

uint8_t table_size = ARRAY_SIZE(singleheli_conversion_info)
for (uint8_t i=0
AP_Param::convert_old_parameter(&singleheli_conversion_info[i], 1.0f)
}

AP_Int16 swash_pos_1, swash_pos_2, swash_pos_3, swash_phang
AP_Int8  swash_type
bool swash_pos1_exist = AP_Param::find_old_parameter(&singleheli_conversion_info[0], &swash_pos_1)
bool swash_pos2_exist = AP_Param::find_old_parameter(&singleheli_conversion_info[1], &swash_pos_2)
bool swash_pos3_exist = AP_Param::find_old_parameter(&singleheli_conversion_info[2], &swash_pos_3)
bool swash_phang_exist = AP_Param::find_old_parameter(&singleheli_conversion_info[3], &swash_phang)
const AP_Param::ConversionInfo swash_type_info { Parameters::k_param_motors, 5, AP_PARAM_INT8, ""H_SW_TYPE"" }
bool swash_type_exists = AP_Param::find_old_parameter(&swash_type_info, &swash_type)

if (swash_type_exists) {
AP_Param::convert_old_parameter(&swash_type_info, 1.0f)
} else {
if (swash_pos1_exist || swash_pos2_exist || swash_pos3_exist || swash_phang_exist) {
enum ap_var_type ptype
AP_Param *ap2
ap2 = AP_Param::find(""H_SW_TYPE"", &ptype)
if (ap2 != nullptr) {
if (!ap2->configured()) {
AP_Param::set_and_save_by_name(""H_SW_TYPE"", SwashPlateType::SWASHPLATE_TYPE_H3)
}
}
}
}
} else if (g2.frame_class.get() == AP_Motors::MOTOR_FRAME_HELI_DUAL) {
const AP_Param::ConversionInfo dualheli_conversion_info[] = {
{ Parameters::k_param_motors, 1, AP_PARAM_INT16, ""H_SW_H3_SV1_POS"" },
{ Parameters::k_param_motors, 2, AP_PARAM_INT16, ""H_SW_H3_SV2_POS"" },
{ Parameters::k_param_motors, 3, AP_PARAM_INT16, ""H_SW_H3_SV3_POS"" },
{ Parameters::k_param_motors, 4, AP_PARAM_INT16, ""H_SW2_H3_SV1_POS"" },
{ Parameters::k_param_motors, 5, AP_PARAM_INT16, ""H_SW2_H3_SV2_POS"" },
{ Parameters::k_param_motors, 6, AP_PARAM_INT16, ""H_SW2_H3_SV3_POS"" },
{ Parameters::k_param_motors, 7, AP_PARAM_INT16, ""H_SW_H3_PHANG"" },
{ Parameters::k_param_motors, 8, AP_PARAM_INT16, ""H_SW2_H3_PHANG"" },
{ Parameters::k_param_motors, 19, AP_PARAM_INT8, ""H_SW_COL_DIR"" },
{ Parameters::k_param_motors, 19, AP_PARAM_INT8, ""H_SW2_COL_DIR"" },
}

uint8_t table_size = ARRAY_SIZE(dualheli_conversion_info)
for (uint8_t i=0
AP_Param::convert_old_parameter(&dualheli_conversion_info[i], 1.0f)
}



AP_Int16 swash1_pos_1, swash1_pos_2, swash1_pos_3, swash1_phang, swash2_pos_1, swash2_pos_2, swash2_pos_3, swash2_phang
bool swash1_pos1_exist = AP_Param::find_old_parameter(&dualheli_conversion_info[0], &swash1_pos_1)
bool swash1_pos2_exist = AP_Param::find_old_parameter(&dualheli_conversion_info[1], &swash1_pos_2)
bool swash1_pos3_exist = AP_Param::find_old_parameter(&dualheli_conversion_info[2], &swash1_pos_3)
bool swash1_phang_exist = AP_Param::find_old_parameter(&dualheli_conversion_info[6], &swash1_phang)
bool swash2_pos1_exist = AP_Param::find_old_parameter(&dualheli_conversion_info[3], &swash2_pos_1)
bool swash2_pos2_exist = AP_Param::find_old_parameter(&dualheli_conversion_info[4], &swash2_pos_2)
bool swash2_pos3_exist = AP_Param::find_old_parameter(&dualheli_conversion_info[5], &swash2_pos_3)
bool swash2_phang_exist = AP_Param::find_old_parameter(&dualheli_conversion_info[7], &swash2_phang)

if (swash1_pos1_exist || swash1_pos2_exist || swash1_pos3_exist || swash1_phang_exist) {
enum ap_var_type ptype
AP_Param *ap2
ap2 = AP_Param::find(""H_SW_TYPE"", &ptype)
if (ap2 != nullptr) {
if (!ap2->configured()) {
AP_Param::set_and_save_by_name(""H_SW_TYPE"", SwashPlateType::SWASHPLATE_TYPE_H3)
}
}
}
if (swash2_pos1_exist || swash2_pos2_exist || swash2_pos3_exist || swash2_phang_exist) {
enum ap_var_type ptype
AP_Param *ap2
ap2 = AP_Param::find(""H_SW2_TYPE"", &ptype)
if (ap2 != nullptr) {
if (!ap2->configured()) {
AP_Param::set_and_save_by_name(""H_SW2_TYPE"", SwashPlateType::SWASHPLATE_TYPE_H3)
}
}
}
}

const AP_Param::ConversionInfo rschelipct_conversion_info[] = {
{ Parameters::k_param_motors, 1280, AP_PARAM_INT16, ""H_RSC_THRCRV_0"" },
{ Parameters::k_param_motors, 1344, AP_PARAM_INT16, ""H_RSC_THRCRV_25"" },
{ Parameters::k_param_motors, 1408, AP_PARAM_INT16, ""H_RSC_THRCRV_50"" },
{ Parameters::k_param_motors, 1472, AP_PARAM_INT16, ""H_RSC_THRCRV_75"" },
{ Parameters::k_param_motors, 1536, AP_PARAM_INT16, ""H_RSC_THRCRV_100"" },
{ Parameters::k_param_motors, 448, AP_PARAM_INT16, ""H_RSC_SETPOINT"" },
{ Parameters::k_param_motors, 768, AP_PARAM_INT16, ""H_RSC_CRITICAL"" },
{ Parameters::k_param_motors, 832, AP_PARAM_INT16, ""H_RSC_IDLE"" },
}
uint8_t table_size = ARRAY_SIZE(rschelipct_conversion_info)
for (uint8_t i=0
AP_Param::convert_old_parameter(&rschelipct_conversion_info[i], 0.1f)
}

const AP_Param::ConversionInfo rscheli_conversion_info[] = {
{ Parameters::k_param_motors, 512, AP_PARAM_INT8,  ""H_RSC_MODE"" },
{ Parameters::k_param_motors, 640, AP_PARAM_INT8,  ""H_RSC_RAMP_TIME"" },
{ Parameters::k_param_motors, 704, AP_PARAM_INT8,  ""H_RSC_RUNUP_TIME"" },
{ Parameters::k_param_motors, 1216, AP_PARAM_INT16,""H_RSC_SLEWRATE"" },
}
table_size = ARRAY_SIZE(rscheli_conversion_info)
for (uint8_t i=0
AP_Param::convert_old_parameter(&rscheli_conversion_info[i], 1.0f)
}

AP_Int16 *tailspeed
enum ap_var_type ptype
tailspeed = (AP_Int16 *)AP_Param::find(""H_TAIL_SPEED"", &ptype)
if (tailspeed != nullptr && tailspeed->get() > 100 ) {
uint16_t tailspeed_pct = (uint16_t)(0.1f * tailspeed->get())
AP_Param::set_and_save_by_name(""H_TAIL_SPEED"", tailspeed_pct )
}

const AP_Param::ConversionInfo collhelipct_conversion_info[] = {
{ Parameters::k_param_input_manager, 1, AP_PARAM_INT16,  ""IM_STB_COL_1"" },
{ Parameters::k_param_input_manager, 2, AP_PARAM_INT16,  ""IM_STB_COL_2"" },
{ Parameters::k_param_input_manager, 3, AP_PARAM_INT16,  ""IM_STB_COL_3"" },
{ Parameters::k_param_input_manager, 4, AP_PARAM_INT16,  ""IM_STB_COL_4"" },
}

table_size = ARRAY_SIZE(collhelipct_conversion_info)
for (uint8_t i=0
AP_Param::convert_old_parameter(&collhelipct_conversion_info[i], 0.1f)
}

}
"
582,Arducopter\Parameters.cpp_convert_fs_options_params,"void Copter::convert_fs_options_params(void) const
{

enum ap_var_type ptype
AP_Int32 *fs_opt = (AP_Int32 *)AP_Param::find(""FS_OPTIONS"", &ptype)

if (fs_opt == nullptr || fs_opt->configured() || ptype != AP_PARAM_INT32) {
return
}

int32_t fs_options_converted = (int32_t)FailsafeOption::GCS_CONTINUE_IF_PILOT_CONTROL

if (g.failsafe_throttle == FS_THR_ENABLED_CONTINUE_MISSION) {
fs_options_converted |= int32_t(FailsafeOption::RC_CONTINUE_IF_AUTO)
AP_Param::set_and_save_by_name(""FS_THR_ENABLE"", FS_THR_ENABLED_ALWAYS_RTL)
}

if (g.failsafe_gcs == FS_GCS_ENABLED_CONTINUE_MISSION) {
fs_options_converted |= int32_t(FailsafeOption::GCS_CONTINUE_IF_AUTO)
AP_Param::set_and_save_by_name(""FS_GCS_ENABLE"", FS_GCS_ENABLED_ALWAYS_RTL)
}

fs_opt->set_and_save(fs_options_converted)
}
"
583,Arducopter\precision_landing.cpp_init_precland,"void Copter::init_precland()
{
copter.precland.init(400)
}
"
584,Arducopter\precision_landing.cpp_update_precland,"void Copter::update_precland()
{
return precland.update(rangefinder_state.alt_cm_glitch_protected,
rangefinder_alt_ok())
}
"
585,Arducopter\radio.cpp_default_dead_zones,"void Copter::default_dead_zones()
{
channel_roll->set_default_dead_zone(20)
channel_pitch->set_default_dead_zone(20)
channel_throttle->set_default_dead_zone(10)
channel_yaw->set_default_dead_zone(15)
channel_throttle->set_default_dead_zone(30)
channel_yaw->set_default_dead_zone(20)
rc().channel(CH_6)->set_default_dead_zone(0)
}
"
586,Arducopter\radio.cpp_init_rc_in,"void Copter::init_rc_in()
{
channel_roll     = rc().channel(rcmap.roll()-1)
channel_pitch    = rc().channel(rcmap.pitch()-1)
channel_throttle = rc().channel(rcmap.throttle()-1)
channel_yaw      = rc().channel(rcmap.yaw()-1)

channel_roll->set_angle(ROLL_PITCH_YAW_INPUT_MAX)
channel_pitch->set_angle(ROLL_PITCH_YAW_INPUT_MAX)
channel_yaw->set_angle(ROLL_PITCH_YAW_INPUT_MAX)
channel_throttle->set_range(1000)

default_dead_zones()

ap.throttle_zero = true
}
"
587,Arducopter\radio.cpp_init_rc_out,"void Copter::init_rc_out()
{
motors->set_loop_rate(scheduler.get_loop_rate_hz())
motors->init((AP_Motors::motor_frame_class)g2.frame_class.get(), (AP_Motors::motor_frame_type)g.frame_type.get())

SRV_Channels::enable_aux_servos()

motors->set_update_rate(g.rc_speed)

if (channel_throttle->configured()) {
motors->convert_pwm_min_max_param(channel_throttle->get_radio_min(), channel_throttle->get_radio_max())
} else {
motors->convert_pwm_min_max_param(1000, 2000)
}
motors->update_throttle_range()
hal.rcout->set_esc_scaling(channel_throttle->get_radio_min(), channel_throttle->get_radio_max())

SRV_Channels::update_aux_servo_function()

setup a default safety ignore mask, so that servo gimbals can be active while safety is on
uint16_t safety_ignore_mask = (~copter.motors->get_motor_mask()) & 0x3FFF
BoardConfig.set_default_safety_ignore_mask(safety_ignore_mask)
}
"
588,Arducopter\radio.cpp_enable_motor_output,"void Copter::enable_motor_output()
{
motors->output_min()
}
"
589,Arducopter\radio.cpp_read_radio,"void Copter::read_radio()
{
const uint32_t tnow_ms = millis()

if (rc().read_input()) {
ap.new_radio_frame = true

set_throttle_and_failsafe(channel_throttle->get_radio_in())
set_throttle_zero_flag(channel_throttle->get_control_in())

ap.rc_receiver_present = true

radio_passthrough_to_motors()

const float dt = (tnow_ms - last_radio_update_ms)*1.0e-3f
rc_throttle_control_in_filter.apply(channel_throttle->get_control_in(), dt)
last_radio_update_ms = tnow_ms
return
}

if (failsafe.radio) {
return
}

const uint32_t elapsed = tnow_ms - last_radio_update_ms
const uint32_t timeout = RC_Channels::has_active_overrides() ? FS_RADIO_RC_OVERRIDE_TIMEOUT_MS : FS_RADIO_TIMEOUT_MS
if (elapsed < timeout) {
return
}
if (!g.failsafe_throttle) {
return
}
if (!ap.rc_receiver_present && !motors->armed()) {
return
}

AP::logger().Write_Error(LogErrorSubsystem::RADIO, LogErrorCode::RADIO_LATE_FRAME)
set_failsafe_radio(true)
}
"
590,Arducopter\radio.cpp_set_throttle_and_failsafe,"void Copter::set_throttle_and_failsafe(uint16_t throttle_pwm)
{
if(g.failsafe_throttle == FS_THR_DISABLED) {
return
}

if (throttle_pwm < (uint16_t)g.failsafe_throttle_value) {

if (failsafe.radio || !(ap.rc_receiver_present || motors->armed())) {
return
}

failsafe.radio_counter++
if( failsafe.radio_counter >= FS_COUNTER ) {
failsafe.radio_counter = FS_COUNTER
set_failsafe_radio(true)
}
}else{
failsafe.radio_counter--
if( failsafe.radio_counter <= 0 ) {
failsafe.radio_counter = 0

if (failsafe.radio) {
set_failsafe_radio(false)
}
}
}
}
"
591,Arducopter\radio.cpp_set_throttle_zero_flag,"void Copter::set_throttle_zero_flag(int16_t throttle_control)
{
static uint32_t last_nonzero_throttle_ms = 0
uint32_t tnow_ms = millis()

if ((!ap.using_interlock && (throttle_control > 0) && !SRV_Channels::get_emergency_stop()) ||
(ap.using_interlock && motors->get_interlock()) ||
ap.armed_with_airmode_switch || air_mode == AirMode::AIRMODE_ENABLED) {
last_nonzero_throttle_ms = tnow_ms
ap.throttle_zero = false
} else if (tnow_ms - last_nonzero_throttle_ms > THROTTLE_ZERO_DEBOUNCE_TIME_MS) {
ap.throttle_zero = true
}
}
"
592,Arducopter\radio.cpp_radio_passthrough_to_motors,"void Copter::radio_passthrough_to_motors()
{
motors->set_radio_passthrough(channel_roll->norm_input(),
channel_pitch->norm_input(),
channel_throttle->get_control_in_zero_dz()*0.001f,
channel_yaw->norm_input())
}
"
593,Arducopter\radio.cpp_get_throttle_mid,"int16_t Copter::get_throttle_mid(void)
{
if (g2.toy_mode.enabled()) {
return g2.toy_mode.get_throttle_mid()
}
return channel_throttle->get_control_mid()
}
"
594,Arducopter\RC_Channel.cpp_flight_mode_channel_number,"int8_t RC_Channels_Copter::flight_mode_channel_number() const
{
return copter.g.flight_mode_chan.get()
}
"
595,Arducopter\RC_Channel.cpp_mode_switch_changed,"void RC_Channel_Copter::mode_switch_changed(modeswitch_pos_t new_pos)
{
if (new_pos < 0 || (uint8_t)new_pos > copter.num_flight_modes) {
return
}

if (!copter.set_mode((Mode::Number)copter.flight_modes[new_pos].get(), ModeReason::RC_COMMAND)) {
return
}

if (!rc().find_channel_for_option(AUX_FUNC::SIMPLE_MODE) &&
!rc().find_channel_for_option(AUX_FUNC::SUPERSIMPLE_MODE)) {
if (BIT_IS_SET(copter.g.super_simple, new_pos)) {
copter.set_simple_mode(Copter::SimpleMode::SUPERSIMPLE)
} else {
copter.set_simple_mode(BIT_IS_SET(copter.g.simple_modes, new_pos) ? Copter::SimpleMode::SIMPLE : Copter::SimpleMode::NONE)
}
}
}
"
596,Arducopter\RC_Channel.cpp_has_valid_input,"bool RC_Channels_Copter::has_valid_input() const
{
if (copter.failsafe.radio) {
return false
}
if (copter.failsafe.radio_counter != 0) {
return false
}
return true
}
"
597,Arducopter\RC_Channel.cpp_arming_check_throttle,"bool RC_Channels_Copter::arming_check_throttle() const {
if ((copter.g.throttle_behavior & THR_BEHAVE_FEEDBACK_FROM_MID_STICK) != 0) {
return false
}
return RC_Channels::arming_check_throttle()
}
"
598,Arducopter\RC_Channel.cpp_get_arming_channel,"RC_Channel * RC_Channels_Copter::get_arming_channel(void) const
{
return copter.channel_yaw
}
"
599,Arducopter\RC_Channel.cpp_init_aux_function,"void RC_Channel_Copter::init_aux_function(const aux_func_t ch_option, const AuxSwitchPos ch_flag)
{
switch(ch_option) {
case AUX_FUNC::ALTHOLD:
case AUX_FUNC::AUTO:
case AUX_FUNC::AUTOTUNE:
case AUX_FUNC::BRAKE:
case AUX_FUNC::CIRCLE:
case AUX_FUNC::DRIFT:
case AUX_FUNC::FLIP:
case AUX_FUNC::FLOWHOLD:
case AUX_FUNC::FOLLOW:
case AUX_FUNC::GUIDED:
case AUX_FUNC::LAND:
case AUX_FUNC::LOITER:
case AUX_FUNC::PARACHUTE_RELEASE:
case AUX_FUNC::POSHOLD:
case AUX_FUNC::RESETTOARMEDYAW:
case AUX_FUNC::RTL:
case AUX_FUNC::SAVE_TRIM:
case AUX_FUNC::SAVE_WP:
case AUX_FUNC::SMART_RTL:
case AUX_FUNC::STABILIZE:
case AUX_FUNC::THROW:
case AUX_FUNC::USER_FUNC1:
case AUX_FUNC::USER_FUNC2:
case AUX_FUNC::USER_FUNC3:
case AUX_FUNC::WINCH_CONTROL:
case AUX_FUNC::ZIGZAG:
case AUX_FUNC::ZIGZAG_Auto:
case AUX_FUNC::ZIGZAG_SaveWP:
case AUX_FUNC::ACRO:
case AUX_FUNC::AUTO_RTL:
case AUX_FUNC::TURTLE:
case AUX_FUNC::SIMPLE_HEADING_RESET:
case AUX_FUNC::ARMDISARM_AIRMODE:
case AUX_FUNC::TURBINE_START:
break
case AUX_FUNC::ACRO_TRAINER:
case AUX_FUNC::ATTCON_ACCEL_LIM:
case AUX_FUNC::ATTCON_FEEDFWD:
case AUX_FUNC::INVERTED:
case AUX_FUNC::MOTOR_INTERLOCK:
case AUX_FUNC::PARACHUTE_3POS:      // we trust the vehicle will be disarmed so even if switch is in release position the chute will not release
case AUX_FUNC::PARACHUTE_ENABLE:
case AUX_FUNC::PRECISION_LOITER:
case AUX_FUNC::RANGEFINDER:
case AUX_FUNC::SIMPLE_MODE:
case AUX_FUNC::STANDBY:
case AUX_FUNC::SUPERSIMPLE_MODE:
case AUX_FUNC::SURFACE_TRACKING:
case AUX_FUNC::WINCH_ENABLE:
case AUX_FUNC::AIRMODE:
case AUX_FUNC::FORCEFLYING:
case AUX_FUNC::CUSTOM_CONTROLLER:
run_aux_function(ch_option, ch_flag, AuxFuncTriggerSource::INIT)
break
default:
RC_Channel::init_aux_function(ch_option, ch_flag)
break
}
}
"
600,Arducopter\RC_Channel.cpp_do_aux_function_change_mode,"void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,
const AuxSwitchPos ch_flag)
{
switch(ch_flag) {
case AuxSwitchPos::HIGH: {
copter.set_mode(mode, ModeReason::RC_COMMAND)
break
}
default:
if (copter.flightmode->mode_number() == mode) {
rc().reset_mode_switch()
}
}
}
"
601,Arducopter\RC_Channel.cpp_do_aux_function,"bool RC_Channel_Copter::do_aux_function(const aux_func_t ch_option, const AuxSwitchPos ch_flag)
{
switch(ch_option) {
case AUX_FUNC::FLIP:
if (ch_flag == AuxSwitchPos::HIGH) {
copter.set_mode(Mode::Number::FLIP, ModeReason::RC_COMMAND)
}
break

case AUX_FUNC::SIMPLE_MODE:
copter.set_simple_mode((ch_flag == AuxSwitchPos::LOW) ? Copter::SimpleMode::NONE : Copter::SimpleMode::SIMPLE)
break

case AUX_FUNC::SUPERSIMPLE_MODE: {
Copter::SimpleMode newmode = Copter::SimpleMode::NONE
switch (ch_flag) {
case AuxSwitchPos::LOW:
break
case AuxSwitchPos::MIDDLE:
newmode = Copter::SimpleMode::SIMPLE
break
case AuxSwitchPos::HIGH:
newmode = Copter::SimpleMode::SUPERSIMPLE
break
}
copter.set_simple_mode(newmode)
break
}

case AUX_FUNC::RTL:
do_aux_function_change_mode(Mode::Number::RTL, ch_flag)
break

case AUX_FUNC::SAVE_TRIM:
if ((ch_flag == AuxSwitchPos::HIGH) &&
(copter.flightmode->allows_save_trim()) &&
(copter.channel_throttle->get_control_in() == 0)) {
copter.save_trim()
}
break

case AUX_FUNC::SAVE_WP:
if (ch_flag == RC_Channel::AuxSwitchPos::HIGH) {

if (copter.flightmode == &copter.mode_auto || !copter.motors->armed()) {
break
}

if ((copter.mode_auto.mission.num_commands() == 0) && (copter.channel_throttle->get_control_in() == 0)) {
break
}

AP_Mission::Mission_Command cmd  = {}

if (copter.mode_auto.mission.num_commands() == 0) {
cmd.id = MAV_CMD_NAV_TAKEOFF
cmd.content.location.alt = MAX(copter.current_loc.alt,100)

if (copter.mode_auto.mission.add_cmd(cmd)) {
AP::logger().Write_Event(LogEvent::SAVEWP_ADD_WP)
}
}

cmd.content.location = copter.current_loc

if (copter.channel_throttle->get_control_in() > 0) {
cmd.id = MAV_CMD_NAV_WAYPOINT
} else {
cmd.id = MAV_CMD_NAV_LAND
}

if (copter.mode_auto.mission.add_cmd(cmd)) {
AP::logger().Write_Event(LogEvent::SAVEWP_ADD_WP)
}
}
break

case AUX_FUNC::AUTO:
do_aux_function_change_mode(Mode::Number::AUTO, ch_flag)
break

case AUX_FUNC::RANGEFINDER:
if ((ch_flag == AuxSwitchPos::HIGH) &&
copter.rangefinder.has_orientation(ROTATION_PITCH_270)) {
copter.rangefinder_state.enabled = true
} else {
copter.rangefinder_state.enabled = false
}
break

case AUX_FUNC::ACRO_TRAINER:
switch(ch_flag) {
case AuxSwitchPos::LOW:
copter.g.acro_trainer.set((uint8_t)ModeAcro::Trainer::OFF)
AP::logger().Write_Event(LogEvent::ACRO_TRAINER_OFF)
break
case AuxSwitchPos::MIDDLE:
copter.g.acro_trainer.set((uint8_t)ModeAcro::Trainer::LEVELING)
AP::logger().Write_Event(LogEvent::ACRO_TRAINER_LEVELING)
break
case AuxSwitchPos::HIGH:
copter.g.acro_trainer.set((uint8_t)ModeAcro::Trainer::LIMITED)
AP::logger().Write_Event(LogEvent::ACRO_TRAINER_LIMITED)
break
}
break

case AUX_FUNC::AUTOTUNE:
do_aux_function_change_mode(Mode::Number::AUTOTUNE, ch_flag)
break

case AUX_FUNC::LAND:
do_aux_function_change_mode(Mode::Number::LAND, ch_flag)
break

case AUX_FUNC::GUIDED:
do_aux_function_change_mode(Mode::Number::GUIDED, ch_flag)
break

case AUX_FUNC::LOITER:
do_aux_function_change_mode(Mode::Number::LOITER, ch_flag)
break

case AUX_FUNC::FOLLOW:
do_aux_function_change_mode(Mode::Number::FOLLOW, ch_flag)
break

case AUX_FUNC::PARACHUTE_ENABLE:
copter.parachute.enabled(ch_flag == AuxSwitchPos::HIGH)
break

case AUX_FUNC::PARACHUTE_RELEASE:
if (ch_flag == AuxSwitchPos::HIGH) {
copter.parachute_manual_release()
}
break

case AUX_FUNC::PARACHUTE_3POS:
switch (ch_flag) {
case AuxSwitchPos::LOW:
copter.parachute.enabled(false)
break
case AuxSwitchPos::MIDDLE:
copter.parachute.enabled(true)
break
case AuxSwitchPos::HIGH:
copter.parachute.enabled(true)
copter.parachute_manual_release()
break
}
break

case AUX_FUNC::ATTCON_FEEDFWD:
copter.attitude_control->bf_feedforward(ch_flag == AuxSwitchPos::HIGH)
break

case AUX_FUNC::ATTCON_ACCEL_LIM:
copter.attitude_control->accel_limiting(ch_flag == AuxSwitchPos::HIGH)
break

case AUX_FUNC::MOTOR_INTERLOCK:
if (copter.motors->get_rsc_mode() != ROTOR_CONTROL_MODE_PASSTHROUGH) {
copter.ap.motor_interlock_switch = (ch_flag == AuxSwitchPos::HIGH || ch_flag == AuxSwitchPos::MIDDLE)
}
copter.ap.motor_interlock_switch = (ch_flag == AuxSwitchPos::HIGH || ch_flag == AuxSwitchPos::MIDDLE)
break

case AUX_FUNC::TURBINE_START:
switch (ch_flag) {
case AuxSwitchPos::HIGH:
copter.motors->set_turb_start(true)
break
case AuxSwitchPos::MIDDLE:
break
case AuxSwitchPos::LOW:
copter.motors->set_turb_start(false)
break
}
break

case AUX_FUNC::BRAKE:
do_aux_function_change_mode(Mode::Number::BRAKE, ch_flag)
break

case AUX_FUNC::THROW:
do_aux_function_change_mode(Mode::Number::THROW, ch_flag)
break

case AUX_FUNC::PRECISION_LOITER:
switch (ch_flag) {
case AuxSwitchPos::HIGH:
copter.mode_loiter.set_precision_loiter_enabled(true)
break
case AuxSwitchPos::MIDDLE:
break
case AuxSwitchPos::LOW:
copter.mode_loiter.set_precision_loiter_enabled(false)
break
}
break

case AUX_FUNC::SMART_RTL:
do_aux_function_change_mode(Mode::Number::SMART_RTL, ch_flag)
break

case AUX_FUNC::INVERTED:
switch (ch_flag) {
case AuxSwitchPos::HIGH:
copter.motors->set_inverted_flight(true)
copter.attitude_control->set_inverted_flight(true)
copter.heli_flags.inverted_flight = true
break
case AuxSwitchPos::MIDDLE:
break
case AuxSwitchPos::LOW:
copter.motors->set_inverted_flight(false)
copter.attitude_control->set_inverted_flight(false)
copter.heli_flags.inverted_flight = false
break
}
break

case AUX_FUNC::WINCH_ENABLE:
switch (ch_flag) {
case AuxSwitchPos::HIGH:
copter.g2.winch.set_desired_rate(0.0f)
break
case AuxSwitchPos::MIDDLE:
case AuxSwitchPos::LOW:
copter.g2.winch.relax()
break
}
break

case AUX_FUNC::WINCH_CONTROL:
break

case AUX_FUNC::USER_FUNC1:
copter.userhook_auxSwitch1(ch_flag)
break

case AUX_FUNC::USER_FUNC2:
copter.userhook_auxSwitch2(ch_flag)
break

case AUX_FUNC::USER_FUNC3:
copter.userhook_auxSwitch3(ch_flag)
break

case AUX_FUNC::ZIGZAG:
do_aux_function_change_mode(Mode::Number::ZIGZAG, ch_flag)
break

case AUX_FUNC::ZIGZAG_SaveWP:
if (copter.flightmode == &copter.mode_zigzag) {
copter.mode_zigzag.init_auto()
switch (ch_flag) {
case AuxSwitchPos::LOW:
copter.mode_zigzag.save_or_move_to_destination(ModeZigZag::Destination::A)
break
case AuxSwitchPos::MIDDLE:
copter.mode_zigzag.return_to_manual_control(false)
break
case AuxSwitchPos::HIGH:
copter.mode_zigzag.save_or_move_to_destination(ModeZigZag::Destination::B)
break
}
}
break

case AUX_FUNC::STABILIZE:
do_aux_function_change_mode(Mode::Number::STABILIZE, ch_flag)
break

case AUX_FUNC::POSHOLD:
do_aux_function_change_mode(Mode::Number::POSHOLD, ch_flag)
break

case AUX_FUNC::ALTHOLD:
do_aux_function_change_mode(Mode::Number::ALT_HOLD, ch_flag)
break


case AUX_FUNC::ACRO:
do_aux_function_change_mode(Mode::Number::ACRO, ch_flag)
break

case AUX_FUNC::FLOWHOLD:
do_aux_function_change_mode(Mode::Number::FLOWHOLD, ch_flag)
break

case AUX_FUNC::CIRCLE:
do_aux_function_change_mode(Mode::Number::CIRCLE, ch_flag)
break

case AUX_FUNC::DRIFT:
do_aux_function_change_mode(Mode::Number::DRIFT, ch_flag)
break

case AUX_FUNC::STANDBY: {
switch (ch_flag) {
case AuxSwitchPos::HIGH:
copter.standby_active = true
AP::logger().Write_Event(LogEvent::STANDBY_ENABLE)
gcs().send_text(MAV_SEVERITY_INFO, ""Stand By Enabled"")
break
default:
copter.standby_active = false
AP::logger().Write_Event(LogEvent::STANDBY_DISABLE)
gcs().send_text(MAV_SEVERITY_INFO, ""Stand By Disabled"")
break
}
break
}

case AUX_FUNC::SURFACE_TRACKING:
switch (ch_flag) {
case AuxSwitchPos::LOW:
copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::GROUND)
break
case AuxSwitchPos::MIDDLE:
copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::NONE)
break
case AuxSwitchPos::HIGH:
copter.surface_tracking.set_surface(Copter::SurfaceTracking::Surface::CEILING)
break
}
break

case AUX_FUNC::ZIGZAG_Auto:
if (copter.flightmode == &copter.mode_zigzag) {
switch (ch_flag) {
case AuxSwitchPos::HIGH:
copter.mode_zigzag.run_auto()
break
default:
copter.mode_zigzag.suspend_auto()
break
}
}
break

case AUX_FUNC::AIRMODE:
do_aux_function_change_air_mode(ch_flag)
copter.mode_acro.air_mode_aux_changed()
break

case AUX_FUNC::FORCEFLYING:
do_aux_function_change_force_flying(ch_flag)
break

case AUX_FUNC::AUTO_RTL:
do_aux_function_change_mode(Mode::Number::AUTO_RTL, ch_flag)
break

case AUX_FUNC::TURTLE:
do_aux_function_change_mode(Mode::Number::TURTLE, ch_flag)
break

case AUX_FUNC::SIMPLE_HEADING_RESET:
if (ch_flag == AuxSwitchPos::HIGH) {
copter.init_simple_bearing()
gcs().send_text(MAV_SEVERITY_INFO, ""Simple heading reset"")
}
break

case AUX_FUNC::ARMDISARM_AIRMODE:
RC_Channel::do_aux_function_armdisarm(ch_flag)
if (copter.arming.is_armed()) {
copter.ap.armed_with_airmode_switch = true
}
break

case AUX_FUNC::CUSTOM_CONTROLLER:
copter.custom_control.set_custom_controller(ch_flag == AuxSwitchPos::HIGH)
break

default:
return RC_Channel::do_aux_function(ch_option, ch_flag)
}
return true
}
"
602,Arducopter\RC_Channel.cpp_do_aux_function_change_air_mode,"void RC_Channel_Copter::do_aux_function_change_air_mode(const AuxSwitchPos ch_flag)
{
switch (ch_flag) {
case AuxSwitchPos::HIGH:
copter.air_mode = AirMode::AIRMODE_ENABLED
break
case AuxSwitchPos::MIDDLE:
break
case AuxSwitchPos::LOW:
copter.air_mode = AirMode::AIRMODE_DISABLED
break
}
}
"
603,Arducopter\RC_Channel.cpp_do_aux_function_change_force_flying,"void RC_Channel_Copter::do_aux_function_change_force_flying(const AuxSwitchPos ch_flag)
{
switch (ch_flag) {
case AuxSwitchPos::HIGH:
copter.force_flying = true
break
case AuxSwitchPos::MIDDLE:
break
case AuxSwitchPos::LOW:
copter.force_flying = false
break
}
}
"
604,Arducopter\RC_Channel.cpp_save_trim,"void Copter::save_trim()
{
float roll_trim = ToRad((float)channel_roll->get_control_in()/100.0f)
float pitch_trim = ToRad((float)channel_pitch->get_control_in()/100.0f)
ahrs.add_trim(roll_trim, pitch_trim)
AP::logger().Write_Event(LogEvent::SAVE_TRIM)
gcs().send_text(MAV_SEVERITY_INFO, ""Trim saved"")
}
"
605,Arducopter\RC_Channel.cpp_auto_trim_cancel,"void Copter::auto_trim_cancel()
{
auto_trim_counter = 0
AP_Notify::flags.save_trim = false
gcs().send_text(MAV_SEVERITY_INFO, ""AutoTrim cancelled"")
}
"
606,Arducopter\RC_Channel.cpp_auto_trim,"void Copter::auto_trim()
{
if (auto_trim_counter > 0) {
if (copter.flightmode != &copter.mode_stabilize ||
!copter.motors->armed()) {
auto_trim_cancel()
return
}

AP_Notify::flags.save_trim = true

if (!auto_trim_started) {
if (ap.land_complete) {
return
}
auto_trim_started = true
}

if (ap.land_complete) {
auto_trim_cancel()
return
}

auto_trim_counter--

float roll_trim_adjustment = ToRad((float)channel_roll->get_control_in() / 4000.0f)

float pitch_trim_adjustment = ToRad((float)channel_pitch->get_control_in() / 4000.0f)

ahrs.add_trim(roll_trim_adjustment, pitch_trim_adjustment, (auto_trim_counter == 0))

if (auto_trim_counter == 0) {
AP_Notify::flags.save_trim = false
gcs().send_text(MAV_SEVERITY_INFO, ""AutoTrim: Trims saved"")
}
}
}
"
607,Arducopter\sensors.cpp_read_barometer,"void Copter::read_barometer(void)
{
barometer.update()

baro_alt = barometer.get_altitude() * 100.0f

motors->set_air_density_ratio(barometer.get_air_density_ratio())
}
"
608,Arducopter\sensors.cpp_init_rangefinder,"void Copter::init_rangefinder(void)
{
rangefinder.set_log_rfnd_bit(MASK_LOG_CTUN)
rangefinder.init(ROTATION_PITCH_270)
rangefinder_state.alt_cm_filt.set_cutoff_frequency(g2.rangefinder_filt)
rangefinder_state.enabled = rangefinder.has_orientation(ROTATION_PITCH_270)

rangefinder_up_state.alt_cm_filt.set_cutoff_frequency(g2.rangefinder_filt)
rangefinder_up_state.enabled = rangefinder.has_orientation(ROTATION_PITCH_90)
}
"
609,Arducopter\sensors.cpp_read_rangefinder,"void Copter::read_rangefinder(void)
{
rangefinder.update()

const float tilt_correction = MAX(0.707f, ahrs.get_rotation_body_to_ned().c.z)
const float tilt_correction = 1.0f

struct {
RangeFinderState &state
enum Rotation orientation
} rngfnd[2] = {{rangefinder_state, ROTATION_PITCH_270}, {rangefinder_up_state, ROTATION_PITCH_90}}

for (uint8_t i=0
RangeFinderState &rf_state = rngfnd[i].state
enum Rotation rf_orient = rngfnd[i].orientation

rf_state.alt_healthy = ((rangefinder.status_orient(rf_orient) == RangeFinder::Status::Good) &&
(rangefinder.range_valid_count_orient(rf_orient) >= RANGEFINDER_HEALTH_MAX))

rf_state.alt_cm = tilt_correction * rangefinder.distance_cm_orient(rf_orient)

rf_state.inertial_alt_cm = inertial_nav.get_position_z_up_cm()

const int32_t glitch_cm = rf_state.alt_cm - rf_state.alt_cm_glitch_protected
if (glitch_cm >= RANGEFINDER_GLITCH_ALT_CM) {
rf_state.glitch_count = MAX(rf_state.glitch_count+1, 1)
} else if (glitch_cm <= -RANGEFINDER_GLITCH_ALT_CM) {
rf_state.glitch_count = MIN(rf_state.glitch_count-1, -1)
} else {
rf_state.glitch_count = 0
rf_state.alt_cm_glitch_protected = rf_state.alt_cm
}
if (abs(rf_state.glitch_count) >= RANGEFINDER_GLITCH_NUM_SAMPLES) {
rf_state.glitch_count = 0
rf_state.alt_cm_glitch_protected = rf_state.alt_cm
rf_state.glitch_cleared_ms = AP_HAL::millis()
}

uint32_t now = AP_HAL::millis()
const bool timed_out = now - rf_state.last_healthy_ms > RANGEFINDER_TIMEOUT_MS
if (rf_state.alt_healthy) {
if (timed_out) {
rf_state.alt_cm_filt.reset(rf_state.alt_cm)
} else {
rf_state.alt_cm_filt.apply(rf_state.alt_cm, 0.05f)
}
rf_state.last_healthy_ms = now
}

if (rf_orient == ROTATION_PITCH_270) {
if (rangefinder_state.alt_healthy || timed_out) {
wp_nav->set_rangefinder_alt(rangefinder_state.enabled, rangefinder_state.alt_healthy, rangefinder_state.alt_cm_filt.get())
circle_nav->set_rangefinder_alt(rangefinder_state.enabled && wp_nav->rangefinder_used(), rangefinder_state.alt_healthy, rangefinder_state.alt_cm_filt.get())
g2.proximity.set_rangefinder_alt(rangefinder_state.enabled, rangefinder_state.alt_healthy, rangefinder_state.alt_cm_filt.get())
}
}
}

rangefinder_state.enabled = false
rangefinder_state.alt_healthy = false
rangefinder_state.alt_cm = 0

rangefinder_up_state.enabled = false
rangefinder_up_state.alt_healthy = false
rangefinder_up_state.alt_cm = 0
}
"
610,Arducopter\sensors.cpp_rangefinder_alt_ok,"bool Copter::rangefinder_alt_ok() const
{
return (rangefinder_state.enabled && rangefinder_state.alt_healthy)
}
"
611,Arducopter\sensors.cpp_rangefinder_up_ok,"bool Copter::rangefinder_up_ok() const
{
return (rangefinder_up_state.enabled && rangefinder_up_state.alt_healthy)
}
"
612,Arducopter\sensors.cpp_get_rangefinder_height_interpolated_cm,"bool Copter::get_rangefinder_height_interpolated_cm(int32_t& ret) const
{
if (!rangefinder_alt_ok()) {
return false
}
ret = rangefinder_state.alt_cm_filt.get()
float inertial_alt_cm = inertial_nav.get_position_z_up_cm()
ret += inertial_alt_cm - rangefinder_state.inertial_alt_cm
return true
}
"
613,Arducopter\standby.cpp_standby_update,"void Copter::standby_update()
{
if (!standby_active) {
return
}

attitude_control->reset_rate_controller_I_terms()
attitude_control->reset_yaw_target_and_rate()
pos_control->standby_xyz_reset()
}
"
614,Arducopter\surface_tracking.cpp_update_surface_offset,"void Copter::SurfaceTracking::update_surface_offset()
{
const uint32_t now_ms = millis()
const bool timeout = (now_ms - last_update_ms) > SURFACE_TRACKING_TIMEOUT_MS

if (((surface == Surface::GROUND) && copter.rangefinder_alt_ok() && (copter.rangefinder_state.glitch_count == 0)) ||
((surface == Surface::CEILING) && copter.rangefinder_up_ok() && (copter.rangefinder_up_state.glitch_count == 0))) {

RangeFinderState &rf_state = (surface == Surface::GROUND) ? copter.rangefinder_state : copter.rangefinder_up_state
const float dir = (surface == Surface::GROUND) ? 1.0f : -1.0f
const float curr_surface_alt_above_origin_cm = copter.inertial_nav.get_position_z_up_cm() - dir * rf_state.alt_cm

copter.pos_control->set_pos_offset_target_z_cm(curr_surface_alt_above_origin_cm)
last_update_ms = now_ms
valid_for_logging = true

if (timeout ||
reset_target ||
(last_glitch_cleared_ms != rf_state.glitch_cleared_ms)) {
copter.pos_control->set_pos_offset_z_cm(curr_surface_alt_above_origin_cm)
reset_target = false
last_glitch_cleared_ms = rf_state.glitch_cleared_ms
}

} else {
if (timeout) {
copter.pos_control->set_pos_offset_z_cm(0)
copter.pos_control->set_pos_offset_target_z_cm(0)
reset_target = true
}
}
copter.pos_control->set_pos_offset_z_cm(0)
copter.pos_control->set_pos_offset_target_z_cm(0)
}
"
615,Arducopter\surface_tracking.cpp_get_target_alt_cm,"bool Copter::SurfaceTracking::get_target_alt_cm(float &target_alt_cm) const
{
if (surface != Surface::GROUND) {
return false
}
if (AP_HAL::millis() - last_update_ms > SURFACE_TRACKING_TIMEOUT_MS) {
return false
}
target_alt_cm = (copter.pos_control->get_pos_target_z_cm() - copter.pos_control->get_pos_offset_z_cm())
return true
}
"
616,Arducopter\surface_tracking.cpp_set_target_alt_cm,"void Copter::SurfaceTracking::set_target_alt_cm(float _target_alt_cm)
{
if (surface != Surface::GROUND) {
return
}
copter.pos_control->set_pos_offset_z_cm(copter.inertial_nav.get_position_z_up_cm() - _target_alt_cm)
last_update_ms = AP_HAL::millis()
}
"
617,Arducopter\surface_tracking.cpp_get_target_dist_for_logging,"bool Copter::SurfaceTracking::get_target_dist_for_logging(float &target_dist) const
{
if (!valid_for_logging || (surface == Surface::NONE)) {
return false
}

const float dir = (surface == Surface::GROUND) ? 1.0f : -1.0f
target_dist = dir * (copter.pos_control->get_pos_target_z_cm() - copter.pos_control->get_pos_offset_z_cm()) * 0.01f
return true
}
"
618,Arducopter\surface_tracking.cpp_get_dist_for_logging,"float Copter::SurfaceTracking::get_dist_for_logging() const
{
return ((surface == Surface::CEILING) ? copter.rangefinder_up_state.alt_cm : copter.rangefinder_state.alt_cm) * 0.01f
}
"
619,Arducopter\surface_tracking.cpp_set_surface,"void Copter::SurfaceTracking::set_surface(Surface new_surface)
{
if (surface == new_surface) {
return
}
if ((new_surface == Surface::GROUND) && !copter.rangefinder.has_orientation(ROTATION_PITCH_270)) {
copter.gcs().send_text(MAV_SEVERITY_WARNING, ""SurfaceTracking: no downward rangefinder"")
AP_Notify::events.user_mode_change_failed = 1
return
}
if ((new_surface == Surface::CEILING) && !copter.rangefinder.has_orientation(ROTATION_PITCH_90)) {
copter.gcs().send_text(MAV_SEVERITY_WARNING, ""SurfaceTracking: no upward rangefinder"")
AP_Notify::events.user_mode_change_failed = 1
return
}
surface = new_surface
reset_target = true
}
"
620,Arducopter\system.cpp_failsafe_check_static,"static void failsafe_check_static()
{
copter.failsafe_check()
}
"
621,Arducopter\system.cpp_init_ardupilot,"void Copter::init_ardupilot()
{

g2.stats.init()

BoardConfig.init()
can_mgr.init()

g2.gripper.init()

g2.winch.init()

notify.init()
notify_flight_mode()

battery.init()

rssi.init()

barometer.init()

gcs().setup_uarts()

osd.init()

log_init()

update_using_interlock()

heli_init()
input_manager.set_loop_rate(scheduler.get_loop_rate_hz())

init_rc_in()

surface_tracking.init((SurfaceTracking::Surface)copter.g2.surftrak_mode.get())

allocate_motors()

rc().convert_options(RC_Channel::AUX_FUNC::ARMDISARM_UNUSED, RC_Channel::AUX_FUNC::ARMDISARM_AIRMODE)
rc().init()

init_rc_out()

esc_calibration_startup_check()

ap.initialised_params = true

relay.init()

hal.scheduler->register_timer_failsafe(failsafe_check_static, 1000)

gps.set_log_gps_bit(MASK_LOG_GPS)
gps.init(serial_manager)

AP::compass().set_log_bit(MASK_LOG_COMPASS)
AP::compass().init()

airspeed.set_log_bit(MASK_LOG_IMU)

g2.oa.init()

attitude_control->parameter_sanity_check()

optflow.init(MASK_LOG_OPTFLOW)

camera_mount.init()

init_precland()

landinggear.init()

USERHOOK_INIT

barometer.set_log_baro_bit(MASK_LOG_IMU)
barometer.calibrate()

init_rangefinder()

g2.proximity.init()

g2.beacon.init()

rpm_sensor.init()

mode_auto.mission.init()

g2.smart_rtl.init()

logger.setVehicle_Startup_Writer(FUNCTOR_BIND(&copter, &Copter::Log_Write_Vehicle_Startup_Messages, void))

startup_INS_ground()

g2.scripting.init()

custom_control.init()

set_land_complete(true)
set_land_complete_maybe(true)

serial_manager.set_blocking_writes_all(false)

failsafe_enable()

ins.set_log_raw_bit(MASK_LOG_IMU_RAW)

if (arming.rc_calibration_checks(true)) {
enable_motor_output()
}

if (!set_mode((enum Mode::Number)g.initial_mode.get(), ModeReason::INITIALISED)) {
set_mode(Mode::Number::STABILIZE, ModeReason::UNAVAILABLE)
}

ap.initialised = true
}
"
622,Arducopter\system.cpp_startup_INS_ground,"void Copter::startup_INS_ground()
{
ahrs.init()
ahrs.set_vehicle_class(AP_AHRS::VehicleClass::COPTER)

ins.init(scheduler.get_loop_rate_hz())

ahrs.reset()
}
"
623,Arducopter\system.cpp_position_ok,"bool Copter::position_ok() const
{
if (failsafe.ekf) {
return false
}

return (ekf_has_absolute_position() || ekf_has_relative_position())
}
"
624,Arducopter\system.cpp_ekf_has_absolute_position,"bool Copter::ekf_has_absolute_position() const
{
if (!ahrs.have_inertial_nav()) {
return false
}

nav_filter_status filt_status = inertial_nav.get_filter_status()

if (!motors->armed()) {
return ((filt_status.flags.horiz_pos_abs || filt_status.flags.pred_horiz_pos_abs))
} else {
return (filt_status.flags.horiz_pos_abs && !filt_status.flags.const_pos_mode)
}
}
"
625,Arducopter\system.cpp_ekf_has_relative_position,"bool Copter::ekf_has_relative_position() const
{
if (!ahrs.have_inertial_nav()) {
return false
}

bool enabled = false
if (optflow.enabled()) {
enabled = true
}
if (visual_odom.enabled()) {
enabled = true
}
if (dead_reckoning.active && !dead_reckoning.timeout) {
enabled = true
}
if (!enabled) {
return false
}

nav_filter_status filt_status = inertial_nav.get_filter_status()

if (!motors->armed()) {
return (filt_status.flags.pred_horiz_pos_rel)
} else {
return (filt_status.flags.horiz_pos_rel && !filt_status.flags.const_pos_mode)
}
}
"
626,Arducopter\system.cpp_ekf_alt_ok,"bool Copter::ekf_alt_ok() const
{
if (!ahrs.have_inertial_nav()) {
return false
}

nav_filter_status filt_status = inertial_nav.get_filter_status()

return (filt_status.flags.vert_vel && filt_status.flags.vert_pos)
}
"
627,Arducopter\system.cpp_update_auto_armed,"void Copter::update_auto_armed()
{
if(ap.auto_armed){
if(!motors->armed()) {
set_auto_armed(false)
return
}
if(flightmode->has_manual_throttle() && ap.throttle_zero && !failsafe.radio) {
set_auto_armed(false)
}

}else{

if(motors->armed() && ap.using_interlock) {
if(!ap.throttle_zero && motors->get_spool_state() == AP_Motors::SpoolState::THROTTLE_UNLIMITED) {
set_auto_armed(true)
}
} else if (motors->armed() && !ap.using_interlock) {
if(!ap.throttle_zero || flightmode->mode_number() == Mode::Number::THROW) {
set_auto_armed(true)
}
}
}
}
"
628,Arducopter\system.cpp_should_log,"bool Copter::should_log(uint32_t mask)
{
ap.logging_started = logger.logging_started()
return logger.should_log(mask)
return false
}
"
629,Arducopter\system.cpp_allocate_motors,"void Copter::allocate_motors(void)
{
switch ((AP_Motors::motor_frame_class)g2.frame_class.get()) {
case AP_Motors::MOTOR_FRAME_QUAD:
case AP_Motors::MOTOR_FRAME_HEXA:
case AP_Motors::MOTOR_FRAME_Y6:
case AP_Motors::MOTOR_FRAME_OCTA:
case AP_Motors::MOTOR_FRAME_OCTAQUAD:
case AP_Motors::MOTOR_FRAME_DODECAHEXA:
case AP_Motors::MOTOR_FRAME_DECA:
case AP_Motors::MOTOR_FRAME_SCRIPTING_MATRIX:
default:
motors = new AP_MotorsMatrix(copter.scheduler.get_loop_rate_hz())
motors_var_info = AP_MotorsMatrix::var_info
break
case AP_Motors::MOTOR_FRAME_TRI:
motors = new AP_MotorsTri(copter.scheduler.get_loop_rate_hz())
motors_var_info = AP_MotorsTri::var_info
AP_Param::set_frame_type_flags(AP_PARAM_FRAME_TRICOPTER)
break
case AP_Motors::MOTOR_FRAME_SINGLE:
motors = new AP_MotorsSingle(copter.scheduler.get_loop_rate_hz())
motors_var_info = AP_MotorsSingle::var_info
break
case AP_Motors::MOTOR_FRAME_COAX:
motors = new AP_MotorsCoax(copter.scheduler.get_loop_rate_hz())
motors_var_info = AP_MotorsCoax::var_info
break
case AP_Motors::MOTOR_FRAME_TAILSITTER:
motors = new AP_MotorsTailsitter(copter.scheduler.get_loop_rate_hz())
motors_var_info = AP_MotorsTailsitter::var_info
break
case AP_Motors::MOTOR_FRAME_6DOF_SCRIPTING:
motors = new AP_MotorsMatrix_6DoF_Scripting(copter.scheduler.get_loop_rate_hz())
motors_var_info = AP_MotorsMatrix_6DoF_Scripting::var_info
break
case AP_Motors::MOTOR_FRAME_DYNAMIC_SCRIPTING_MATRIX:
motors = new AP_MotorsMatrix_Scripting_Dynamic(copter.scheduler.get_loop_rate_hz())
motors_var_info = AP_MotorsMatrix_Scripting_Dynamic::var_info
break
case AP_Motors::MOTOR_FRAME_HELI_DUAL:
motors = new AP_MotorsHeli_Dual(copter.scheduler.get_loop_rate_hz())
motors_var_info = AP_MotorsHeli_Dual::var_info
AP_Param::set_frame_type_flags(AP_PARAM_FRAME_HELI)
break

case AP_Motors::MOTOR_FRAME_HELI_QUAD:
motors = new AP_MotorsHeli_Quad(copter.scheduler.get_loop_rate_hz())
motors_var_info = AP_MotorsHeli_Quad::var_info
AP_Param::set_frame_type_flags(AP_PARAM_FRAME_HELI)
break

case AP_Motors::MOTOR_FRAME_HELI:
default:
motors = new AP_MotorsHeli_Single(copter.scheduler.get_loop_rate_hz())
motors_var_info = AP_MotorsHeli_Single::var_info
AP_Param::set_frame_type_flags(AP_PARAM_FRAME_HELI)
break
}
if (motors == nullptr) {
AP_BoardConfig::allocation_error(""FRAME_CLASS=%u"", (unsigned)g2.frame_class.get())
}
AP_Param::load_object_from_eeprom(motors, motors_var_info)

ahrs_view = ahrs.create_view(ROTATION_NONE)
if (ahrs_view == nullptr) {
AP_BoardConfig::allocation_error(""AP_AHRS_View"")
}

const struct AP_Param::GroupInfo *ac_var_info

if ((AP_Motors::motor_frame_class)g2.frame_class.get() == AP_Motors::MOTOR_FRAME_6DOF_SCRIPTING) {
attitude_control = new AC_AttitudeControl_Multi_6DoF(*ahrs_view, aparm, *motors, scheduler.get_loop_period_s())
ac_var_info = AC_AttitudeControl_Multi_6DoF::var_info
} else {
attitude_control = new AC_AttitudeControl_Multi(*ahrs_view, aparm, *motors, scheduler.get_loop_period_s())
ac_var_info = AC_AttitudeControl_Multi::var_info
}
attitude_control = new AC_AttitudeControl_Heli(*ahrs_view, aparm, *motors, scheduler.get_loop_period_s())
ac_var_info = AC_AttitudeControl_Heli::var_info
if (attitude_control == nullptr) {
AP_BoardConfig::allocation_error(""AttitudeControl"")
}
AP_Param::load_object_from_eeprom(attitude_control, ac_var_info)

pos_control = new AC_PosControl(*ahrs_view, inertial_nav, *motors, *attitude_control, scheduler.get_loop_period_s())
if (pos_control == nullptr) {
AP_BoardConfig::allocation_error(""PosControl"")
}
AP_Param::load_object_from_eeprom(pos_control, pos_control->var_info)

wp_nav = new AC_WPNav_OA(inertial_nav, *ahrs_view, *pos_control, *attitude_control)
wp_nav = new AC_WPNav(inertial_nav, *ahrs_view, *pos_control, *attitude_control)
if (wp_nav == nullptr) {
AP_BoardConfig::allocation_error(""WPNav"")
}
AP_Param::load_object_from_eeprom(wp_nav, wp_nav->var_info)

loiter_nav = new AC_Loiter(inertial_nav, *ahrs_view, *pos_control, *attitude_control)
if (loiter_nav == nullptr) {
AP_BoardConfig::allocation_error(""LoiterNav"")
}
AP_Param::load_object_from_eeprom(loiter_nav, loiter_nav->var_info)

circle_nav = new AC_Circle(inertial_nav, *ahrs_view, *pos_control)
if (circle_nav == nullptr) {
AP_BoardConfig::allocation_error(""CircleNav"")
}
AP_Param::load_object_from_eeprom(circle_nav, circle_nav->var_info)

AP_Param::reload_defaults_file(true)

switch ((AP_Motors::motor_frame_class)g2.frame_class.get()) {
case AP_Motors::MOTOR_FRAME_Y6:
attitude_control->get_rate_roll_pid().kP().set_default(0.1)
attitude_control->get_rate_roll_pid().kD().set_default(0.006)
attitude_control->get_rate_pitch_pid().kP().set_default(0.1)
attitude_control->get_rate_pitch_pid().kD().set_default(0.006)
attitude_control->get_rate_yaw_pid().kP().set_default(0.15)
attitude_control->get_rate_yaw_pid().kI().set_default(0.015)
break
case AP_Motors::MOTOR_FRAME_TRI:
attitude_control->get_rate_yaw_pid().filt_D_hz().set_default(100)
break
default:
break
}

if (motors->is_brushed_pwm_type()) {
g.rc_speed.set_default(16000)
}

convert_pid_parameters()
convert_tradheli_parameters()

convert_prx_parameters()

AP_Param::invalidate_count()
}
"
630,Arducopter\system.cpp_is_tradheli,"bool Copter::is_tradheli() const
{
return true
return false
}
"
631,Arducopter\takeoff.cpp_do_user_takeoff_start,"bool Mode::do_user_takeoff_start(float takeoff_alt_cm)
{
copter.flightmode->takeoff.start(takeoff_alt_cm)
return true
}
"
632,Arducopter\takeoff.cpp_do_user_takeoff,"bool Mode::do_user_takeoff(float takeoff_alt_cm, bool must_navigate)
{
if (!copter.motors->armed()) {
return false
}
if (!copter.ap.land_complete) {
return false
}
if (!has_user_takeoff(must_navigate)) {
return false
}
if (takeoff_alt_cm <= copter.current_loc.alt) {
return false
}

if (!motors->get_interlock() && copter.ap.using_interlock) {
return false
}

if (!do_user_takeoff_start(takeoff_alt_cm)) {
return false
}

copter.set_auto_armed(true)
return true
}
"
633,Arducopter\takeoff.cpp_start,"void Mode::_TakeOff::start(float alt_cm)
{
_running = true
take_off_start_alt = copter.pos_control->get_pos_target_z_cm()
take_off_complete_alt  = take_off_start_alt + alt_cm
}
"
634,Arducopter\takeoff.cpp_stop,"void Mode::_TakeOff::stop()
{
_running = false
if (copter.attitude_control->get_throttle_in() > copter.get_non_takeoff_throttle()) {
copter.set_land_complete(false)
}
}
"
635,Arducopter\takeoff.cpp_do_pilot_takeoff,"void Mode::_TakeOff::do_pilot_takeoff(float& pilot_climb_rate_cm)
{
if (!_running) {
return
}

if (copter.ap.land_complete) {
float throttle = constrain_float(copter.attitude_control->get_throttle_in() + copter.G_Dt / copter.g2.takeoff_throttle_slew_time, 0.0, 1.0)
copter.attitude_control->set_throttle_out(throttle, true, 0.0)
copter.pos_control->init_z_controller()
if (throttle >= 0.9 ||
(copter.pos_control->get_z_accel_cmss() >= 0.5 * copter.pos_control->get_max_accel_z_cmss()) ||
(copter.pos_control->get_vel_desired_cms().z >= constrain_float(pilot_climb_rate_cm, copter.pos_control->get_max_speed_up_cms() * 0.1, copter.pos_control->get_max_speed_up_cms() * 0.5)) ||
(is_positive(take_off_complete_alt - take_off_start_alt) && copter.pos_control->get_pos_target_z_cm() - take_off_start_alt > 0.5 * (take_off_complete_alt - take_off_start_alt))) {
copter.set_land_complete(false)
}
} else {
float pos_z = take_off_complete_alt
float vel_z = pilot_climb_rate_cm

copter.pos_control->input_pos_vel_accel_z(pos_z, vel_z, 0)

if (is_negative(pilot_climb_rate_cm) ||
(take_off_complete_alt  - take_off_start_alt) * 0.999f < copter.pos_control->get_pos_target_z_cm() - take_off_start_alt) {
stop()
}
}
}
"
636,Arducopter\takeoff.cpp_auto_takeoff_run,"void Mode::auto_takeoff_run()
{
if (!motors->armed() || !copter.ap.auto_armed) {
make_safe_ground_handling(copter.is_tradheli() && motors->get_interlock())
return
}

float terr_offset = 0.0f
if (auto_takeoff_terrain_alt && !wp_nav->get_terrain_offset(terr_offset)) {
copter.failsafe_terrain_on_event()
return
}

motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED)

float target_yaw_rate = 0
if (!copter.failsafe.radio && copter.flightmode->use_pilot_yaw()) {
target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->norm_input_dz())
if (!is_zero(target_yaw_rate)) {
auto_yaw.set_mode(AUTO_YAW_HOLD)
}
}

if (motors->get_spool_state() != AP_Motors::SpoolState::THROTTLE_UNLIMITED) {
pos_control->relax_velocity_controller_xy()
pos_control->update_xy_controller()
pos_control->relax_z_controller(0.0f)
pos_control->update_z_controller()
attitude_control->reset_yaw_target_and_rate()
attitude_control->reset_rate_controller_I_terms()
attitude_control->input_thrust_vector_rate_heading(pos_control->get_thrust_vector(), 0.0)
return
}

if (copter.ap.land_complete) {
float throttle = constrain_float(copter.attitude_control->get_throttle_in() + copter.G_Dt / copter.g2.takeoff_throttle_slew_time, 0.0, 1.0)
copter.attitude_control->set_throttle_out(throttle, true, 0.0)
copter.pos_control->init_z_controller()
pos_control->relax_velocity_controller_xy()
pos_control->update_xy_controller()
attitude_control->reset_rate_controller_I_terms()
attitude_control->input_thrust_vector_rate_heading(pos_control->get_thrust_vector(), 0.0)
if (throttle >= 0.9 ||
(copter.pos_control->get_z_accel_cmss() >= 0.5 * copter.pos_control->get_max_accel_z_cmss()) ||
(copter.pos_control->get_vel_desired_cms().z >= 0.1 * copter.pos_control->get_max_speed_up_cms()) ||
( auto_takeoff_no_nav_active && (inertial_nav.get_position_z_up_cm() >= auto_takeoff_no_nav_alt_cm))) {
copter.set_land_complete(false)
}
return
}

if (auto_takeoff_no_nav_active) {
if (inertial_nav.get_position_z_up_cm() >= auto_takeoff_no_nav_alt_cm) {
auto_takeoff_no_nav_active = false
}
pos_control->relax_velocity_controller_xy()
} else {
Vector2f vel
Vector2f accel
pos_control->input_vel_accel_xy(vel, accel)
}
pos_control->update_xy_controller()

float pos_z = auto_takeoff_complete_alt_cm + terr_offset
float vel_z = 0.0
copter.pos_control->input_pos_vel_accel_z(pos_z, vel_z, 0.0)

pos_control->update_z_controller()

if (auto_yaw.mode() == AUTO_YAW_HOLD) {
attitude_control->input_thrust_vector_rate_heading(pos_control->get_thrust_vector(), target_yaw_rate)
} else if (auto_yaw.mode() == AUTO_YAW_RATE) {
attitude_control->input_thrust_vector_rate_heading(pos_control->get_thrust_vector(), auto_yaw.rate_cds())
} else {
attitude_control->input_thrust_vector_heading(pos_control->get_thrust_vector(), auto_yaw.yaw(), auto_yaw.rate_cds())
}

bool reached_altitude = (copter.pos_control->get_pos_target_z_cm() - auto_takeoff_start_alt_cm) >= ((auto_takeoff_complete_alt_cm + terr_offset - auto_takeoff_start_alt_cm) * 0.90)
bool reached_climb_rate = copter.pos_control->get_vel_desired_cms().z < copter.pos_control->get_max_speed_up_cms() * 0.1
auto_takeoff_complete = reached_altitude && reached_climb_rate

if (auto_takeoff_complete) {
const Vector3p& complete_pos = copter.pos_control->get_pos_target_cm()
auto_takeoff_complete_pos = Vector3p{complete_pos.x, complete_pos.y, pos_z}
}
}
"
637,Arducopter\takeoff.cpp_auto_takeoff_start,"void Mode::auto_takeoff_start(float complete_alt_cm, bool terrain_alt)
{
auto_takeoff_start_alt_cm = inertial_nav.get_position_z_up_cm()
auto_takeoff_complete_alt_cm = complete_alt_cm
auto_takeoff_terrain_alt = terrain_alt
auto_takeoff_complete = false
if ((g2.wp_navalt_min > 0) && (is_disarmed_or_landed() || !motors->get_interlock())) {
auto_takeoff_no_nav_alt_cm = auto_takeoff_start_alt_cm + g2.wp_navalt_min * 100
auto_takeoff_no_nav_active = true
} else {
auto_takeoff_no_nav_active = false
}
}
"
638,Arducopter\takeoff.cpp_auto_takeoff_get_position,"bool Mode::auto_takeoff_get_position(Vector3p& complete_pos)
{
if (!auto_takeoff_complete) {
return false
}

complete_pos = auto_takeoff_complete_pos
return true
}
"
639,Arducopter\takeoff.cpp_is_taking_off,"bool Mode::is_taking_off() const
{
if (!has_user_takeoff(false)) {
return false
}
return takeoff.running()
}
"
640,Arducopter\takeoff_check.cpp_takeoff_check,"void Copter::takeoff_check()
{
if ((g2.takeoff_rpm_min <= 0) || (motors->armed() && !ap.land_complete)) {
motors->set_spoolup_block(false)
return
}

if (!motors->armed()) {
motors->set_spoolup_block(true)
takeoff_check_warning_ms = 0
return
}

if (!motors->get_spoolup_block()) {
return
}

uint32_t motor_mask = motors->get_motor_mask()
const bool telem_active = AP::esc_telem().is_telemetry_active(motor_mask)
const bool rpm_adequate = AP::esc_telem().are_motors_running(motor_mask, g2.takeoff_rpm_min)

if (telem_active && rpm_adequate) {
motors->set_spoolup_block(false)
return
}

uint32_t now_ms = AP_HAL::millis()
if (takeoff_check_warning_ms == 0) {
takeoff_check_warning_ms = now_ms
}
if (now_ms - takeoff_check_warning_ms > 5000) {
takeoff_check_warning_ms = now_ms
const char* prefix_str = ""Takeoff blocked:""
if (!telem_active) {
gcs().send_text(MAV_SEVERITY_CRITICAL, ""%s waiting for ESC RPM"", prefix_str)
} else if (!rpm_adequate) {
gcs().send_text(MAV_SEVERITY_CRITICAL, ""%s ESC RPM too low"", prefix_str)
}
}
}
"
641,Arducopter\terrain.cpp_terrain_update,"void Copter::terrain_update()
{
terrain.update()

float height
if (terrain.height_above_terrain(height, true)) {
rangefinder.set_estimated_terrain_height(height)
}
}
"
642,Arducopter\terrain.cpp_terrain_logging,"void Copter::terrain_logging()
{
if (should_log(MASK_LOG_GPS)) {
terrain.log_terrain_data()
}
}
"
643,Arducopter\toy_mode.cpp_ToyMode,"ToyMode::ToyMode()
{
AP_Param::setup_object_defaults(this, var_info)
}
"
644,Arducopter\toy_mode.cpp_update,"void ToyMode::update()
{
if (!enable) {
return
}

if (!copter.motors->armed()) {
load_test.running = false
}

filtered_voltage = 0.99 * filtered_voltage + 0.01 * copter.battery.voltage()

blink_update()

if (!done_first_update) {
done_first_update = true
copter.set_mode(Mode::Number(primary_mode[0].get()), ModeReason::TOY_MODE)
copter.motors->set_thrust_compensation_callback(FUNCTOR_BIND_MEMBER(&ToyMode::thrust_limiting, void, float *, uint8_t))
}

if (trim_auto > 0) {
trim_update()
}

copter.ahrs.set_indoor_mode(copter.flightmode->mode_number() == ALT_HOLD || copter.flightmode->mode_number() == FLOWHOLD)

bool left_button = false
bool right_button = false
bool left_action_button = false
bool right_action_button = false
bool power_button = false
bool left_change = false

uint16_t ch5_in = RC_Channels::get_radio_in(CH_5)
uint16_t ch6_in = RC_Channels::get_radio_in(CH_6)
uint16_t ch7_in = RC_Channels::get_radio_in(CH_7)

if (copter.failsafe.radio || ch5_in < 900) {
green_blink_pattern = BLINK_NO_RX
red_blink_pattern = BLINK_NO_RX
red_blink_index = green_blink_index
return
}

uint32_t now = AP_HAL::millis()

if (is_v2450_buttons()) {
left_change = ((ch5_in > 1700 && last_ch5 <= 1700) || (ch5_in <= 1700 && last_ch5 > 1700))

last_ch5 = ch5_in

left_button = (ch5_in > 2050 || (ch5_in > 1050 && ch5_in < 1150))
right_button = (ch6_in > 1500)
uint8_t ch7_bits = (ch7_in>1000)?uint8_t((ch7_in-1000)/100):0
left_action_button = (ch7_bits&1) != 0
right_action_button = (ch7_bits&2) != 0
power_button = (ch7_bits&4) != 0
} else if (is_f412_buttons()) {
uint8_t ch5_bits = (ch5_in>1000)?uint8_t((ch5_in-1000)/100):0
uint8_t ch6_bits = (ch6_in>1000)?uint8_t((ch6_in-1000)/100):0
left_button = (ch5_bits & 4) != 0
right_button = (ch5_bits & 2) != 0
right_action_button = (ch6_bits & 1) != 0
left_action_button = (ch6_bits & 2) != 0
power_button = (ch6_bits & 4) != 0
left_change = (left_button != last_left_button)
last_left_button = left_button
}

uint8_t action_input = 0
if (left_action_button) {
action_input = 1
} else if (right_action_button) {
action_input = 2
} else if (power_button) {
action_input = 3
}

if (action_input != 0 && left_button) {
action_input += 3
left_press_counter = 0
} else if (left_button) {
left_press_counter++
} else {
left_press_counter = 0
}

bool reset_combination = left_action_button && right_action_button
if (reset_combination && abs(copter.ahrs.roll_sensor) > 160) {
if both shoulder buttons are pressed at the same time for 5
seconds while the vehicle is inverted then we send a
WIFIRESET message to the sonix to reset SSID and password
if (reset_turtle_start_ms == 0) {
reset_turtle_start_ms = now
}
if (now - reset_turtle_start_ms > TOY_RESET_TURTLE_TIME) {
gcs().send_text(MAV_SEVERITY_INFO, ""Tmode: WiFi reset"")
reset_turtle_start_ms = 0
send_named_int(""WIFIRESET"", 1)
}
} else {
reset_turtle_start_ms = 0
}
if (reset_combination) {
action_input = 0
left_press_counter = 0
}

work out commanded action, if any
enum toy_action action = action_input?toy_action(actions[action_input-1].get()):ACTION_NONE

if (action == ACTION_NONE && left_press_counter > TOY_LONG_PRESS_COUNT) {
left_press_counter = -TOY_COMMAND_DELAY
action = toy_action(actions[7].get())
ignore_left_change = true
}

if (ignore_left_change && left_change) {
left_change = false
ignore_left_change = false
}

if (is_v2450_buttons()) {
if (action == ACTION_NONE && left_change) {
action = toy_action(actions[6].get())
}
} else if (is_f412_buttons()) {
if (action == ACTION_NONE && left_change && !left_button) {
action = toy_action(actions[6].get())
}

}

if (action == ACTION_NONE && right_button) {
right_press_counter++
if (right_press_counter >= TOY_RIGHT_PRESS_COUNT) {
action = toy_action(actions[8].get())
right_press_counter = -TOY_COMMAND_DELAY
}
} else {
right_press_counter = 0
}

some actions shouldn't repeat too fast
switch (action) {
case ACTION_TOGGLE_VIDEO:
case ACTION_TOGGLE_MODE:
case ACTION_TOGGLE_SIMPLE:
case ACTION_TOGGLE_SSIMPLE:
case ACTION_ARM_LAND_RTL:
case ACTION_LOAD_TEST:
case ACTION_MODE_FLOW:
if (last_action == action ||
now - last_action_ms < TOY_ACTION_DELAY_MS) {
last_action = action
action = ACTION_NONE
}
break

case ACTION_TAKE_PHOTO:
if (now - last_action_ms < TOY_ACTION_DELAY_MS) {
last_action = action
action = ACTION_NONE
}
break

default:
last_action = action
break
}

if (action != ACTION_NONE) {
gcs().send_text(MAV_SEVERITY_INFO, ""Tmode: action %u"", action)
last_action_ms = now
}

bool throttle_at_min =
copter.channel_throttle->get_control_in() < 150

bool throttle_near_max =
copter.channel_throttle->get_control_in() > 700

disarm if throttle is low for 1 second when landed
if ((flags & FLAG_THR_DISARM) && throttle_at_min && copter.motors->armed() && copter.ap.land_complete) {
throttle_low_counter++
const uint8_t disarm_limit = copter.flightmode->has_manual_throttle()?TOY_LAND_MANUAL_DISARM_COUNT:TOY_LAND_DISARM_COUNT
if (throttle_low_counter >= disarm_limit) {
gcs().send_text(MAV_SEVERITY_INFO, ""Tmode: throttle disarm"")
copter.arming.disarm(AP_Arming::Method::TOYMODELANDTHROTTLE)
}
} else {
throttle_low_counter = 0
}

arm if throttle is high for 1 second when landed
if ((flags & FLAG_THR_ARM) && throttle_near_max && !copter.motors->armed()) {
throttle_high_counter++
if (throttle_high_counter >= TOY_LAND_ARM_COUNT) {
gcs().send_text(MAV_SEVERITY_INFO, ""Tmode: throttle arm"")
arm_check_compass()
if (!copter.arming.arm(AP_Arming::Method::MAVLINK) && (flags & FLAG_UPGRADE_LOITER) && copter.flightmode->mode_number() == Mode::Number::LOITER) {
support auto-switching to ALT_HOLD, then upgrade to LOITER once GPS available
if (set_and_remember_mode(Mode::Number::ALT_HOLD, ModeReason::TOY_MODE)) {
gcs().send_text(MAV_SEVERITY_INFO, ""Tmode: ALT_HOLD update arm"")
copter.fence.enable(false)
if (!copter.arming.arm(AP_Arming::Method::MAVLINK)) {
gcs().send_text(MAV_SEVERITY_ERROR, ""Tmode: ALT_HOLD arm failed"")
set_and_remember_mode(Mode::Number::LOITER, ModeReason::TOY_MODE)
} else {
upgrade_to_loiter = true
AP_Notify::flags.hybrid_loiter = true
}
}
} else {
throttle_arm_ms = AP_HAL::millis()
}
}
} else {
throttle_high_counter = 0
}

if (upgrade_to_loiter) {
if (!copter.motors->armed() || copter.flightmode->mode_number() != Mode::Number::ALT_HOLD) {
upgrade_to_loiter = false
AP_Notify::flags.hybrid_loiter = false
} else if (copter.position_ok() && set_and_remember_mode(Mode::Number::LOITER, ModeReason::TOY_MODE)) {
copter.fence.enable(true)
gcs().send_text(MAV_SEVERITY_INFO, ""Tmode: LOITER update"")
}
}

if (copter.flightmode->mode_number() == Mode::Number::RTL && (flags & FLAG_RTL_CANCEL) && throttle_near_max) {
gcs().send_text(MAV_SEVERITY_INFO, ""Tmode: RTL cancel"")
set_and_remember_mode(Mode::Number::LOITER, ModeReason::TOY_MODE)
}

enum Mode::Number old_mode = copter.flightmode->mode_number()
enum Mode::Number new_mode = old_mode

implement actions
switch (action) {
case ACTION_NONE:
break

case ACTION_TAKE_PHOTO:
send_named_int(""SNAPSHOT"", 1)
break

case ACTION_TOGGLE_VIDEO:
send_named_int(""VIDEOTOG"", 1)
break

case ACTION_MODE_ACRO:
new_mode = Mode::Number::ACRO
gcs().send_text(MAV_SEVERITY_ERROR, ""Tmode: ACRO is disabled"")
break

case ACTION_MODE_ALTHOLD:
new_mode = Mode::Number::ALT_HOLD
break

case ACTION_MODE_AUTO:
new_mode = Mode::Number::AUTO
break

case ACTION_MODE_LOITER:
new_mode = Mode::Number::LOITER
break

case ACTION_MODE_RTL:
new_mode = Mode::Number::RTL
break

case ACTION_MODE_CIRCLE:
new_mode = Mode::Number::CIRCLE
break

case ACTION_MODE_LAND:
new_mode = Mode::Number::LAND
break

case ACTION_MODE_DRIFT:
new_mode = Mode::Number::DRIFT
break

case ACTION_MODE_SPORT:
new_mode = Mode::Number::SPORT
break

case ACTION_MODE_AUTOTUNE:
new_mode = Mode::Number::AUTOTUNE
break

case ACTION_MODE_POSHOLD:
new_mode = Mode::Number::POSHOLD
break

case ACTION_MODE_BRAKE:
new_mode = Mode::Number::BRAKE
break

case ACTION_MODE_THROW:
new_mode = Mode::Number::THROW
gcs().send_text(MAV_SEVERITY_ERROR, ""Tmode: THROW is disabled"")
break

case ACTION_MODE_FLIP:
new_mode = Mode::Number::FLIP
break

case ACTION_MODE_STAB:
new_mode = Mode::Number::STABILIZE
break

case ACTION_MODE_FLOW:
if (old_mode != Mode::Number::FLOWHOLD) {
new_mode = Mode::Number::FLOWHOLD
} else {
new_mode = Mode::Number::ALT_HOLD
}
break

case ACTION_DISARM:
if (copter.motors->armed()) {
gcs().send_text(MAV_SEVERITY_ERROR, ""Tmode: Force disarm"")
copter.arming.disarm(AP_Arming::Method::TOYMODELANDFORCE)
}
break

case ACTION_TOGGLE_MODE:
last_mode_choice = (last_mode_choice+1) % 2
new_mode = Mode::Number(primary_mode[last_mode_choice].get())
break

case ACTION_TOGGLE_SIMPLE:
copter.set_simple_mode(bool(copter.simple_mode)?Copter::SimpleMode::NONE:Copter::SimpleMode::SIMPLE)
break

case ACTION_TOGGLE_SSIMPLE:
copter.set_simple_mode(bool(copter.simple_mode)?Copter::SimpleMode::NONE:Copter::SimpleMode::SUPERSIMPLE)
break

case ACTION_ARM_LAND_RTL:
if (!copter.motors->armed()) {
action_arm()
} else if (old_mode == Mode::Number::RTL) {
new_mode = Mode::Number::LOITER
} else if (old_mode == Mode::Number::LAND) {
if (last_set_mode == Mode::Number::LAND || !copter.position_ok()) {
new_mode = Mode::Number::ALT_HOLD
} else if (copter.landing_with_GPS()) {
new_mode = Mode::Number::LOITER
} else {
new_mode = Mode::Number::ALT_HOLD
}
} else if (copter.flightmode->requires_GPS()) {
new_mode = Mode::Number::RTL
} else {
new_mode = Mode::Number::LAND
}
break

case ACTION_LOAD_TEST:
if (copter.motors->armed() && !load_test.running) {
break
}
if (load_test.running) {
load_test.running = false
gcs().send_text(MAV_SEVERITY_INFO, ""Tmode: load_test off"")
copter.init_disarm_motors()
copter.set_mode(Mode::Number::ALT_HOLD, ModeReason::TOY_MODE)
} else {
copter.set_mode(Mode::Number::ALT_HOLD, ModeReason::TOY_MODE)
copter.fence.enable(false)
if (copter.arming.arm(AP_Arming::Method::MAVLINK)) {
load_test.running = true
gcs().send_text(MAV_SEVERITY_INFO, ""Tmode: load_test on"")
} else {
gcs().send_text(MAV_SEVERITY_INFO, ""Tmode: load_test failed"")
}
}
break
}

if (!copter.motors->armed() && (copter.flightmode->mode_number() == Mode::Number::LAND || copter.flightmode->mode_number() == Mode::Number::RTL)) {
new_mode = Mode::Number(primary_mode[last_mode_choice].get())
}

if (new_mode != copter.flightmode->mode_number()) {
load_test.running = false
copter.fence.enable(false)
if (set_and_remember_mode(new_mode, ModeReason::TOY_MODE)) {
gcs().send_text(MAV_SEVERITY_INFO, ""Tmode: mode %s"", copter.flightmode->name4())
if (copter.flightmode->requires_GPS()) {
copter.fence.enable(true)
}
} else {
gcs().send_text(MAV_SEVERITY_ERROR, ""Tmode: %u FAILED"", (unsigned)new_mode)
if (new_mode == Mode::Number::RTL) {
gcs().send_text(MAV_SEVERITY_ERROR, ""Tmode: LANDING"")
set_and_remember_mode(Mode::Number::LAND, ModeReason::TOY_MODE)
if (copter.landing_with_GPS()) {
copter.fence.enable(true)
}
}
}
}
}
"
645,Arducopter\toy_mode.cpp_set_and_remember_mode,"bool ToyMode::set_and_remember_mode(Mode::Number mode, ModeReason reason)
{
if (copter.flightmode->mode_number() == mode) {
return true
}
if (!copter.set_mode(mode, reason)) {
return false
}
last_set_mode = mode
return true
}
"
646,Arducopter\toy_mode.cpp_trim_update,"void ToyMode::trim_update(void)
{
if (hal.util->get_soft_armed() || copter.failsafe.radio) {
trim.start_ms = 0
return
}

uint16_t throttle_trim = copter.channel_throttle->get_radio_trim()
if (abs(throttle_trim - 1500) <= trim_auto) {
RC_Channel *c = copter.channel_throttle
uint16_t ch_min = c->get_radio_min()
uint16_t ch_max = c->get_radio_max()
int16_t new_value = 1000UL * (throttle_trim - ch_min) / (ch_max - ch_min)
if (new_value != throttle_mid) {
throttle_mid = new_value
gcs().send_text(MAV_SEVERITY_ERROR, ""Tmode: thr mid %d"",
throttle_mid)
}
}

uint16_t chan[4]
if (rc().get_radio_in(chan, 4) != 4) {
trim.start_ms = 0
return
}

const uint16_t noise_limit = 2
for (uint8_t i=0
if (abs(chan[i] - 1500) > trim_auto) {
trim.start_ms = 0
return
}
}

uint32_t now = AP_HAL::millis()

if (trim.start_ms == 0) {
memcpy(trim.chan, chan, 4*sizeof(uint16_t))
trim.start_ms = now
return
}


for (uint8_t i=0
if (abs(trim.chan[i] - chan[i]) > noise_limit) {
memcpy(trim.chan, chan, 4*sizeof(uint16_t))
trim.start_ms = now
return
}
}

if (now - trim.start_ms < 4000) {
return
}

trim.start_ms = 0

uint8_t need_trim = 0
for (uint8_t i=0
RC_Channel *c = RC_Channels::rc_channel(i)
if (c && abs(chan[i] - c->get_radio_trim()) > noise_limit) {
need_trim |= 1U<<i
}
}
if (need_trim == 0) {
return
}
for (uint8_t i=0
if (need_trim & (1U<<i)) {
RC_Channel *c = RC_Channels::rc_channel(i)
c->set_and_save_radio_trim(chan[i])
}
}

gcs().send_text(MAV_SEVERITY_ERROR, ""Tmode: trim %u %u %u %u"",
chan[0], chan[1], chan[2], chan[3])
}
"
647,Arducopter\toy_mode.cpp_action_arm,"void ToyMode::action_arm(void)
{
bool needs_gps = copter.flightmode->requires_GPS()

bool sticks_centered =
copter.channel_roll->get_control_in() == 0 &&
copter.channel_pitch->get_control_in() == 0 &&
copter.channel_yaw->get_control_in() == 0

if (!sticks_centered) {
gcs().send_text(MAV_SEVERITY_ERROR, ""Tmode: sticks not centered"")
return
}

arm_check_compass()

if (needs_gps && copter.arming.gps_checks(false)) {
copter.fence.enable(true)
copter.arming.arm(AP_Arming::Method::RUDDER)
if (!copter.motors->armed()) {
AP_Notify::events.arming_failed = true
gcs().send_text(MAV_SEVERITY_ERROR, ""Tmode: GPS arming failed"")
} else {
gcs().send_text(MAV_SEVERITY_ERROR, ""Tmode: GPS armed motors"")
}
} else if (needs_gps) {
AP_Notify::events.arming_failed = true
gcs().send_text(MAV_SEVERITY_ERROR, ""Tmode: GPS arming failed"")
} else {
copter.fence.enable(false)
copter.arming.arm(AP_Arming::Method::RUDDER)
if (!copter.motors->armed()) {
AP_Notify::events.arming_failed = true
gcs().send_text(MAV_SEVERITY_ERROR, ""Tmode: non-GPS arming failed"")
} else {
gcs().send_text(MAV_SEVERITY_ERROR, ""Tmode: non-GPS armed motors"")
}
}
}
"
648,Arducopter\toy_mode.cpp_throttle_adjust,"void ToyMode::throttle_adjust(float &throttle_control)
{
uint32_t now = AP_HAL::millis()
const uint32_t soft_start_ms = 5000
const uint16_t throttle_start = 600 + copter.g.throttle_deadzone
if (!copter.motors->armed() && (flags & FLAG_THR_ARM)) {
throttle_control = MIN(throttle_control, 500)
} else if (now - throttle_arm_ms < soft_start_ms) {
float p = (now - throttle_arm_ms) / float(soft_start_ms)
throttle_control = MIN(throttle_control, throttle_start + p * (1000 - throttle_start))
}

float height = copter.inertial_nav.get_position_z_up_cm() * 0.01 - copter.arming_altitude_m
if (throttle_control < 500 &&
height < TOY_DESCENT_SLOW_HEIGHT + TOY_DESCENT_SLOW_RAMP &&
copter.motors->armed() && !copter.ap.land_complete) {
float limit = linear_interpolate(TOY_DESCENT_SLOW_MIN, 0, height,
TOY_DESCENT_SLOW_HEIGHT, TOY_DESCENT_SLOW_HEIGHT+TOY_DESCENT_SLOW_RAMP)
if (throttle_control < limit) {
throttle_control = limit
}
}
}
"
649,Arducopter\toy_mode.cpp_blink_update,"void ToyMode::blink_update(void)
{
if (red_blink_pattern & (1U<<red_blink_index)) {
copter.relay.on(1)
} else {
copter.relay.off(1)
}
if (green_blink_pattern & (1U<<green_blink_index)) {
copter.relay.on(0)
} else {
copter.relay.off(0)
}
green_blink_index = (green_blink_index+1) % 16
red_blink_index = (red_blink_index+1) % 16
if (green_blink_index == 0 && green_blink_count > 0) {
green_blink_count--
}
if (red_blink_index == 0 && red_blink_count > 0) {
red_blink_count--
}

uint32_t now = AP_HAL::millis()
if (now - last_video_ms < 1000) {
AP_Notify::flags.video_recording = 1
} else {
AP_Notify::flags.video_recording = 0
}

if (red_blink_count > 0 && green_blink_count > 0) {
return
}

uint16_t pattern = 0

if (copter.motors->armed() && AP_Notify::flags.failsafe_battery) {
pattern = BLINK_8
} else if (!copter.motors->armed() && (blink_disarm > 0)) {
pattern = BLINK_8
blink_disarm--
} else {
pattern = BLINK_FULL
}

if (copter.motors->armed()) {
blink_disarm = 4
}

if (red_blink_count == 0) {
red_blink_pattern = pattern
}
if (green_blink_count == 0) {
green_blink_pattern = pattern
}
if (red_blink_count == 0 && green_blink_count == 0) {
red_blink_index = green_blink_index
}
}
"
650,Arducopter\toy_mode.cpp_handle_message,"void ToyMode::handle_message(const mavlink_message_t &msg)
{
if (msg.msgid != MAVLINK_MSG_ID_NAMED_VALUE_INT) {
return
}
mavlink_named_value_int_t m
mavlink_msg_named_value_int_decode(&msg, &m)
if (strncmp(m.name, ""BLINKR"", 10) == 0) {
red_blink_pattern = (uint16_t)m.value
red_blink_count = m.value >> 16
red_blink_index = 0
} else if (strncmp(m.name, ""BLINKG"", 10) == 0) {
green_blink_pattern = (uint16_t)m.value
green_blink_count = m.value >> 16
green_blink_index = 0
} else if (strncmp(m.name, ""VNOTIFY"", 10) == 0) {
if (green_blink_pattern != BLINK_2) {
green_blink_index = 0
}
green_blink_pattern = BLINK_2
green_blink_count = 1
last_video_ms = AP_HAL::millis()
AP_Notify::flags.video_recording = 1
} else if (strncmp(m.name, ""WIFICHAN"", 10) == 0) {
AP_Radio *radio = AP_Radio::get_singleton()
if (radio) {
radio->set_wifi_channel(m.value)
}
} else if (strncmp(m.name, ""LOGDISARM"", 10) == 0) {
enum ap_var_type vtype
AP_Int8 *log_disarmed = (AP_Int8 *)AP_Param::find(""LOG_DISARMED"", &vtype)
if (log_disarmed) {
log_disarmed->set(int8_t(m.value))
}
}
}
"
651,Arducopter\toy_mode.cpp_send_named_int,"void ToyMode::send_named_int(const char *name, int32_t value)
{
mavlink_msg_named_value_int_send(MAVLINK_COMM_1, AP_HAL::millis(), name, value)
}
"
652,Arducopter\toy_mode.cpp_thrust_limiting,"void ToyMode::thrust_limiting(float *thrust, uint8_t num_motors)
{
float thrust_mul = linear_interpolate(filter.thrust_max, filter.thrust_min, filtered_voltage, filter.volt_min, filter.volt_max)
for (uint8_t i=0
thrust[i] *= thrust_mul
}
uint16_t pwm[4]
hal.rcout->read(pwm, 4)


if (motor_log_counter++ % 10 == 0) {
AP::logger().WriteStreaming(""THST"", ""TimeUS,Vol,Mul,M1,M2,M3,M4"", ""QffHHHH"",
AP_HAL::micros64(),
(double)filtered_voltage,
(double)thrust_mul,
pwm[0], pwm[1], pwm[2], pwm[3])
}

}
"
653,Arducopter\toy_mode.cpp_load_test_run,"void ToyMode::load_test_run(void)
{
uint16_t pwm[4] {}
switch ((enum load_type)load_test.load_type.get()) {
case LOAD_TYPE_LOG1:
for (uint8_t i=0
pwm[i] = load_data1[load_test.row].m[i]
}
load_test.filter_counter++
if (load_test.filter_counter >= load_test.load_filter.get()) {
load_test.filter_counter = 0
load_test.row = (load_test.row + 1) % ARRAY_SIZE(load_data1)
}
break

case LOAD_TYPE_LOG2:
for (uint8_t i=0
pwm[i] = load_data1[load_test.row].m[0]
}
load_test.filter_counter++
if (load_test.filter_counter >= load_test.load_filter.get()) {
load_test.filter_counter = 0
load_test.row = (load_test.row + 1) % ARRAY_SIZE(load_data1)
}
break

case LOAD_TYPE_CONSTANT:
for (uint8_t i=0
pwm[i] = 500
}
break
default:
return
}
for (uint8_t i=0
pwm[i] *= load_test.load_mul
hal.rcout->write(i, 1000 + pwm[i]*2)
}

if (copter.failsafe.battery) {
gcs().send_text(MAV_SEVERITY_INFO, ""Tmode: load_test off (battery)"")
copter.init_disarm_motors()
load_test.running = false
}
}
"
654,Arducopter\toy_mode.cpp_arm_check_compass,"void ToyMode::arm_check_compass(void)
{
Vector3f offsets = copter.compass.get_offsets()
float field = copter.compass.get_field().length()

char unused_compass_configured_error_message[20]
if (offsets.length() > copter.compass.get_offsets_max() ||
field < 200 || field > 800 ||
!copter.compass.configured(unused_compass_configured_error_message, ARRAY_SIZE(unused_compass_configured_error_message))) {
if (copter.compass.get_learn_type() != Compass::LEARN_INFLIGHT) {
gcs().send_text(MAV_SEVERITY_INFO, ""Tmode: enable compass learning"")
copter.compass.set_learn_type(Compass::LEARN_INFLIGHT, false)
}
}
}
"
655,Arducopter\tuning.cpp_tuning,"void Copter::tuning()
{
const RC_Channel *rc6 = rc().channel(CH_6)

if ((g.radio_tuning <= 0) || (is_zero(g2.tuning_min.get()) && is_zero(g2.tuning_max.get()))) {
return
}

if (failsafe.radio || failsafe.radio_counter != 0 || rc6->get_radio_in() == 0) {
return
}

if ((RC_Channel::aux_func_t)rc6->option.get() != RC_Channel::AUX_FUNC::DO_NOTHING) {
return
}

const uint16_t radio_in = rc6->get_radio_in()
float tuning_value = linear_interpolate(g2.tuning_min, g2.tuning_max, radio_in, rc6->get_radio_min(), rc6->get_radio_max())
Log_Write_Parameter_Tuning(g.radio_tuning, tuning_value, g2.tuning_min, g2.tuning_max)

switch(g.radio_tuning) {

case TUNING_STABILIZE_ROLL_PITCH_KP:
attitude_control->get_angle_roll_p().kP(tuning_value)
attitude_control->get_angle_pitch_p().kP(tuning_value)
break

case TUNING_RATE_ROLL_PITCH_KP:
attitude_control->get_rate_roll_pid().kP(tuning_value)
attitude_control->get_rate_pitch_pid().kP(tuning_value)
break

case TUNING_RATE_ROLL_PITCH_KI:
attitude_control->get_rate_roll_pid().kI(tuning_value)
attitude_control->get_rate_pitch_pid().kI(tuning_value)
break

case TUNING_RATE_ROLL_PITCH_KD:
attitude_control->get_rate_roll_pid().kD(tuning_value)
attitude_control->get_rate_pitch_pid().kD(tuning_value)
break

case TUNING_STABILIZE_YAW_KP:
attitude_control->get_angle_yaw_p().kP(tuning_value)
break

case TUNING_YAW_RATE_KP:
attitude_control->get_rate_yaw_pid().kP(tuning_value)
break

case TUNING_YAW_RATE_KD:
attitude_control->get_rate_yaw_pid().kD(tuning_value)
break

case TUNING_ALTITUDE_HOLD_KP:
pos_control->get_pos_z_p().kP(tuning_value)
break

case TUNING_THROTTLE_RATE_KP:
pos_control->get_vel_z_pid().kP(tuning_value)
break

case TUNING_ACCEL_Z_KP:
pos_control->get_accel_z_pid().kP(tuning_value)
break

case TUNING_ACCEL_Z_KI:
pos_control->get_accel_z_pid().kI(tuning_value)
break

case TUNING_ACCEL_Z_KD:
pos_control->get_accel_z_pid().kD(tuning_value)
break

case TUNING_LOITER_POSITION_KP:
pos_control->get_pos_xy_p().kP(tuning_value)
break

case TUNING_VEL_XY_KP:
pos_control->get_vel_xy_pid().kP(tuning_value)
break

case TUNING_VEL_XY_KI:
pos_control->get_vel_xy_pid().kI(tuning_value)
break

case TUNING_WP_SPEED:
wp_nav->set_speed_xy(tuning_value)
break

case TUNING_ACRO_RP_RATE:
g2.command_model_acro_rp.set_rate(tuning_value)
break

case TUNING_ACRO_YAW_RATE:
g2.command_model_acro_y.set_rate(tuning_value)
break

case TUNING_HELI_EXTERNAL_GYRO:
motors->ext_gyro_gain(tuning_value)
break

case TUNING_RATE_PITCH_FF:
attitude_control->get_rate_pitch_pid().ff(tuning_value)
break

case TUNING_RATE_ROLL_FF:
attitude_control->get_rate_roll_pid().ff(tuning_value)
break

case TUNING_RATE_YAW_FF:
attitude_control->get_rate_yaw_pid().ff(tuning_value)
break

case TUNING_DECLINATION:
compass.set_declination(ToRad(tuning_value), false)
break

case TUNING_CIRCLE_RATE:
circle_nav->set_rate(tuning_value)
break

case TUNING_RC_FEEL_RP:
attitude_control->set_input_tc(tuning_value)
break

case TUNING_RATE_PITCH_KP:
attitude_control->get_rate_pitch_pid().kP(tuning_value)
break

case TUNING_RATE_PITCH_KI:
attitude_control->get_rate_pitch_pid().kI(tuning_value)
break

case TUNING_RATE_PITCH_KD:
attitude_control->get_rate_pitch_pid().kD(tuning_value)
break

case TUNING_RATE_ROLL_KP:
attitude_control->get_rate_roll_pid().kP(tuning_value)
break

case TUNING_RATE_ROLL_KI:
attitude_control->get_rate_roll_pid().kI(tuning_value)
break

case TUNING_RATE_ROLL_KD:
attitude_control->get_rate_roll_pid().kD(tuning_value)
break

case TUNING_RATE_MOT_YAW_HEADROOM:
motors->set_yaw_headroom(tuning_value)
break

case TUNING_RATE_YAW_FILT:
attitude_control->get_rate_yaw_pid().filt_E_hz(tuning_value)
break

case TUNING_SYSTEM_ID_MAGNITUDE:
copter.mode_systemid.set_magnitude(tuning_value)
break
}
}
"
656,Arducopter\UserCode.cpp_userhook_init,"void Copter::userhook_init()
{
}
"
657,Arducopter\UserCode.cpp_userhook_FastLoop,"void Copter::userhook_FastLoop()
{
}
"
658,Arducopter\UserCode.cpp_userhook_50Hz,"void Copter::userhook_50Hz()
{
}
"
659,Arducopter\UserCode.cpp_userhook_MediumLoop,"void Copter::userhook_MediumLoop()
{
}
"
660,Arducopter\UserCode.cpp_userhook_SlowLoop,"void Copter::userhook_SlowLoop()
{
}
"
661,Arducopter\UserCode.cpp_userhook_SuperSlowLoop,"void Copter::userhook_SuperSlowLoop()
{
}
"
662,Arducopter\UserCode.cpp_userhook_auxSwitch1,"void Copter::userhook_auxSwitch1(const RC_Channel::AuxSwitchPos ch_flag)
{
}
"
663,Arducopter\UserCode.cpp_userhook_auxSwitch2,"void Copter::userhook_auxSwitch2(const RC_Channel::AuxSwitchPos ch_flag)
{
}
"
664,Arducopter\UserCode.cpp_userhook_auxSwitch3,"void Copter::userhook_auxSwitch3(const RC_Channel::AuxSwitchPos ch_flag)
{
}
"
